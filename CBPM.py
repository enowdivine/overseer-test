"""
Cameroon Building Project Management System (CBPM)
A comprehensive role-based system for managing building projects in Cameroon
"""

import sqlite3
import hashlib
# Tkinter may not be available on Android; import defensively
try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
    HAS_TK = True
except Exception:
    tk = None
    ttk = None
    messagebox = None
    filedialog = None
    HAS_TK = False
from datetime import datetime, date
import json
import os
import logging
# Matplotlib is optional; the app should still start without it
try:
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    HAS_MATPLOTLIB = True
except Exception:
    plt = None
    FigureCanvasTkAgg = None
    HAS_MATPLOTLIB = False
# Pandas is optional; the app should still start without it
try:
    import pandas as pd
    HAS_PANDAS = True
except Exception:
    pd = None
    HAS_PANDAS = False
from typing import Optional
from config import DATABASE_NAME, ROLE_JOB_SEEKER, SCALABILITY_SETTINGS, CLOUD_DB_SETTINGS
# Cryptography is optional; app should start without it
try:
    from cryptography.fernet import Fernet
    HAS_CRYPTO = True
except Exception:
    Fernet = None
    HAS_CRYPTO = False
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Explicit adapters for SQLite to avoid Python 3.12 datetime deprecation warnings
# Store Python date/datetime as ISO strings when writing to SQLite
sqlite3.register_adapter(date, lambda d: d.isoformat())
sqlite3.register_adapter(datetime, lambda dt: dt.isoformat(sep=' '))


# Cloud synchronization for shared SQLite database
class CloudSyncManager:
    def __init__(self, db_name=DATABASE_NAME):
        self.db_name = db_name
        self.settings = CLOUD_DB_SETTINGS
        self.local_backup_dir = os.path.join(os.path.expanduser('~'), 'Documents', 'CBPM', 'backups')
        os.makedirs(self.local_backup_dir, exist_ok=True)
    
    def sync_from_cloud(self):
        """Download database from cloud storage if enabled"""
        if not self.settings.get('enabled', False):
            return True
        
        try:
            provider = self.settings.get('provider', 'local')
            remote_path = self.settings.get('remote_path', '')
            
            if provider == 'ftp' and remote_path:
                return self._sync_ftp_download(remote_path)
            elif provider == 'google_drive':
                return self._sync_google_drive_download()
            # Add other providers as needed
            
        except Exception as e:
            print(f"Cloud sync download failed: {e}")
            return False
        return True
    
    def sync_to_cloud(self):
        """Upload database to cloud storage if enabled"""
        if not self.settings.get('enabled', False):
            return True
            
        try:
            provider = self.settings.get('provider', 'local')
            remote_path = self.settings.get('remote_path', '')
            
            if provider == 'ftp' and remote_path:
                return self._sync_ftp_upload(remote_path)
            elif provider == 'google_drive':
                return self._sync_google_drive_upload()
            
        except Exception as e:
            print(f"Cloud sync upload failed: {e}")
            return False
        return True
    
    def _sync_ftp_download(self, remote_path):
        """Simple FTP download implementation"""
        # Basic FTP implementation - you'd need to add FTP credentials to config
        return True
    
    def _sync_ftp_upload(self, remote_path):
        """Simple FTP upload implementation"""
        # Basic FTP implementation - you'd need to add FTP credentials to config
        return True
    
    def _sync_google_drive_download(self):
        """Download database from Google Drive"""
        try:
            file_id = self.settings.get('google_drive_file_id')
            if not file_id:
                print("Google Drive file ID not configured")
                return False
            
            # Download using direct link (works for public files)
            import requests
            download_url = f"https://drive.google.com/uc?export=download&id={file_id}"
            
            response = requests.get(download_url)
            if response.status_code == 200:
                # Create backup of existing file
                self.create_backup()
                
                # Write new content
                with open(self.db_name, 'wb') as f:
                    f.write(response.content)
                print(f"Successfully downloaded database from Google Drive")
                return True
            else:
                print(f"Failed to download from Google Drive: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"Google Drive download failed: {e}")
            return False
    
    def _sync_google_drive_upload(self):
        """Upload database to Google Drive"""
        # For now, we'll skip upload since it requires OAuth setup
        # Users can manually upload the updated database file
        print("Note: For changes to be shared, manually upload your updated database file to Google Drive")
        print(f"File to upload: '{self.db_name}'")
        return True
    
    def create_backup(self):
        """Create local backup of database"""
        if not self.settings.get('backup_enabled', True):
            return
            
        try:
            if os.path.exists(self.db_name):
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                backup_name = f"backup_{timestamp}_{os.path.basename(self.db_name)}"
                backup_path = os.path.join(self.local_backup_dir, backup_name)
                
                import shutil
                shutil.copy2(self.db_name, backup_path)
                
                # Keep only last 5 backups
                backups = [f for f in os.listdir(self.local_backup_dir) if f.startswith('backup_')]
                backups.sort()
                while len(backups) > 5:
                    os.remove(os.path.join(self.local_backup_dir, backups.pop(0)))
                    
        except Exception as e:
            print(f"Backup creation failed: {e}")

# Database setup and initial data
class DatabaseManager:
    def __init__(self, db_name=DATABASE_NAME):
        self.db_name = db_name
        self.cloud_sync = CloudSyncManager(db_name)
        
        # Sync from cloud before initializing
        self.cloud_sync.sync_from_cloud()
        
        try:
            self.create_tables()
        except sqlite3.DatabaseError as e:
            # Attempt recovery from malformed database
            try:
                self._recover_malformed_database(e)
                self.create_tables()
            except Exception:
                raise
        self.populate_building_materials()

    def _recover_malformed_database(self, error: Exception):
        """Backup malformed SQLite DB and start fresh.
        Renames the existing DB file with a timestamp, then leaves a new empty file to be initialized.
        """
        try:
            # Only handle malformed database errors
            msg = str(error).lower()
            if 'malformed' not in msg and 'database disk image is malformed' not in msg:
                raise error
        except Exception:
            pass
        # Ensure directory exists
        try:
            db_path = self.db_name
            # If file exists, back it up
            if os.path.exists(db_path):
                base, ext = os.path.splitext(db_path)
                from datetime import datetime as _dt
                ts = _dt.now().strftime('%Y%m%d-%H%M%S')
                backup_path = f"{base}.corrupt-{ts}{ext or '.db'}.bak"
                try:
                    os.replace(db_path, backup_path)
                except Exception:
                    # Fallback: copy then truncate
                    try:
                        import shutil
                        shutil.copy2(db_path, backup_path)
                        with open(db_path, 'wb') as f:
                            f.truncate(0)
                    except Exception:
                        pass
                # Inform user if UI available
                try:
                    messagebox.showwarning(
                        "Database Recovery",
                        f"The database file was corrupted and has been backed up to:\n{backup_path}\n\n"
                        f"A new database will be created."
                    )
                except Exception:
                    pass
            else:
                # Ensure parent directory exists for OneDrive paths
                parent = os.path.dirname(db_path)
                if parent and not os.path.isdir(parent):
                    os.makedirs(parent, exist_ok=True)
        except Exception:
            # As a last resort, try to remove file
            try:
                if os.path.exists(self.db_name):
                    os.remove(self.db_name)
            except Exception:
                pass

    def create_connection(self):
        """Create and configure a SQLite connection.

        Returns:
            sqlite3.Connection: An open SQLite connection configured with PRAGMA settings.
        """
        # Use a small busy timeout to mitigate 'database is locked' errors and enable WAL for concurrency
        try:
            conn = sqlite3.connect(self.db_name, timeout=5)
        except sqlite3.DatabaseError as e:
            # If the database file is malformed, try recovery once, then reconnect
            self._recover_malformed_database(e)
            conn = sqlite3.connect(self.db_name, timeout=5)
        try:
            print(f"[DEBUG] opened DB at: {self.db_name}")
        except Exception:
            pass
        try:
            # Apply scalability PRAGMAs from config
            _s = SCALABILITY_SETTINGS.get('sqlite', {}) if 'SCALABILITY_SETTINGS' in globals() or 'SCALABILITY_SETTINGS' in locals() else {}
            bt = int(_s.get('busy_timeout', 5000))
            conn.execute(f"PRAGMA busy_timeout={bt}")
            jm = _s.get('journal_mode', 'WAL')
            try:
                conn.execute(f"PRAGMA journal_mode={jm}")
            except Exception:
                # Fallback to WAL if custom failed
                try:
                    conn.execute("PRAGMA journal_mode=WAL")
                except Exception:
                    pass
            syn = _s.get('synchronous', 'NORMAL')
            try:
                conn.execute(f"PRAGMA synchronous={syn}")
            except Exception:
                pass
            try:
                if _s.get('foreign_keys', 1):
                    conn.execute("PRAGMA foreign_keys=ON")
            except Exception:
                pass
            try:
                cs = int(_s.get('cache_size', -20000))
                conn.execute(f"PRAGMA cache_size={cs}")
            except Exception:
                pass
            try:
                ts = int(_s.get('temp_store', 2))
                conn.execute(f"PRAGMA temp_store={ts}")
            except Exception:
                pass
        except Exception:
            pass
        return conn

    def create_tables(self):
        conn = self.create_connection()
        cursor = conn.cursor()

        # Users table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS users
                       (
                           id
                           INTEGER
                           PRIMARY
                           KEY
                           AUTOINCREMENT,
                           username
                           TEXT
                           UNIQUE
                           NOT
                           NULL,
                           email
                           TEXT
                           UNIQUE
                           NOT
                           NULL,
                           password_hash
                           TEXT
                           NOT
                           NULL,
                           role
                           TEXT
                           NOT
                           NULL,
                           full_name
                           TEXT
                           NOT
                           NULL,
                           phone
                           TEXT,
                           address
                           TEXT,
                           created_date
                           DATE
                           NOT
                           NULL,
                           last_login
                           DATETIME,
                           is_active
                           BOOLEAN
                           DEFAULT
                           1,
                           first_login
                           BOOLEAN
                           DEFAULT
                           1,
                           failed_login_attempts
                           INTEGER
                           DEFAULT
                           0,
                           profile_picture
                           TEXT,
                           digital_signature
                           TEXT
                       )
                       ''')

        # Building materials table (Cameroon specific)
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS building_materials
                       (
                           id
                           INTEGER
                           PRIMARY
                           KEY
                           AUTOINCREMENT,
                           name
                           TEXT
                           NOT
                           NULL,
                           category
                           TEXT
                           NOT
                           NULL,
                           unit
                           TEXT
                           NOT
                           NULL,
                           standard_price
                           REAL
                           NOT
                           NULL,
                           supplier
                           TEXT,
                           description
                           TEXT,
                           local_name
                           TEXT,
                           availability
                           TEXT
                           DEFAULT
                           'Available',
                           created_date
                           DATE
                           NOT
                           NULL
                       )
                       ''')
        # Ensure columns for custom, owner-scoped materials exist (backward compatible)
        try:
            cursor.execute("ALTER TABLE building_materials ADD COLUMN is_custom INTEGER DEFAULT 0")
        except Exception:
            pass
        try:
            cursor.execute("ALTER TABLE building_materials ADD COLUMN owner_id INTEGER")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_materials_owner ON building_materials(owner_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_materials_custom ON building_materials(is_custom)")
        except Exception:
            pass

        # Stores table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS stores
                       (
                           id
                           INTEGER
                           PRIMARY
                           KEY
                           AUTOINCREMENT,
                           name
                           TEXT
                           NOT
                           NULL,
                           location
                           TEXT
                           NOT
                           NULL,
                           owner_id
                           INTEGER
                           NOT
                           NULL,
                           manager_id
                           INTEGER,
                           contact_info
                           TEXT,
                           created_date
                           DATE
                           NOT
                           NULL,
                           is_active
                           BOOLEAN
                           DEFAULT
                           1,
                           FOREIGN
                           KEY
                       (
                           owner_id
                       ) REFERENCES users
                       (
                           id
                       ),
                           FOREIGN KEY
                       (
                           manager_id
                       ) REFERENCES users
                       (
                           id
                       )
                           )
                       ''')
        # Backward-compatible column to track if a store is currently open (1) or closed (0)
        try:
            cursor.execute("ALTER TABLE stores ADD COLUMN is_open INTEGER DEFAULT 1")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_stores_open ON stores(is_open)")
        except Exception:
            pass

        # Inventory table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS inventory
                       (
                           id
                           INTEGER
                           PRIMARY
                           KEY
                           AUTOINCREMENT,
                           store_id
                           INTEGER
                           NOT
                           NULL,
                           material_id
                           INTEGER
                           NOT
                           NULL,
                           quantity
                           REAL
                           NOT
                           NULL,
                           unit_price
                           REAL
                           NOT
                           NULL,
                           reorder_level
                           REAL
                           DEFAULT
                           10,
                           last_updated
                           DATETIME
                           NOT
                           NULL,
                           FOREIGN
                           KEY
                       (
                           store_id
                       ) REFERENCES stores
                       (
                           id
                       ),
                           FOREIGN KEY
                       (
                           material_id
                       ) REFERENCES building_materials
                       (
                           id
                       )
                           )
                       ''')
        # Ensure unique inventory entry per store-material
        try:
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS ux_inventory_store_material ON inventory(store_id, material_id)")
        except Exception:
            pass

        # Performance indexes for scalability (safe to run repeatedly)
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_users_role ON users(role)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_users_is_active ON users(is_active)")
        except Exception:
            pass
        # Ensure created_by column exists for ownership scoping (idempotent migration)
        try:
            cursor.execute("ALTER TABLE users ADD COLUMN created_by INTEGER")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_users_created_by ON users(created_by)")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_stores_owner ON stores(owner_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_stores_manager ON stores(manager_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_stores_active ON stores(is_active)")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_inventory_store ON inventory(store_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_inventory_material ON inventory(material_id)")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_transactions_store ON transactions(store_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_transactions_material ON transactions(material_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_transactions_date ON transactions(transaction_date)")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_contracts_owner ON contracts(contract_owner_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_contracts_contractor ON contracts(contractor_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_contracts_status ON contracts(status)")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_jobs_employer ON jobs(employer_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_jobs_status ON jobs(status)")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_job_apps_job ON job_applications(job_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_job_apps_status ON job_applications(status)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_job_apps_applicant ON job_applications(applicant_id)")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_audit_user ON audit_log(user_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_audit_time ON audit_log(timestamp)")
        except Exception:
            pass

        # Contracts table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS contracts
                       (
                           id
                           INTEGER
                           PRIMARY
                           KEY
                           AUTOINCREMENT,
                           title
                           TEXT
                           NOT
                           NULL,
                           description
                           TEXT,
                           contract_owner_id
                           INTEGER
                           NOT
                           NULL,
                           contractor_id
                           INTEGER,
                           start_date
                           DATE,
                           end_date
                           DATE,
                           budget
                           REAL,
                           status
                           TEXT
                           DEFAULT
                           'Draft',
                           digital_signature_owner
                           TEXT,
                           digital_signature_contractor
                           TEXT,
                           created_date
                           DATE
                           NOT
                           NULL,
                           FOREIGN
                           KEY
                       (
                           contract_owner_id
                       ) REFERENCES users
                       (
                           id
                       ),
                           FOREIGN KEY
                       (
                           contractor_id
                       ) REFERENCES users
                       (
                           id
                       )
                           )
                       ''')
        # Ensure backward-compatible columns exist (added in later versions)
        try:
            cursor.execute("ALTER TABLE contracts ADD COLUMN requirements TEXT")
        except Exception:
            pass
        try:
            cursor.execute("ALTER TABLE contracts ADD COLUMN owner_signature BLOB")
        except Exception:
            pass
        try:
            cursor.execute("ALTER TABLE contracts ADD COLUMN contractor_signature BLOB")
        except Exception:
            pass
        # New fields: contract kind and materials inclusion (backward-compatible)
        try:
            cursor.execute("ALTER TABLE contracts ADD COLUMN contract_kind TEXT DEFAULT 'Labour Only'")
        except Exception:
            pass
        try:
            cursor.execute("ALTER TABLE contracts ADD COLUMN includes_materials INTEGER DEFAULT 0")
        except Exception:
            pass

        # Contract payments table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS contract_payments
                       (
                           id INTEGER PRIMARY KEY AUTOINCREMENT,
                           contract_id INTEGER NOT NULL,
                           amount REAL NOT NULL,
                           method TEXT,
                           reference TEXT,
                           status TEXT DEFAULT 'Pending',
                           requested_by INTEGER,
                           requested_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                           confirmed_by INTEGER,
                           confirmed_at DATETIME,
                           notes TEXT,
                           FOREIGN KEY(contract_id) REFERENCES contracts(id),
                           FOREIGN KEY(requested_by) REFERENCES users(id),
                           FOREIGN KEY(confirmed_by) REFERENCES users(id)
                       )
                       ''')
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_cp_contract ON contract_payments(contract_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_cp_status ON contract_payments(status)")
        except Exception:
            pass
        # Backward-compatible: account fields for contract payments
        try:
            cursor.execute("ALTER TABLE contract_payments ADD COLUMN payer_account TEXT")
        except Exception:
            pass
        try:
            cursor.execute("ALTER TABLE contract_payments ADD COLUMN method_account TEXT")
        except Exception:
            pass

        # Contract ledger table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS contract_ledger
                       (
                           id INTEGER PRIMARY KEY AUTOINCREMENT,
                           contract_id INTEGER NOT NULL,
                           entry_type TEXT NOT NULL,
                           amount REAL NOT NULL,
                           ref_payment_id INTEGER,
                           description TEXT,
                           created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                           FOREIGN KEY(contract_id) REFERENCES contracts(id),
                           FOREIGN KEY(ref_payment_id) REFERENCES contract_payments(id)
                       )
                       ''')
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_cl_contract ON contract_ledger(contract_id)")
        except Exception:
            pass

        # Transactions table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS transactions
                       (
                           id
                           INTEGER
                           PRIMARY
                           KEY
                           AUTOINCREMENT,
                           store_id
                           INTEGER
                           NOT
                           NULL,
                           customer_name
                           TEXT,
                           material_id
                           INTEGER
                           NOT
                           NULL,
                           quantity
                           REAL
                           NOT
                           NULL,
                           unit_price
                           REAL
                           NOT
                           NULL,
                           total_amount
                           REAL
                           NOT
                           NULL,
                           transaction_type
                           TEXT
                           NOT
                           NULL,
                           payment_status
                           TEXT
                           DEFAULT
                           'Pending',
                           transaction_date
                           DATETIME
                           NOT
                           NULL,
                           user_id
                           INTEGER
                           NOT
                           NULL,
                           FOREIGN
                           KEY
                       (
                           store_id
                       ) REFERENCES stores
                       (
                           id
                       ),
                           FOREIGN KEY
                       (
                           material_id
                       ) REFERENCES building_materials
                       (
                           id
                       ),
                           FOREIGN KEY
                       (
                           user_id
                       ) REFERENCES users
                       (
                           id
                       )
                           )
                       ''')
        # Backward-compat: ensure legacy 'timestamp' column exists and is populated
        try:
            cursor.execute("ALTER TABLE transactions ADD COLUMN timestamp DATETIME")
        except Exception:
            pass
        try:
            cursor.execute("UPDATE transactions SET timestamp = transaction_date WHERE timestamp IS NULL")
        except Exception:
            pass

        # Purchase requests table (centralized)
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS purchase_requests
                       (
                           id INTEGER PRIMARY KEY AUTOINCREMENT,
                           created_at TEXT NOT NULL,
                           buyer_id INTEGER NOT NULL,
                           store_id INTEGER NOT NULL,
                           buyer_store_id INTEGER,
                           material_id INTEGER NOT NULL,
                           quantity REAL NOT NULL,
                           unit_price REAL NOT NULL,
                           notes TEXT,
                           status TEXT NOT NULL DEFAULT 'Pending',
                           approved_by INTEGER,
                           approved_at TEXT,
                           FOREIGN KEY(store_id) REFERENCES stores(id),
                           FOREIGN KEY(buyer_store_id) REFERENCES stores(id),
                           FOREIGN KEY(material_id) REFERENCES building_materials(id),
                           FOREIGN KEY(buyer_id) REFERENCES users(id),
                           FOREIGN KEY(approved_by) REFERENCES users(id)
                       )
                       ''')
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_pr_store_status ON purchase_requests(store_id, status)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_pr_buyer ON purchase_requests(buyer_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_pr_material ON purchase_requests(material_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_pr_buyer_store ON purchase_requests(buyer_store_id)")
        except Exception:
            pass
        # Backward compat: add buyer_store_id if missing
        try:
            cursor.execute("PRAGMA table_info(purchase_requests)")
            cols = [r[1] for r in cursor.fetchall()]
            if 'buyer_store_id' not in cols:
                cursor.execute("ALTER TABLE purchase_requests ADD COLUMN buyer_store_id INTEGER")
        except Exception:
            pass

        # Payments table (two-party confirmation)
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS payments
                       (
                           id INTEGER PRIMARY KEY AUTOINCREMENT,
                           reference TEXT UNIQUE,
                           payer_id INTEGER NOT NULL,
                           payee_id INTEGER NOT NULL,
                           store_id INTEGER,
                           amount REAL NOT NULL,
                           currency TEXT DEFAULT 'XAF',
                           method TEXT,
                           purpose TEXT,
                           status TEXT NOT NULL DEFAULT 'Pending',
                           created_at TEXT NOT NULL,
                           confirmed_at TEXT,
                           confirmed_by INTEGER,
                           meta TEXT,
                           require_receipt INTEGER DEFAULT 0,
                           receipt_printed INTEGER DEFAULT 0,
                           FOREIGN KEY(payer_id) REFERENCES users(id),
                           FOREIGN KEY(payee_id) REFERENCES users(id),
                           FOREIGN KEY(confirmed_by) REFERENCES users(id),
                           FOREIGN KEY(store_id) REFERENCES stores(id)
                       )
                       ''')
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_payments_payer ON payments(payer_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_payments_payee ON payments(payee_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_payments_status ON payments(status)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_payments_store ON payments(store_id)")
        except Exception:
            pass

        # Refunds table linked to payments
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS refunds
                       (
                           id INTEGER PRIMARY KEY AUTOINCREMENT,
                           payment_id INTEGER NOT NULL,
                           amount REAL NOT NULL,
                           reason TEXT,
                           status TEXT NOT NULL DEFAULT 'Pending',
                           requested_by INTEGER NOT NULL,
                           requested_at TEXT NOT NULL,
                           confirmed_by INTEGER,
                           confirmed_at TEXT,
                           FOREIGN KEY(payment_id) REFERENCES payments(id),
                           FOREIGN KEY(requested_by) REFERENCES users(id),
                           FOREIGN KEY(confirmed_by) REFERENCES users(id)
                       )
                       ''')
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_refunds_payment ON refunds(payment_id)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_refunds_status ON refunds(status)")
        except Exception:
            pass

        # Backward-compatible: store-level receipt printing preference
        try:
            cursor.execute("ALTER TABLE stores ADD COLUMN print_receipt_default INTEGER DEFAULT 1")
        except Exception:
            pass

        # Backward-compatible: receipt template per store
        try:
            cursor.execute("ALTER TABLE stores ADD COLUMN receipt_template TEXT")
        except Exception:
            pass

        # Backward-compatible: additional payment security/metadata columns
        try:
            cursor.execute("ALTER TABLE payments ADD COLUMN payer_account TEXT")
        except Exception:
            pass
        try:
            cursor.execute("ALTER TABLE payments ADD COLUMN method_account TEXT")
        except Exception:
            pass
        try:
            cursor.execute("ALTER TABLE payments ADD COLUMN link_type TEXT")
        except Exception:
            pass
        try:
            cursor.execute("ALTER TABLE payments ADD COLUMN link_id INTEGER")
        except Exception:
            pass
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_payments_link ON payments(link_type, link_id)")
        except Exception:
            pass

        # Jobs table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS jobs
                       (
                           id
                           INTEGER
                           PRIMARY
                           KEY
                           AUTOINCREMENT,
                           title
                           TEXT
                           NOT
                           NULL,
                           description
                           TEXT,
                           employer_id
                           INTEGER
                           NOT
                           NULL,
                           location
                           TEXT,
                           salary_range
                           TEXT,
                           requirements
                           TEXT,
                           status
                           TEXT
                           DEFAULT
                           'Open',
                           posted_date
                           DATE
                           NOT
                           NULL,
                           deadline
                           DATE,
                           FOREIGN
                           KEY
                       (
                           employer_id
                       ) REFERENCES users
                       (
                           id
                       )
                           )
                       ''')

        # Job applications table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS job_applications
                       (
                           id
                           INTEGER
                           PRIMARY
                           KEY
                           AUTOINCREMENT,
                           job_id
                           INTEGER
                           NOT
                           NULL,
                           applicant_id
                           INTEGER
                           NOT
                           NULL,
                           application_date
                           DATE
                           NOT
                           NULL,
                           status
                           TEXT
                           DEFAULT
                           'Submitted',
                           resume_path
                           TEXT,
                           cover_letter
                           TEXT,
                           FOREIGN
                           KEY
                       (
                           job_id
                       ) REFERENCES jobs
                       (
                           id
                       ),
                           FOREIGN KEY
                       (
                           applicant_id
                       ) REFERENCES users
                       (
                           id
                       )
                           )
                       ''')

        # Helpful indexes for performance (idempotent)
        try:
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_jobs_status_date ON jobs(status, posted_date)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_jobs_location ON jobs(location)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_job_apps_applicant_status ON job_applications(applicant_id, status)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_job_apps_job ON job_applications(job_id)")
        except Exception:
            pass

        # Seed minimal test data if necessary (safe, idempotent)
        try:
            cursor.execute("SELECT COUNT(*) FROM jobs")
            _job_count = cursor.fetchone()[0]
            if _job_count == 0:
                # Create a sample employer user if none exists
                cursor.execute("SELECT id FROM users WHERE role='employer' LIMIT 1")
                row = cursor.fetchone()
                if row:
                    emp_id = row[0]
                else:
                    # Create a lightweight employer
                    cursor.execute(
                        "INSERT INTO users(username, email, password_hash, role, full_name, phone, address, created_date, is_active, first_login) VALUES (?,?,?,?,?,?,?,?,?,?)",
                        (
                            'demo_employer',
                            'demo_employer@example.com',
                            hashlib.sha256('Password1!'.encode()).hexdigest(),
                            'employer',
                            'Demo Employer',
                            '+237600000000',
                            'Douala',
                            date.today(),
                            1,
                            0
                        )
                    )
                    emp_id = cursor.lastrowid
                # Insert a couple of jobs
                cursor.execute(
                    "INSERT INTO jobs(title, description, employer_id, location, salary_range, requirements, status, posted_date, deadline) VALUES (?,?,?,?,?,?,?,?,?)",
                    (
                        'Site Engineer',
                        'Oversee construction activities and ensure quality standards.',
                        emp_id,
                        'Douala',
                        '300k-500k XAF',
                        'Bachelor in Civil Engineering; 3+ years experience',
                        'Open',
                        date.today(),
                        date.today()
                    )
                )
                cursor.execute(
                    "INSERT INTO jobs(title, description, employer_id, location, salary_range, requirements, status, posted_date, deadline) VALUES (?,?,?,?,?,?,?,?,?)",
                    (
                        'Procurement Officer',
                        'Manage material sourcing and supplier relations.',
                        emp_id,
                        'Yaoundé',
                        '200k-350k XAF',
                        'Procurement experience; Excel skills',
                        'Open',
                        date.today(),
                        date.today()
                    )
                )
        except Exception:
            pass

        # Audit log table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS audit_log
                       (
                           id
                           INTEGER
                           PRIMARY
                           KEY
                           AUTOINCREMENT,
                           user_id
                           INTEGER,
                           action
                           TEXT
                           NOT
                           NULL,
                           details
                           TEXT,
                           timestamp
                           DATETIME
                           NOT
                           NULL,
                           ip_address
                           TEXT,
                           FOREIGN
                           KEY
                       (
                           user_id
                       ) REFERENCES users
                       (
                           id
                       )
                           )
                       ''')

        # Customers table (simple CRM)
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS customers
                       (
                           id INTEGER PRIMARY KEY AUTOINCREMENT,
                           name TEXT UNIQUE NOT NULL,
                           phone TEXT,
                           email TEXT,
                           address TEXT,
                           notes TEXT,
                           created_date DATE NOT NULL
                       )
                       ''')

        # Transfers header table
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS transfers
                       (
                           id INTEGER PRIMARY KEY AUTOINCREMENT,
                           reference TEXT UNIQUE NOT NULL,
                           source_store_id INTEGER NOT NULL,
                           dest_store_id INTEGER NOT NULL,
                           total_items INTEGER NOT NULL,
                           total_value REAL NOT NULL,
                           status TEXT NOT NULL DEFAULT 'Completed',
                           reason TEXT,
                           notes TEXT,
                           signature_name TEXT,
                           signature_date DATETIME,
                           created_at DATETIME NOT NULL,
                           initiated_by INTEGER NOT NULL,
                           FOREIGN KEY(source_store_id) REFERENCES stores(id),
                           FOREIGN KEY(dest_store_id) REFERENCES stores(id),
                           FOREIGN KEY(initiated_by) REFERENCES users(id)
                       )
                       ''')
        # Transfer line items
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS transfer_items
                       (
                           id INTEGER PRIMARY KEY AUTOINCREMENT,
                           transfer_id INTEGER NOT NULL,
                           material_id INTEGER NOT NULL,
                           quantity REAL NOT NULL,
                           unit TEXT,
                           unit_price REAL NOT NULL,
                           total REAL NOT NULL,
                           FOREIGN KEY(transfer_id) REFERENCES transfers(id),
                           FOREIGN KEY(material_id) REFERENCES building_materials(id)
                       )
                       ''')

        conn.commit()
        conn.close()

    def populate_building_materials(self):
        """Populate database with common building materials used in Cameroon"""
        conn = self.create_connection()
        cursor = conn.cursor()

        # Check if materials already exist
        cursor.execute("SELECT COUNT(*) FROM building_materials")
        if cursor.fetchone()[0] > 0:
            conn.close()
            return

        materials = [
            # Cement and Binding Materials
            ("Cement Portland", "Cement", "Bag (50kg)", 6500, "CIMENCAM", "Standard Portland cement", "Ciment",
             "Available"),
            ("Cement Super", "Cement", "Bag (50kg)", 7000, "CIMENCAM", "High strength cement", "Ciment Super",
             "Available"),
            ("Lime", "Binding", "Bag (25kg)", 2000, "Local Supplier", "Building lime", "Chaux", "Available"),
            ("Mortar Mix", "Cement", "Bag (25kg)", 3500, "Various", "Ready mortar mix", "Mortier", "Available"),

            # Aggregates
            ("Sand (River)", "Aggregate", "Cubic Meter", 15000, "Local Quarry", "River sand for construction",
             "Sable de rivière", "Available"),
            ("Sand (Sea)", "Aggregate", "Cubic Meter", 12000, "Coastal Supplier", "Sea sand", "Sable de mer",
             "Available"),
            ("Gravel (4/6)", "Aggregate", "Cubic Meter", 18000, "Local Quarry", "Small gravel 4-6mm", "Gravier petit",
             "Available"),
            ("Gravel (6/10)", "Aggregate", "Cubic Meter", 20000, "Local Quarry", "Medium gravel 6-10mm",
             "Gravier moyen", "Available"),
            ("Gravel (10/14)", "Aggregate", "Cubic Meter", 22000, "Local Quarry", "Large gravel 10-14mm",
             "Gravier gros", "Available"),
            ("Stone (Hardcore)", "Aggregate", "Cubic Meter", 25000, "Local Quarry", "Foundation stone",
             "Pierre de fondation", "Available"),

            # Steel and Metal
            ("Rebar 8mm", "Steel", "Piece (12m)", 4500, "ALUCAM", "8mm reinforcement bar", "Fer à béton 8mm",
             "Available"),
            ("Rebar 10mm", "Steel", "Piece (12m)", 6800, "ALUCAM", "10mm reinforcement bar", "Fer à béton 10mm",
             "Available"),
            ("Rebar 12mm", "Steel", "Piece (12m)", 9500, "ALUCAM", "12mm reinforcement bar", "Fer à béton 12mm",
             "Available"),
            ("Rebar 16mm", "Steel", "Piece (12m)", 16000, "ALUCAM", "16mm reinforcement bar", "Fer à béton 16mm",
             "Available"),
            ("Wire Mesh", "Steel", "Roll", 45000, "ALUCAM", "Welded wire mesh", "Grillage soudé", "Available"),
            ("Galvanized Sheets", "Roofing", "Sheet", 8500, "ALUCAM", "Corrugated iron sheets", "Tôles galvanisées",
             "Available"),
            ("Aluminum Sheets", "Roofing", "Sheet", 12000, "ALUCAM", "Aluminum roofing sheets", "Tôles aluminium",
             "Available"),

            # Blocks and Bricks
            ("Concrete Blocks (15cm)", "Masonry", "Piece", 350, "Local Producer", "15cm concrete blocks",
             "Parpaings 15cm", "Available"),
            ("Concrete Blocks (20cm)", "Masonry", "Piece", 450, "Local Producer", "20cm concrete blocks",
             "Parpaings 20cm", "Available"),
            ("Hollow Blocks (10cm)", "Masonry", "Piece", 250, "Local Producer", "10cm hollow blocks",
             "Parpaings creux 10cm", "Available"),
            ("Clay Bricks", "Masonry", "Piece", 150, "Local Kiln", "Traditional clay bricks", "Briques en terre cuite",
             "Available"),
            ("Compressed Earth Blocks", "Masonry", "Piece", 200, "Local Producer", "Eco-friendly earth blocks",
             "Blocs de terre compressée", "Available"),

            # Wood Materials
            ("Iroko Planks", "Timber", "Cubic Meter", 450000, "Local Sawmill", "Iroko hardwood planks",
             "Planches Iroko", "Available"),
            ("Ayous Planks", "Timber", "Cubic Meter", 280000, "Local Sawmill", "Ayous softwood planks",
             "Planches Ayous", "Available"),
            ("Sapelli Planks", "Timber", "Cubic Meter", 380000, "Local Sawmill", "Sapelli hardwood planks",
             "Planches Sapelli", "Available"),
            ("Bamboo Poles", "Timber", "Piece", 2500, "Local Supplier", "Bamboo construction poles", "Bambou",
             "Available"),
            ("Raffia Poles", "Timber", "Piece", 1500, "Local Supplier", "Raffia palm poles", "Raphia", "Available"),

            # Roofing Materials
            ("Clay Tiles", "Roofing", "Square Meter", 3500, "Local Producer", "Traditional clay roof tiles",
             "Tuiles en terre cuite", "Available"),
            ("Concrete Tiles", "Roofing", "Square Meter", 2800, "Local Producer", "Concrete roof tiles", "Tuiles béton",
             "Available"),
            ("Thatch Grass", "Roofing", "Bundle", 5000, "Rural Supplier", "Traditional thatch grass", "Chaume",
             "Seasonal"),
            ("Roofing Felt", "Roofing", "Roll", 15000, "Import", "Waterproof roofing felt", "Feutre bitumé",
             "Available"),

            # Pipes and Plumbing
            ("PVC Pipes 110mm", "Plumbing", "Piece (6m)", 8500, "WAVIN", "PVC drainage pipes", "Tuyaux PVC 110mm",
             "Available"),
            ("PVC Pipes 50mm", "Plumbing", "Piece (6m)", 3500, "WAVIN", "PVC water pipes", "Tuyaux PVC 50mm",
             "Available"),
            ("PVC Pipes 25mm", "Plumbing", "Piece (6m)", 1800, "WAVIN", "PVC water pipes", "Tuyaux PVC 25mm",
             "Available"),
            ("Galvanized Pipes", "Plumbing", "Piece (6m)", 12000, "Various", "Galvanized steel pipes",
             "Tuyaux galvanisés", "Available"),

            # Electrical Materials
            ("Electrical Cable 2.5mm", "Electrical", "Roll (100m)", 35000, "NEXANS", "House wiring cable",
             "Câble électrique 2.5mm", "Available"),
            ("Electrical Cable 1.5mm", "Electrical", "Roll (100m)", 22000, "NEXANS", "House wiring cable",
             "Câble électrique 1.5mm", "Available"),
            ("Circuit Breakers", "Electrical", "Piece", 8500, "ABB", "Electrical circuit breakers", "Disjoncteurs",
             "Available"),
            ("Electrical Sockets", "Electrical", "Piece", 2500, "Various", "Wall electrical sockets",
             "Prises électriques", "Available"),

            # Finishing Materials
            ("White Paint", "Paint", "Liter", 3500, "SIGMA", "Interior white paint", "Peinture blanche", "Available"),
            ("Colored Paint", "Paint", "Liter", 4000, "SIGMA", "Interior colored paint", "Peinture colorée",
             "Available"),
            ("Exterior Paint", "Paint", "Liter", 4500, "SIGMA", "Weather resistant paint", "Peinture extérieure",
             "Available"),
            ("Floor Tiles", "Tiles", "Square Meter", 12000, "Import", "Ceramic floor tiles", "Carreaux sol",
             "Available"),
            ("Wall Tiles", "Tiles", "Square Meter", 15000, "Import", "Ceramic wall tiles", "Carreaux mur", "Available"),
            ("Marble Tiles", "Tiles", "Square Meter", 35000, "Import", "Natural marble tiles", "Carreaux marbre",
             "Available"),
        ]

        for material in materials:
            cursor.execute('''
                           INSERT INTO building_materials
                           (name, category, unit, standard_price, supplier, description, local_name, availability,
                            created_date)
                           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                           ''', material + (date.today(),))

        conn.commit()
        conn.close()


# Password and Security Manager
class SecurityManager:
    def __init__(self):
        self.key = self.get_or_create_key() if HAS_CRYPTO else None
        self.cipher_suite = Fernet(self.key) if HAS_CRYPTO and self.key else None

    def get_or_create_key(self):
        # Store key in a less obvious location under user Documents for basic hardening
        try:
            base_dir = os.path.join(os.path.expanduser('~'), 'Documents', 'CBPM')
            os.makedirs(base_dir, exist_ok=True)
            key_file = os.path.join(base_dir, 'security.key')
        except Exception:
            key_file = "security.key"
        if os.path.exists(key_file):
            with open(key_file, 'rb') as f:
                return f.read()
        else:
            key = Fernet.generate_key()
            with open(key_file, 'wb') as f:
                f.write(key)
            try:
                # Best-effort permission tightening on Windows may not be straightforward; skip complex ACLs
                pass
            except Exception:
                pass
            return key

    def hash_password(self, password, salt=None):
        """Use the secure implementation from utils"""
        try:
            from utils import SecurityUtils
            hash_val, salt_val = SecurityUtils.hash_password(password, salt)
            return f"{hash_val}:{salt_val}"
        except Exception:
            # Fallback to legacy insecure SHA-256 (for environments without utils), for compatibility
            return hashlib.sha256(password.encode()).hexdigest()

    def verify_password(self, password, stored_hash):
        """Verify password using secure method or legacy fallback"""
        try:
            from utils import SecurityUtils
            if ':' in str(stored_hash):
                hash_val, salt = str(stored_hash).split(':', 1)
                return SecurityUtils.verify_password(password, hash_val, salt)
            # Legacy fallback for old users
            return str(stored_hash) == hashlib.sha256(password.encode()).hexdigest()
        except Exception:
            # As a last resort, compare legacy
            return str(stored_hash) == hashlib.sha256(password.encode()).hexdigest()

    def encrypt_data(self, data):
        if not HAS_CRYPTO or not self.cipher_suite:
            # Fallback: return plaintext when cryptography isn't available
            return data
        return self.cipher_suite.encrypt(data.encode()).decode()

    def decrypt_data(self, encrypted_data):
        if not HAS_CRYPTO or not self.cipher_suite:
            return encrypted_data
        return self.cipher_suite.decrypt(encrypted_data.encode()).decode()


# Main Application Class
class CBPMApp:
    def __init__(self):
        self.db_manager = DatabaseManager()
        self.security_manager = SecurityManager()
        self.current_user = None
        # Quick debug query for job seekers presence
        try:
            from config import ROLE_JOB_SEEKER
            _conn = self.db_manager.create_connection(); _cur = _conn.cursor()
            _cur.execute("SELECT id, username, role, full_name, email FROM users WHERE role = ? LIMIT 10", (ROLE_JOB_SEEKER,))
            _rows = _cur.fetchall(); _conn.close()
            print(f"[DEBUG] {ROLE_JOB_SEEKER} preview: {len(_rows)} rows", _rows)
        except Exception:
            import traceback; traceback.print_exc()
        self.setup_main_window()
        self.show_login()

    def run(self):
        # Start the Tkinter main event loop
        self.root.mainloop()

    def setup_main_window(self):
        self.root = tk.Tk()
        self.root.title("Cameroon Building Project Management System")
        self.root.geometry("1200x800")
        self.root.configure(bg='#2c3e50')

        # Set icon if available
        try:
            self.root.iconbitmap("icon.ico")
        except:
            pass

    def _validate_file_path(self, filename):
        """Validate file paths to prevent directory traversal"""
        from utils import SecurityUtils
        if not SecurityUtils.is_safe_filename(os.path.basename(filename)):
            raise ValueError("Invalid filename")
        abs_path = os.path.abspath(filename)
        allowed_dirs = [os.path.abspath('.'), os.path.expanduser('~/Documents')]
        if not any(abs_path.startswith(os.path.abspath(d)) for d in allowed_dirs):
            raise ValueError("File path not allowed")

    def show_login(self):
        # Clear main window
        for widget in self.root.winfo_children():
            widget.destroy()

        # Login frame
        login_frame = tk.Frame(self.root, bg='#34495e', padx=40, pady=40)
        login_frame.place(relx=0.5, rely=0.5, anchor='center')

        # Title
        title_label = tk.Label(login_frame, text="CBPM System Login",
                               font=('Arial', 20, 'bold'),
                               bg='#34495e', fg='white')
        title_label.pack(pady=(0, 30))

        # Username
        tk.Label(login_frame, text="Username:", font=('Arial', 12),
                 bg='#34495e', fg='white').pack(anchor='w')
        self.username_entry = tk.Entry(login_frame, font=('Arial', 12), width=25)
        self.username_entry.pack(pady=(5, 15))

        # Password
        tk.Label(login_frame, text="Password:", font=('Arial', 12),
                 bg='#34495e', fg='white').pack(anchor='w')
        self.password_entry = tk.Entry(login_frame, show="*", font=('Arial', 12), width=25)
        self.password_entry.pack(pady=(5, 20))

        # Login button
        login_btn = tk.Button(login_frame, text="Login", font=('Arial', 12, 'bold'),
                              bg='#3498db', fg='white', width=20,
                              command=self.login)
        login_btn.pack(pady=(0, 10))

        # Register button for job seekers
        register_btn = tk.Button(login_frame, text="Register as Job Seeker",
                                 font=('Arial', 10),
                                 bg='#27ae60', fg='white', width=20,
                                 command=self.show_registration)
        register_btn.pack()

        # Bind Enter key to login
        self.root.bind('<Return>', lambda event: self.login())

        # Focus on username entry
        self.username_entry.focus()

    def show_registration(self):
        # Registration window for job seekers
        reg_window = tk.Toplevel(self.root)
        reg_window.title("Register - Job Seeker")
        reg_window.geometry("500x600")
        reg_window.configure(bg='#34495e')
        reg_window.grab_set()  # Make modal

        # Registration form
        form_frame = tk.Frame(reg_window, bg='#34495e', padx=30, pady=30)
        form_frame.pack(fill='both', expand=True)

        tk.Label(form_frame, text="Job Seeker Registration",
                 font=('Arial', 16, 'bold'), bg='#34495e', fg='white').pack(pady=(0, 20))

        # Form fields
        fields = [
            ("Full Name:", "full_name"),
            ("Email:", "email"),
            ("Username:", "username"),
            ("Password:", "password"),
            ("Confirm Password:", "confirm_password"),
            ("Phone:", "phone"),
            ("Address:", "address")
        ]

        entries = {}
        for label_text, field_name in fields:
            tk.Label(form_frame, text=label_text, font=('Arial', 10),
                     bg='#34495e', fg='white').pack(anchor='w')

            if "password" in field_name.lower():
                entry = tk.Entry(form_frame, show="*", font=('Arial', 10), width=40)
            else:
                entry = tk.Entry(form_frame, font=('Arial', 10), width=40)

            entry.pack(pady=(5, 15))
            entries[field_name] = entry

        def register_job_seeker():
            # Validate form
            if not all(entry.get().strip() for entry in entries.values()):
                messagebox.showerror("Error", "All fields are required!")
                return

            if entries['password'].get() != entries['confirm_password'].get():
                messagebox.showerror("Error", "Passwords don't match!")
                return

            # Register user
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                password_hash = self.security_manager.hash_password(entries['password'].get())

                cursor.execute('''
                               INSERT INTO users
                               (username, email, password_hash, role, full_name, phone, address, created_date, is_active)
                               VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                               ''', (
                                   entries['username'].get(),
                                   entries['email'].get(),
                                   password_hash,
                                   ROLE_JOB_SEEKER,
                                   entries['full_name'].get(),
                                   entries['phone'].get(),
                                   entries['address'].get(),
                                   date.today(),
                                   1
                               ))

                conn.commit()
                conn.close()

                messagebox.showinfo("Success", "Registration successful! You can now login.")
                reg_window.destroy()

            except sqlite3.IntegrityError:
                messagebox.showerror("Error", "Username or email already exists!")
            except Exception as e:
                import traceback; traceback.print_exc()
                messagebox.showerror("Error", f"Registration failed: {str(e)}")

        tk.Button(form_frame, text="Register", font=('Arial', 12, 'bold'),
                  bg='#27ae60', fg='white', width=20,
                  command=register_job_seeker).pack(pady=20)

    def login(self):
        username = self.username_entry.get()
        password = self.password_entry.get()
        try:
            print(f"[DEBUG] login called with username={username}")
        except Exception:
            pass

        if not username or not password:
            messagebox.showerror("Error", "Please enter both username and password!")
            return

        # Use a short-lived connection with timeout and rollback safety to avoid 'database is locked'
        conn = None
        try:
            conn = sqlite3.connect(self.db_manager.db_name, timeout=5, isolation_level=None)
            try:
                print(f"[DEBUG] opened DB at (login): {self.db_manager.db_name}")
            except Exception:
                pass
            cursor = conn.cursor()
            # Ensure WAL mode for better concurrency
            try:
                cursor.execute("PRAGMA journal_mode=WAL")
            except Exception:
                pass
            # Explicitly begin immediate to avoid later lock escalation issues
            cursor.execute("BEGIN IMMEDIATE")

            cursor.execute('''
                           SELECT id, username, role, full_name, is_active, first_login, failed_login_attempts, password_hash
                           FROM users
                           WHERE username = ?
                           ''', (username,))

            user = cursor.fetchone()

            if user:
                user_id, username_db, role, full_name, is_active, first_login, failed_attempts, stored_hash = user

                # Verify password using secure method (with legacy fallback)
                if not self.security_manager.verify_password(password, stored_hash):
                    # Incorrect password: increment failed attempts and possibly suspend
                    cursor.execute('SELECT id, failed_login_attempts FROM users WHERE username = ?', (username,))
                    user_data = cursor.fetchone()
                    if user_data:
                        u_id, f_attempts = user_data
                        f_attempts = int(f_attempts or 0) + 1
                        if f_attempts >= 5:
                            cursor.execute('UPDATE users SET is_active = 0 WHERE id = ?', (u_id,))
                            messagebox.showerror("Error", "Account suspended due to multiple failed login attempts!")
                        else:
                            cursor.execute('UPDATE users SET failed_login_attempts = ? WHERE id = ?', (f_attempts, u_id))
                            messagebox.showerror("Error", f"Invalid credentials! {5 - f_attempts} attempts remaining.")
                        conn.commit()
                    else:
                        messagebox.showerror("Error", "Invalid username or password!")
                    return

                if not is_active:
                    messagebox.showerror("Error", "Your account has been suspended!")
                    conn.rollback()
                    return

                # Upgrade legacy hashes to secure format when logging in successfully
                try:
                    if ':' not in str(stored_hash):
                        new_hash = self.security_manager.hash_password(password)
                        cursor.execute('UPDATE users SET password_hash = ? WHERE id = ?', (new_hash, user_id))
                except Exception:
                    pass

                # Reset failed attempts on successful login
                cursor.execute('UPDATE users SET failed_login_attempts = 0, last_login = ? WHERE id = ?',
                               (datetime.now(), user_id))

                # Check if first login - require password change
                if first_login:
                    # Commit the reset then show password change dialog; we'll use a fresh connection in the dialog
                    conn.commit()
                    self.require_password_change(user_id, conn)
                    return

                conn.commit()

                self.current_user = {
                    'id': user_id,
                    'username': username_db,
                    'role': role,
                    'full_name': full_name
                }

                # Close connection before long UI operations to release DB
                conn.close()
                conn = None

                self.log_audit_action(user_id, "Login", f"User {username} logged in")

                # Low stock alert at login
                try:
                    self.notify_low_stock_on_login()
                except Exception:
                    pass

                self.show_main_dashboard()
            else:
                # Handle failed login
                cursor.execute('SELECT id, failed_login_attempts FROM users WHERE username = ?', (username,))
                user_data = cursor.fetchone()

                if user_data:
                    user_id, failed_attempts = user_data
                    failed_attempts += 1

                    if failed_attempts >= 5:
                        cursor.execute('UPDATE users SET is_active = 0 WHERE id = ?', (user_id,))
                        messagebox.showerror("Error", "Account suspended due to multiple failed login attempts!")
                    else:
                        cursor.execute('UPDATE users SET failed_login_attempts = ? WHERE id = ?',
                                       (failed_attempts, user_id))
                        messagebox.showerror("Error", f"Invalid credentials! {5 - failed_attempts} attempts remaining.")
                else:
                    messagebox.showerror("Error", "Invalid username or password!")

                conn.commit()
        except sqlite3.OperationalError as e:
            # Gracefully handle database locks or similar operational issues
            try:
                if conn:
                    conn.rollback()
            except Exception:
                pass
            import traceback; traceback.print_exc()
            messagebox.showerror("Database", f"Operation failed: {str(e)}. Please try again.")
        except Exception as e:
            try:
                if conn:
                    conn.rollback()
            except Exception:
                pass
            import traceback; traceback.print_exc()
            messagebox.showerror("Error", f"Login failed: {str(e)}")
        finally:
            try:
                if conn:
                    conn.close()
            except Exception:
                pass

    def require_password_change(self, user_id, conn):
        # Password change window
        pwd_window = tk.Toplevel(self.root)
        pwd_window.title("Change Password - First Login")
        pwd_window.geometry("400x300")
        pwd_window.configure(bg='#34495e')
        pwd_window.grab_set()

        frame = tk.Frame(pwd_window, bg='#34495e', padx=30, pady=30)
        frame.pack(fill='both', expand=True)

        tk.Label(frame, text="Change Password", font=('Arial', 16, 'bold'),
                 bg='#34495e', fg='white').pack(pady=(0, 20))

        tk.Label(frame, text="New Password:", font=('Arial', 10),
                 bg='#34495e', fg='white').pack(anchor='w')
        new_pwd_entry = tk.Entry(frame, show="*", font=('Arial', 10), width=30)
        new_pwd_entry.pack(pady=(5, 15))

        tk.Label(frame, text="Confirm Password:", font=('Arial', 10),
                 bg='#34495e', fg='white').pack(anchor='w')
        confirm_pwd_entry = tk.Entry(frame, show="*", font=('Arial', 10), width=30)
        confirm_pwd_entry.pack(pady=(5, 20))

        def change_password():
            new_pwd = new_pwd_entry.get()
            confirm_pwd = confirm_pwd_entry.get()

            if not new_pwd or not confirm_pwd:
                messagebox.showerror("Error", "Please fill all fields!")
                return

            if new_pwd != confirm_pwd:
                messagebox.showerror("Error", "Passwords don't match!")
                return

            if len(new_pwd) < 6:
                messagebox.showerror("Error", "Password must be at least 6 characters!")
                return

            # Update password using a fresh short-lived connection to avoid using a possibly closed handle
            local_conn = None
            try:
                # Close the passed-in conn if it still exists, to release any locks before opening new one
                try:
                    if conn:
                        conn.close()
                except Exception:
                    pass
                local_conn = self.db_manager.create_connection()
                cur = local_conn.cursor()
                new_pwd_hash = self.security_manager.hash_password(new_pwd)
                cur.execute('UPDATE users SET password_hash = ?, first_login = 0 WHERE id = ?',
                            (new_pwd_hash, user_id))
                local_conn.commit()
                messagebox.showinfo("Success", "Password changed successfully! Please login again.")
                pwd_window.destroy()
                # After password change, return to login screen
                self.show_login()
            except Exception as e:
                try:
                    if local_conn:
                        local_conn.rollback()
                except Exception:
                    pass
                try:
                    messagebox.showerror("Error", f"Failed to change password: {str(e)}")
                except Exception:
                    pass
            finally:
                try:
                    if local_conn:
                        local_conn.close()
                except Exception:
                    pass

        tk.Button(frame, text="Change Password", font=('Arial', 12, 'bold'),
                  bg='#3498db', fg='white', width=20,
                  command=change_password).pack()

    def log_audit_action(self, user_id, action, details):
        conn = self.db_manager.create_connection()
        cursor = conn.cursor()
        cursor.execute('''
                       INSERT INTO audit_log (user_id, action, details, timestamp)
                       VALUES (?, ?, ?, ?)
                       ''', (user_id, action, details, datetime.now()))
        conn.commit()
        conn.close()
        
    def has_contract_permission(self, contract_id: int, perm: str) -> bool:
            try:
                if not getattr(self, 'current_user', None):
                    return False
                uid = self.current_user.get('id')
                role = self.current_user.get('role')
                if role == 'administrator':
                    return True
                conn = self.db_manager.create_connection(); cur = conn.cursor()
                cur.execute("SELECT contract_owner_id, COALESCE(contractor_id, -1) FROM contracts WHERE id=?", (contract_id,))
                row = cur.fetchone()
                if not row:
                    conn.close(); return False
                owner_id, contractor_id = row
                # Owner has full permissions
                if owner_id == uid:
                    conn.close(); return True
                # Assigned contractor has basic permissions
                if role == 'contractor' and contractor_id == uid:
                    if perm in ('view', 'progress'):
                        conn.close(); return True
                # Check explicit permissions
                col_map = {'view':'can_view','update':'can_update','payments':'can_payments','progress':'can_progress'}
                col = col_map.get(perm)
                if not col:
                    conn.close(); return False
                cur.execute(f"SELECT COALESCE({col},0) FROM contract_permissions WHERE contract_id=? AND user_id=?", (contract_id, uid))
                r = cur.fetchone(); conn.close()
                return bool(r and (r[0] == 1 or r[0] is True))
            except Exception:
                try:
                    conn.close()
                except Exception:
                    pass
                return False
        
    def ensure_contract_active_if_fully_signed(self, contract_id: int) -> None:
        """Set contract status to 'Active' when both parties have signed.

        Checks both digital (digital_signature_owner/digital_signature_contractor)
        and legacy (owner_signature/contractor_signature) columns. Logs an audit
        entry when activation occurs.

        Args:
            contract_id: The contract ID to evaluate.
        """
        try:
            conn = self.db_manager.create_connection(); cur = conn.cursor()
            cur.execute(
                "SELECT digital_signature_owner, digital_signature_contractor, "
                "owner_signature, contractor_signature, COALESCE(status,'') "
                "FROM contracts WHERE id=?",
                (contract_id,)
            )
            row = cur.fetchone()
            if not row:
                conn.close(); return
            d_owner, d_contractor, l_owner, l_contractor, status = row
            both_signed = (d_owner is not None and d_contractor is not None) or (l_owner is not None and l_contractor is not None)
            if both_signed and (status or '').lower() != 'active':
                cur.execute("UPDATE contracts SET status='Active' WHERE id=?", (contract_id,))
                conn.commit()
                try:
                    self.log_audit_action(self.current_user['id'], 'Activate Contract (Auto)', f'Contract {contract_id} activated after both signatures')
                except Exception:
                    pass
            conn.close()
        except Exception:
            try:
                conn.close()
            except Exception:
                pass
            return
        
    def notify_low_stock_on_login(self):
        """Only show a low-stock alert scoped to a single store.
        If multiple stores are affected for this user, suppress the global popup and
        let per-store inventory views surface the alerts.
        """
        try:
            if not getattr(self, 'current_user', None):
                return
            role = self.current_user.get('role')
            conn = self.db_manager.create_connection()
            cur = conn.cursor()
            # Build role-based filter for accessible stores
            store_filter = " AND s.is_active = 1"
            params = []
            if role in ('retail_store', 'contract_owner'):
                store_filter += " AND s.owner_id = ?"
                params.append(self.current_user['id'])
            elif role == 'manager':
                store_filter += " AND s.manager_id = ?"
                params.append(self.current_user['id'])
            elif role == 'administrator':
                # administrators see all active stores; no extra params
                pass
            else:
                # Other roles (job_seeker, employer, contractor, etc.) don't get inventory alerts
                conn.close()
                return

            # Determine affected stores (with at least one low-stock item)
            cur.execute(
                """
                SELECT i.store_id, s.name, COUNT(*) AS low_cnt
                FROM inventory i
                JOIN stores s ON s.id = i.store_id
                WHERE COALESCE(i.quantity,0) <= COALESCE(i.reorder_level,0)
                """ + store_filter + " GROUP BY i.store_id ORDER BY low_cnt DESC",
                params
            )
            stores_low = cur.fetchall() or []
            if not stores_low:
                conn.close()
                return

            # Show alert only when exactly one store is affected to keep alerts store-specific
            if len(stores_low) != 1:
                conn.close()
                return

            store_id, store_name, low_cnt = stores_low[0]

            # Fetch a small sample list for this specific store
            cur.execute(
                """
                SELECT bm.name AS material, COALESCE(i.quantity,0) AS qty, COALESCE(i.reorder_level,0) AS rl
                FROM inventory i
                JOIN building_materials bm ON bm.id = i.material_id
                WHERE i.store_id = ? AND COALESCE(i.quantity,0) <= COALESCE(i.reorder_level,0)
                ORDER BY (COALESCE(i.reorder_level,0) - COALESCE(i.quantity,0)) DESC, bm.name
                LIMIT 10
                """,
                (store_id,)
            )
            items = cur.fetchall() or []
            conn.close()

            # Build message text scoped to the store
            lines = [
                f"Low stock in store: {store_name}",
                f"Items at/below reorder level: {int(low_cnt)}",
            ]
            if items:
                lines.append("")
                lines.append("Examples:")
                for mname, qty, rl in items:
                    # Format numbers (integer when applicable)
                    try:
                        qty_disp = int(qty) if float(qty).is_integer() else qty
                    except Exception:
                        qty_disp = qty
                    try:
                        rl_disp = int(rl) if float(rl).is_integer() else rl
                    except Exception:
                        rl_disp = rl
                    lines.append(f"• {mname} — Qty {qty_disp} (Reorder {rl_disp})")
            msg = "\n".join(lines)

            try:
                from tkinter import messagebox as _mb
                _mb.showwarning("Low Stock", msg)
            except Exception:
                pass
            try:
                self.log_audit_action(self.current_user['id'], "Low Stock Alert", f"{store_name}: {str(low_cnt)} item(s)")
            except Exception:
                pass
        except Exception:
            # Silent fail to avoid blocking login
            pass

    def show_main_dashboard(self):
        # Clear window
        for widget in self.root.winfo_children():
            widget.destroy()

        # Create main frame with menu
        self.create_main_menu()

        # Main content area
        self.main_content = tk.Frame(self.root, bg='white')
        self.main_content.pack(fill='both', expand=True, padx=10, pady=10)

        # Show dashboard based on role
        role = self.current_user['role']
        if role == 'administrator':
            self.show_admin_dashboard()
        elif role == 'retail_store':
            self.show_retail_dashboard()
        elif role == 'contract_owner':
            self.show_contract_owner_dashboard()
        elif role == 'contractor':
            self.show_contractor_dashboard()
        elif role == 'manager':
            self.show_manager_dashboard()
        elif role == ROLE_JOB_SEEKER:
            self.show_job_seeker_dashboard()
        elif role == 'employer':
            self.show_employer_dashboard()

    def create_main_menu(self):
        # Top menu bar
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # User info
        user_frame = tk.Frame(self.root, bg='#2c3e50', height=40)
        user_frame.pack(fill='x')
        user_frame.pack_propagate(False)

        tk.Label(user_frame,
                 text=f"Welcome, {self.current_user['full_name']} ({self.current_user['role'].replace('_', ' ').title()})",
                 font=('Arial', 12), bg='#2c3e50', fg='white').pack(side='left', padx=10, pady=10)

        tk.Button(user_frame, text="Logout", font=('Arial', 10),
                  bg='#e74c3c', fg='white', command=self.logout).pack(side='right', padx=10, pady=5)

        # Calendar display
        today = datetime.now().strftime("%A, %B %d, %Y")
        tk.Label(user_frame, text=today, font=('Arial', 10),
                 bg='#2c3e50', fg='#bdc3c7').pack(side='right', padx=10, pady=10)

        # Quick-access buttons for Job Seekers to improve discoverability
        try:
            if self.current_user.get('role') == ROLE_JOB_SEEKER:
                tk.Button(user_frame, text="Search Jobs", font=('Arial', 10),
                          bg='#3498db', fg='white', command=self.show_search_jobs).pack(side='right', padx=4, pady=5)
                tk.Button(user_frame, text="My Applications", font=('Arial', 10),
                          bg='#8e44ad', fg='white', command=self.show_my_applications).pack(side='right', padx=4, pady=5)
        except Exception:
            pass

        # Role-specific menus
        role = self.current_user['role']

        if role == 'administrator':
            self.create_admin_menu(menubar)
        elif role == 'retail_store':
            self.create_retail_menu(menubar)
        elif role == 'contract_owner':
            self.create_contract_owner_menu(menubar)
        elif role == 'contractor':
            self.create_contractor_menu(menubar)
        elif role == 'manager':
            self.create_manager_menu(menubar)
        elif role == ROLE_JOB_SEEKER:
            self.create_job_seeker_menu(menubar)
        elif role == 'employer':
            self.create_employer_menu(menubar)

    def create_admin_menu(self, menubar):
        # Users menu
        users_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Users", menu=users_menu)
        users_menu.add_command(label="Create User", command=self.show_create_user)
        users_menu.add_command(label="Manage Users", command=self.show_manage_users)
        users_menu.add_command(label="User Activity", command=self.show_user_activity)

        # Stores menu (limited admin store management)
        stores_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Stores", menu=stores_menu)
        stores_menu.add_command(label="Store Management", command=self.show_admin_store_management)

        # System menu
        system_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="System", menu=system_menu)
        system_menu.add_command(label="Materials Database", command=self.show_materials_database)
        system_menu.add_command(label="System Statistics", command=self.show_system_statistics)
        system_menu.add_command(label="Audit Log", command=self.show_audit_log)

    def show_admin_store_management(self):
        try:
            # Role check
            if not getattr(self, 'current_user', None) or self.current_user.get('role') != 'administrator':
                try:
                    messagebox.showwarning("Access", "Only Administrators can manage store status.")
                except Exception:
                    pass
                return

            win = tk.Toplevel(self.root)
            win.title("Administrator - Store Management")
            win.geometry("1000x600")
            win.configure(bg='white')
            win.grab_set()

            # Header
            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Store Management (Open/Close, Activate/Deactivate)", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Table
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Name","Location","Owner","Manager","Open","Active")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=140 if c not in ("Name","Location") else 200)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Actions
            btns = tk.Frame(win, bg='white')
            btns.pack(fill='x', padx=10, pady=(0,10))
            open_btn = tk.Button(btns, text="Open Store", bg="#27ae60", fg="white")
            close_btn = tk.Button(btns, text="Close Store", bg="#e67e22", fg="white")
            activate_btn = tk.Button(btns, text="Activate Store", bg="#2ecc71", fg="white")
            deactivate_btn = tk.Button(btns, text="Deactivate Store", bg="#c0392b", fg="white")
            refresh_btn = tk.Button(btns, text="Refresh")
            close_win_btn = tk.Button(btns, text="Close", command=win.destroy)
            open_btn.pack(side='left')
            close_btn.pack(side='left', padx=6)
            activate_btn.pack(side='left', padx=6)
            deactivate_btn.pack(side='left', padx=6)
            refresh_btn.pack(side='right')
            close_win_btn.pack(side='right', padx=6)

            def load_stores():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(
                        """
                        SELECT s.id,
                               s.name,
                               s.location,
                               COALESCE(o.full_name, o.username) AS owner_name,
                               COALESCE(m.full_name, m.username) AS manager_name,
                               COALESCE(s.is_open, 1) AS is_open,
                               COALESCE(s.is_active, 1) AS is_active
                        FROM stores s
                        LEFT JOIN users o ON o.id = s.owner_id
                        LEFT JOIN users m ON m.id = s.manager_id
                        ORDER BY s.name
                        """
                    )
                    rows = cur.fetchall()
                    conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Stores", f"Failed to load stores: {str(e)}")
                    except Exception:
                        pass
                    rows = []
                tree.delete(*tree.get_children())
                for r in rows:
                    sid, name, loc, owner, mgr, is_open, is_active = r
                    tree.insert('', 'end', values=(sid, name, loc or '', owner or '', mgr or '', 'Open' if (is_open==1 or is_open==True) else 'Closed', 'Active' if (is_active==1 or is_active==True) else 'Inactive'))

            def get_selected_id():
                sel = tree.selection()
                if not sel:
                    try:
                        messagebox.showinfo("Stores", "Please select a store first.")
                    except Exception:
                        pass
                    return None
                vals = tree.item(sel[0], 'values')
                return vals[0]

            def set_open(val: int):
                sid = get_selected_id()
                if not sid:
                    return
                try:
                    if val == 0 and not messagebox.askyesno("Confirm", "Close this store? Customers/managers may be limited."):
                        return
                except Exception:
                    pass
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("UPDATE stores SET is_open = ? WHERE id = ?", (val, sid))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Admin Store Open/Close", json.dumps({"store_id": sid, "is_open": val}))
                    except Exception:
                        pass
                    load_stores()
                except Exception as e:
                    try:
                        messagebox.showerror("Stores", f"Failed to update store: {str(e)}")
                    except Exception:
                        pass

            def set_active(val: int):
                sid = get_selected_id()
                if not sid:
                    return
                try:
                    if val == 0 and not messagebox.askyesno("Confirm", "Deactivate this store? It will be hidden/disabled for use."):
                        return
                except Exception:
                    pass
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("UPDATE stores SET is_active = ? WHERE id = ?", (val, sid))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Admin Store Activate/Deactivate", json.dumps({"store_id": sid, "is_active": val}))
                    except Exception:
                        pass
                    load_stores()
                except Exception as e:
                    try:
                        messagebox.showerror("Stores", f"Failed to update store: {str(e)}")
                    except Exception:
                        pass

            # Wire buttons
            open_btn.config(command=lambda: set_open(1))
            close_btn.config(command=lambda: set_open(0))
            activate_btn.config(command=lambda: set_active(1))
            deactivate_btn.config(command=lambda: set_active(0))
            refresh_btn.config(command=load_stores)

            # Initial
            load_stores()
        except Exception as e:
            try:
                messagebox.showerror("Stores", f"Failed to open Store Management: {str(e)}")
            except Exception:
                pass

    def create_retail_menu(self, menubar):
        # Store menu
        store_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Store", menu=store_menu)
        store_menu.add_command(label="Create Store", command=self.show_create_store)
        store_menu.add_command(label="Manage Stores", command=self.show_manage_stores)
        store_menu.add_command(label="Inventory", command=self.show_inventory)
        # Catalog of other stores' inventory (all stores except other retail-owned; includes own)
        catalog_cmd = self.show_view_inventory if hasattr(self, 'show_view_inventory') else (lambda: messagebox.showinfo("Catalog", "Catalog view unavailable."))
        store_menu.add_command(label="Retail Catalog", command=catalog_cmd)

        # Sales menu
        sales_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Sales", menu=sales_menu)
        sales_menu.add_command(label="New Sale", command=self.show_new_sale)
        sales_menu.add_command(label="Sales History", command=self.show_sales_history)
        sales_menu.add_command(label="Customer Management", command=self.show_customer_management)
        # Replace placing orders with View & Approve Orders for retail stores
        sales_menu.add_command(label="View & Approve Orders", command=self.show_view_approve_orders)

        # Payments menu
        payments_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Payments", menu=payments_menu)
        payments_menu.add_command(label="Payments Center", command=self.show_payments_center)

        # Reports menu
        reports_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Reports", menu=reports_menu)
        reports_menu.add_command(label="Store Analytics", command=self.show_store_analytics)
        reports_menu.add_command(label="Financial Reports", command=self.show_financial_reports)

        # HR menu for Retail Store Owner
        hr_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="HR", menu=hr_menu)
        # Retail store owners can create only Manager accounts
        hr_menu.add_command(label="Create Manager Account", command=lambda: self.show_create_user('manager'))
        # Job features (use safe getters where needed)
        post_cmd = getattr(self, 'show_post_job', lambda: messagebox.showinfo("Jobs", "Post Job is unavailable."))
        manage_cmd = self.show_manage_jobs
        manage_apps_cmd = getattr(self, 'show_manage_applications', lambda: messagebox.showinfo("Jobs", "Manage Applications is unavailable."))
        hr_menu.add_separator()
        hr_menu.add_command(label="Post Job", command=post_cmd)
        hr_menu.add_command(label="Manage My Jobs", command=manage_cmd)
        hr_menu.add_command(label="Manage Applications", command=manage_apps_cmd)

    def create_contract_owner_menu(self, menubar):
        # Contracts menu
        contracts_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Contracts", menu=contracts_menu)
        contracts_menu.add_command(label="Create Contract", command=self.show_create_contract)
        contracts_menu.add_command(label="Manage Contract", command=self.show_manage_contracts)
        contracts_menu.add_command(label="Digital Signatures", command=self.show_digital_signatures)

        # Manager & Contractor Management menu
        mgmt_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Team", menu=mgmt_menu)
        mgmt_menu.add_command(label="Managers - Activate/Assign", command=self.show_manager_activation)
        mgmt_menu.add_command(label="Managers - Activities", command=self.show_manager_activities)
        mgmt_menu.add_command(label="Managers - Reports", command=self.show_manager_reports)
        mgmt_menu.add_separator()
        mgmt_menu.add_command(label="Contractors - Activities", command=self.show_contractor_activities)
        mgmt_menu.add_command(label="Contractors - Reports", command=self.show_contractor_reports)

        # Store menu (add Inventory for Contract Owners)
        store_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Store", menu=store_menu)
        store_menu.add_command(label="Create Store", command=self.show_create_store)
        store_menu.add_command(label="Manage Stores", command=self.show_manage_stores)
        # Direct access to Inventory Management
        inv_command = self.show_view_inventory if hasattr(self, 'show_view_inventory') else self.show_inventory
        store_menu.add_command(label="Inventory", command=inv_command)
        store_menu.add_command(label="Transfer Products", command=self.show_transfer_products)
        # Browse retail catalogs (visible to Contract Owners)
        catalog_cmd = self.show_view_inventory if hasattr(self, 'show_view_inventory') else (lambda: messagebox.showinfo("Catalog", "Catalog view unavailable."))
        store_menu.add_command(label="Retail Catalog", command=catalog_cmd)
        # Buy Materials is available for Contract Owners only
        store_menu.add_command(label="Buy Materials", command=self.show_buy_materials)

        # Payments menu
        payments_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Payments", menu=payments_menu)
        payments_menu.add_command(label="Payments Center", command=self.show_payments_center)

        # HR menu
        hr_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="HR", menu=hr_menu)
        # HR menu bindings (direct reference for Manage My Jobs; others safe fallbacks)
        post_cmd = getattr(self, 'show_post_job', lambda: messagebox.showinfo("Jobs", "Post Job is unavailable."))
        manage_cmd = self.show_manage_jobs  # Direct reference instead of getattr chain
        manage_apps_cmd = getattr(self, 'show_manage_applications', lambda: messagebox.showinfo("Jobs", "Manage Applications is unavailable."))
        # Quick employee account creation for Contract Owners
        hr_menu.add_command(label="Create Contractor Account", command=lambda: self.show_create_user('contractor'))
        hr_menu.add_command(label="Create Manager Account", command=lambda: self.show_create_user('manager'))
        hr_menu.add_separator()
        hr_menu.add_command(label="Post Job", command=post_cmd)
        hr_menu.add_command(label="Manage My Jobs", command=manage_cmd)
        hr_menu.add_command(label="Manage Applications", command=manage_apps_cmd)

    def create_contractor_menu(self, menubar):
        # Contracts menu
        contracts_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Contracts", menu=contracts_menu)
        contracts_menu.add_command(label="View Contracts", command=self.show_view_contracts)
        contracts_menu.add_command(label="Sign Contracts", command=self.show_sign_contracts)
        contracts_menu.add_command(label="Material Reports", command=self.show_material_reports)
        # Browse retail catalogs (visible to Contractors)
        catalog_cmd = self.show_view_inventory if hasattr(self, 'show_view_inventory') else (lambda: messagebox.showinfo("Catalog", "Catalog view unavailable."))
        contracts_menu.add_command(label="Retail Catalog", command=catalog_cmd)
        # Allow contractors to place orders from the menu
        contracts_menu.add_command(label="Place Order", command=self.show_buy_materials)

        # Workers menu
        workers_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Workers", menu=workers_menu)
        workers_menu.add_command(label="Create Worker Profile", command=self.show_create_worker)
        workers_menu.add_command(label="Manage Workers", command=self.show_manage_workers)

        # Jobs menu
        jobs_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Jobs", menu=jobs_menu)
        # Jobs menu bindings (direct reference for Manage My Jobs; others safe fallbacks)
        post_cmd = getattr(self, 'show_post_job', lambda: messagebox.showinfo("Jobs", "Post Job is unavailable."))
        manage_cmd = self.show_manage_jobs  # Direct reference instead of getattr chain
        view_apps_cmd = getattr(self, 'show_view_applicants', getattr(self, 'show_view_applications', lambda: messagebox.showinfo("Jobs", "View Applications is unavailable.")))
        jobs_menu.add_command(label="Post Job", command=post_cmd)
        jobs_menu.add_command(label="Manage My Jobs", command=manage_cmd)
        jobs_menu.add_command(label="View Applications", command=view_apps_cmd)

        # Payments menu
        payments_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Payments", menu=payments_menu)
        payments_menu.add_command(label="Payments Center", command=self.show_payments_center)

    def create_manager_menu(self, menubar):
        # Store menu (limited functions)
        store_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Store", menu=store_menu)
        # Use the more detailed inventory view if available; fall back to generic inventory
        inv_command = self.show_view_inventory if hasattr(self, 'show_view_inventory') else self.show_inventory
        store_menu.add_command(label="View Inventory", command=inv_command)
        # Use manager sales view if available; otherwise show a placeholder to avoid AttributeError
        sales_command = self.show_manager_sales if hasattr(self, 'show_manager_sales') else (lambda: messagebox.showinfo("Feature", "Manager Sales interface will be implemented here"))
        store_menu.add_command(label="Sales", command=sales_command)

        # Payments menu
        payments_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Payments", menu=payments_menu)
        payments_menu.add_command(label="Payments Center", command=self.show_payments_center)

        # Reports menu
        reports_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Reports", menu=reports_menu)
        # Bind Daily Report defensively in case method is moved/renamed
        daily_report_cmd = self.show_daily_report if hasattr(self, 'show_daily_report') else (lambda: messagebox.showinfo("Report", "Daily Report is currently unavailable."))
        reports_menu.add_command(label="Daily Report", command=daily_report_cmd)

    def create_job_seeker_menu(self, menubar):
        # Build the Job Seeker menu (visible when a job_seeker is logged in)
        try:
            try:
                print(f"[DEBUG] create_job_seeker_menu: current_user={getattr(self, 'current_user', None)}")
            except Exception:
                pass
            job_menu = tk.Menu(menubar, tearoff=0)

            # Ensure we pass function references (no parentheses) so they are called on click
            edit_cmd = self.show_edit_profile if hasattr(self, 'show_edit_profile') else (lambda: messagebox.showinfo("Profile", "Edit Profile feature is currently unavailable."))
            job_menu.add_command(label="Edit Profile", command=edit_cmd)
            upload_cmd = self.show_upload_resume if hasattr(self, 'show_upload_resume') else (lambda: messagebox.showinfo("Resume", "Upload Resume feature is currently unavailable."))
            job_menu.add_command(label="Upload / Replace Resume", command=upload_cmd)
            search_cmd = self.show_search_jobs if hasattr(self, 'show_search_jobs') else (lambda: messagebox.showinfo("Jobs", "Search Jobs feature is currently unavailable."))
            job_menu.add_command(label="Search Jobs", command=search_cmd)
            apps_cmd = self.show_my_applications if hasattr(self, 'show_my_applications') else (lambda: messagebox.showinfo("Applications", "My Applications feature is currently unavailable."))
            job_menu.add_command(label="My Applications", command=apps_cmd)

            # ... you may already have other job seeker items here ...
            menubar.add_cascade(label="Job Seeker", menu=job_menu)

        except Exception:
            import traceback; traceback.print_exc()

    def show_manager_activation(self):
        try:
            if not getattr(self, 'current_user', None) or self.current_user.get('role') != 'contract_owner':
                messagebox.showwarning("Access", "Only Contract Owners can manage managers.")
                return
            win = tk.Toplevel(self.root); win.title("Managers - Activate / Assign"); win.geometry("900x520"); win.configure(bg='white'); win.grab_set()
            header = tk.Frame(win, bg='white'); header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Managers - Activate / Assign to My Stores", font=('Arial',16,'bold'), bg='white').pack(side='left')
            filt = tk.Frame(win, bg='white'); filt.pack(fill='x', padx=10)
            tk.Label(filt, text="Store:", bg='white').grid(row=0, column=0, sticky='e', padx=4, pady=6)
            store_var = tk.StringVar(); store_cb = ttk.Combobox(filt, textvariable=store_var, state='readonly', width=40); store_cb.grid(row=0, column=1, sticky='w')
            refresh_btn = tk.Button(filt, text="Refresh", bg="#3498db", fg="white"); refresh_btn.grid(row=0, column=2, padx=6)
            frame = tk.Frame(win, bg='white'); frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("Store ID","Store","Manager ID","Manager Name","Manager Status"); tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c); tree.column(c, width=150 if c!="Store" else 220)
            tree.pack(fill='both', expand=True, side='left'); sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview); tree.configure(yscrollcommand=sy.set); sy.pack(side='right', fill='y')
            act = tk.Frame(win, bg='white'); act.pack(fill='x', padx=10, pady=(0,10))
            assign_btn = tk.Button(act, text="Assign/Change Manager", bg="#8e44ad", fg="white"); assign_btn.pack(side='left')
            activate_btn = tk.Button(act, text="Activate Selected Manager", bg="#27ae60", fg="white"); activate_btn.pack(side='left', padx=8)
            open_manage_btn = tk.Button(act, text="Open Manage Stores", command=self.show_manage_stores); open_manage_btn.pack(side='left', padx=8)
            close_btn = tk.Button(act, text="Close", command=win.destroy); close_btn.pack(side='right')
            store_map = {"All My Stores": None}
            def load_stores():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT id, name FROM stores WHERE owner_id=? ORDER BY name", (self.current_user['id'],))
                    rows = cur.fetchall(); conn.close()
                    values = ["All My Stores"]
                    for sid, name in rows:
                        disp = f"{name} (ID:{sid})"; store_map[disp] = sid; values.append(disp)
                    store_cb['values'] = values; store_cb.set(values[0] if values else "All My Stores")
                except Exception:
                    store_cb['values'] = ["All My Stores"]; store_cb.set("All My Stores")
            def refresh():
                try:
                    sid = store_map.get(store_var.get())
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    q = ("SELECT s.id, s.name, u.id, COALESCE(u.full_name, u.username), COALESCE(u.is_active,0) "
                         "FROM stores s LEFT JOIN users u ON u.id = s.manager_id WHERE s.owner_id = ? ")
                    params = [self.current_user['id']]
                    if sid:
                        q += "AND s.id = ? "; params.append(sid)
                    q += "ORDER BY s.name"
                    cur.execute(q, params); rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try: messagebox.showerror("Load", f"Failed to load: {str(e)}")
                    except Exception: pass
                    rows = []
                for it in tree.get_children(): tree.delete(it)
                for r in rows:
                    stid, stname, mid, mname, active = r
                    status = "Active" if (active==1 or active==True) and mid else ("Inactive" if mid else "Not Assigned")
                    tree.insert('', 'end', values=(stid, stname, mid or '', mname or '', status))
            def do_assign():
                sel = tree.selection()
                if not sel:
                    messagebox.showwarning("Assign", "Select a store row first"); return
                values = tree.item(sel[0])['values']; stid = values[0]
                dlg = tk.Toplevel(win); dlg.title("Assign/Change Manager"); dlg.geometry("420x200"); dlg.configure(bg='white'); dlg.grab_set()
                tk.Label(dlg, text=f"Store ID: {stid}", bg='white', font=('Arial',11,'bold')).pack(anchor='w', padx=10, pady=(10,4))
                tk.Label(dlg, text="Select Manager (active users)", bg='white').pack(anchor='w', padx=10)
                var = tk.StringVar(); cb = ttk.Combobox(dlg, textvariable=var, state='readonly'); cb.pack(fill='x', padx=10, pady=6)
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    q = "SELECT id, full_name, username FROM users WHERE role = 'manager' AND is_active = 1 "
                    params = []
                    try:
                        if self.current_user.get('role') != 'administrator':
                            q += "AND created_by = ? "
                            params.append(self.current_user['id'])
                    except Exception:
                        pass
                    q += "ORDER BY full_name"
                    cur.execute(q, params)
                    mans = cur.fetchall(); conn.close()
                    cb['values'] = [f"{m[0]} - {m[1]} ({m[2]})" for m in mans]
                    if cb['values']: cb.set(cb['values'][0])
                except Exception:
                    cb['values'] = []
                def save():
                    if not var.get():
                        messagebox.showwarning("Assign", "Select a manager"); return
                    try:
                        mid = int(var.get().split(' - ')[0])
                        conn = self.db_manager.create_connection(); cur = conn.cursor()
                        cur.execute("UPDATE stores SET manager_id=? WHERE id=? AND owner_id=?", (mid, stid, self.current_user['id']))
                        conn.commit(); conn.close()
                        self.log_audit_action(self.current_user['id'], "Assign Manager", json.dumps({"store_id": stid, "manager_id": mid}))
                        messagebox.showinfo("Assigned", "Manager assigned to store"); dlg.destroy(); refresh()
                    except Exception as e:
                        try: messagebox.showerror("Assign", f"Failed: {str(e)}")
                        except Exception: pass
                tk.Button(dlg, text="Save", bg="#27ae60", fg="white", command=save).pack(pady=8)
                tk.Button(dlg, text="Cancel", command=dlg.destroy).pack()
            def do_activate():
                sel = tree.selection()
                if not sel:
                    messagebox.showwarning("Activate", "Select a row first"); return
                # As per policy, only Administrators can activate accounts created by non-admins
                try:
                    messagebox.showinfo(
                        "Activation Restricted",
                        "Only Administrators can activate user accounts.\nPlease contact Admin via WhatsApp: +237683786186 to request activation."
                    )
                except Exception:
                    pass
            assign_btn.config(command=do_assign); activate_btn.config(command=do_activate); refresh_btn.config(command=refresh); store_var.trace('w', lambda *a: refresh())
            load_stores(); refresh()
        except Exception as e:
            try: messagebox.showerror("Error", f"Failed to open Manager Activation: {str(e)}")
            except Exception: pass

    def show_manager_activities(self):
        try:
            if not getattr(self, 'current_user', None) or self.current_user.get('role') != 'contract_owner':
                messagebox.showwarning("Access", "Only Contract Owners can view manager activities."); return
            win = tk.Toplevel(self.root); win.title("Manager Activities"); win.geometry("1000x600"); win.configure(bg='white'); win.grab_set()
            header = tk.Frame(win, bg='white'); header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Manager Activities (Audit Log)", font=('Arial',16,'bold'), bg='white').pack(side='left')
            filt = tk.Frame(win, bg='white'); filt.pack(fill='x', padx=10)
            tk.Label(filt, text="Manager:", bg='white').grid(row=0, column=0, sticky='e')
            mgr_var = tk.StringVar(); mgr_cb = ttk.Combobox(filt, textvariable=mgr_var, state='readonly', width=40); mgr_cb.grid(row=0, column=1, sticky='w', padx=6, pady=6)
            tk.Label(filt, text="From (YYYY-MM-DD):", bg='white').grid(row=0, column=2, sticky='e'); from_var = tk.StringVar(); tk.Entry(filt, textvariable=from_var, width=14).grid(row=0, column=3, sticky='w')
            tk.Label(filt, text="To:", bg='white').grid(row=0, column=4, sticky='e', padx=(8,0)); to_var = tk.StringVar(); tk.Entry(filt, textvariable=to_var, width=14).grid(row=0, column=5, sticky='w')
            refresh_btn = tk.Button(filt, text="Refresh", bg="#3498db", fg="white"); refresh_btn.grid(row=0, column=6, padx=6)
            export_btn = tk.Button(filt, text="Export CSV"); export_btn.grid(row=0, column=7)
            # Action filter and Details button
            tk.Label(filt, text="Action:", bg='white').grid(row=1, column=0, sticky='e')
            action_var = tk.StringVar(value='All Actions')
            action_cb = ttk.Combobox(filt, textvariable=action_var, state='readonly', width=36)
            action_cb.grid(row=1, column=1, sticky='w', padx=6, pady=4)
            details_btn = tk.Button(filt, text="View Details")
            details_btn.grid(row=1, column=6, padx=6)
            frame = tk.Frame(win, bg='white'); frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("Time","Manager","Action","Details"); tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c); tree.column(c, width=200 if c in ("Time","Details") else 160)
            tree.pack(fill='both', expand=True, side='left'); sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview); tree.configure(yscrollcommand=sy.set); sy.pack(side='right', fill='y')
            mgr_map = {"All Managers": None}
            def load_mgrs():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Managers that worked on owner's stores (assigned) or all managers
                    cur.execute("SELECT DISTINCT u.id, COALESCE(u.full_name,u.username) FROM users u WHERE u.role='manager' ORDER BY 2")
                    rows = cur.fetchall(); conn.close()
                    values = ["All Managers"]
                    for mid, name in rows:
                        disp = f"{mid} - {name}"; mgr_map[disp] = mid; values.append(disp)
                    mgr_cb['values'] = values; mgr_cb.set(values[0])
                except Exception:
                    mgr_cb['values'] = ["All Managers"]; mgr_cb.set("All Managers")
            def refresh():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    q = ("SELECT a.timestamp, COALESCE(u.full_name,u.username), a.action, COALESCE(a.details,'') "
                         "FROM audit_log a LEFT JOIN users u ON u.id = a.user_id WHERE u.role='manager' ")
                    params = []
                    mid = mgr_map.get(mgr_var.get()); f = from_var.get().strip(); t = to_var.get().strip()
                    act = (action_var.get() or '').strip()
                    if mid: q += "AND u.id = ? "; params.append(mid)
                    if f: q += "AND date(a.timestamp) >= ? "; params.append(f)
                    if t: q += "AND date(a.timestamp) <= ? "; params.append(t)
                    if act and act != 'All Actions': q += "AND a.action = ? "; params.append(act)
                    q += "ORDER BY a.timestamp DESC LIMIT 500"
                    cur.execute(q, params); rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try: messagebox.showerror("Activities", f"Failed to load: {str(e)}")
                    except Exception: pass
                    rows = []
                for it in tree.get_children(): tree.delete(it)
                for r in rows: tree.insert('', 'end', values=r)
                try:
                    self.log_audit_action(self.current_user['id'], "View Manager Activities", json.dumps({"mgr": mgr_var.get(), "from": from_var.get(), "to": to_var.get()}))
                except Exception: pass
            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    filename = fd.asksaveasfilename(title="Export Manager Activities", defaultextension=".csv", filetypes=[("CSV","*.csv")])
                    if not filename: return
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT a.timestamp, COALESCE(u.full_name,u.username), a.action, COALESCE(a.details,'') FROM audit_log a LEFT JOIN users u ON u.id=a.user_id WHERE u.role='manager' ORDER BY a.timestamp DESC")
                    rows = cur.fetchall(); conn.close()
                    import csv; f = open(filename, 'w', newline='', encoding='utf-8'); w = csv.writer(f); w.writerow(["Time","Manager","Action","Details"]); w.writerows(rows); f.close(); messagebox.showinfo("Export", "Export complete")
                except Exception as e:
                    try: messagebox.showerror("Export", f"Failed: {str(e)}")
                    except Exception: pass
            def view_details():
                sel = tree.selection()
                if not sel:
                    try:
                        messagebox.showinfo("Details", "Select a record first")
                    except Exception:
                        pass
                    return
                vals = tree.item(sel[0])['values']
                details_text = vals[3] if len(vals) > 3 else ''
                try:
                    parsed = None
                    try:
                        parsed = json.loads(details_text)
                    except Exception:
                        parsed = None
                    pretty = json.dumps(parsed, indent=2, ensure_ascii=False) if parsed is not None else str(details_text)
                    d = tk.Toplevel(win); d.title("Activity Details"); d.geometry("600x420"); d.configure(bg='white'); d.grab_set()
                    txt = tk.Text(d, wrap='word'); txt.pack(fill='both', expand=True, padx=8, pady=8)
                    txt.insert('1.0', pretty); txt.config(state='disabled')
                    tk.Button(d, text='Close', command=d.destroy).pack(pady=6)
                except Exception:
                    try:
                        messagebox.showinfo("Details", str(details_text))
                    except Exception:
                        pass

            # Populate actions for filter
            try:
                connA = self.db_manager.create_connection(); curA = connA.cursor()
                curA.execute("SELECT DISTINCT a.action FROM audit_log a JOIN users u ON u.id=a.user_id WHERE u.role='manager' ORDER BY a.action")
                acts = [r[0] for r in curA.fetchall()]; connA.close()
                action_cb['values'] = ['All Actions'] + acts
                action_cb.set('All Actions')
            except Exception:
                action_cb['values'] = ['All Actions']; action_cb.set('All Actions')

            refresh_btn.config(command=refresh); export_btn.config(command=export_csv); details_btn.config(command=view_details); mgr_var.trace('w', lambda *a: refresh()); from_var.trace('w', lambda *a: refresh()); to_var.trace('w', lambda *a: refresh()); action_var.trace('w', lambda *a: refresh())
            load_mgrs(); refresh()
        except Exception as e:
            try: messagebox.showerror("Error", f"Failed to open Manager Activities: {str(e)}")
            except Exception: pass

    def show_manager_reports(self):
        try:
            if not getattr(self, 'current_user', None) or self.current_user.get('role') != 'contract_owner':
                messagebox.showwarning("Access", "Only Contract Owners can view manager reports."); return
            win = tk.Toplevel(self.root); win.title("Manager Reports"); win.geometry("700x480"); win.configure(bg='white'); win.grab_set()
            tk.Label(win, text="Manager Reports (Summary)", font=('Arial',16,'bold'), bg='white').pack(pady=10)
            txt = tk.Text(win, height=16); txt.pack(fill='both', expand=True, padx=10, pady=10)
            def refresh():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT u.id, COALESCE(u.full_name,u.username), COUNT(a.id) FROM users u LEFT JOIN audit_log a ON a.user_id = u.id WHERE u.role='manager' GROUP BY u.id, u.full_name, u.username ORDER BY 3 DESC")
                    rows = cur.fetchall(); conn.close()
                    txt.config(state='normal'); txt.delete('1.0','end')
                    txt.insert('end', "Manager Activity Counts (from audit log)\n\n")
                    for mid, name, cnt in rows:
                        txt.insert('end', f"- {name} (ID {mid}): {cnt} activities logged\n")
                    txt.config(state='disabled')
                except Exception as e:
                    txt.config(state='normal'); txt.delete('1.0','end'); txt.insert('end', f"Failed to load: {str(e)}"); txt.config(state='disabled')
            def export():
                try:
                    from tkinter import filedialog as fd
                    filename = fd.asksaveasfilename(title="Export Manager Report", defaultextension=".txt")
                    if not filename: return
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(txt.get('1.0','end'))
                    messagebox.showinfo("Export", "Report saved")
                except Exception as e:
                    try: messagebox.showerror("Export", f"Failed: {str(e)}")
                    except Exception: pass
            btns = tk.Frame(win, bg='white'); btns.pack(fill='x', padx=10, pady=8)
            tk.Button(btns, text="Refresh", bg="#3498db", fg="white", command=refresh).pack(side='left')
            tk.Button(btns, text="Export", command=export).pack(side='left', padx=8)
            tk.Button(btns, text="Close", command=win.destroy).pack(side='right')
            refresh()
        except Exception as e:
            try: messagebox.showerror("Error", f"Failed to open Manager Reports: {str(e)}")
            except Exception: pass

    def show_contractor_activities(self):
        try:
            if not getattr(self, 'current_user', None) or self.current_user.get('role') != 'contract_owner':
                messagebox.showwarning("Access", "Only Contract Owners can view contractor activities."); return
            win = tk.Toplevel(self.root); win.title("Contractor Activities"); win.geometry("1000x600"); win.configure(bg='white'); win.grab_set()
            header = tk.Frame(win, bg='white'); header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Contractor Activities (Audit Log)", font=('Arial',16,'bold'), bg='white').pack(side='left')
            filt = tk.Frame(win, bg='white'); filt.pack(fill='x', padx=10)
            tk.Label(filt, text="Contract:", bg='white').grid(row=0, column=0, sticky='e')
            contract_var = tk.StringVar(); contract_cb = ttk.Combobox(filt, textvariable=contract_var, state='readonly', width=50); contract_cb.grid(row=0, column=1, sticky='w', padx=6, pady=6)
            tk.Label(filt, text="Contractor:", bg='white').grid(row=0, column=2, sticky='e'); contractor_var = tk.StringVar(); contractor_cb = ttk.Combobox(filt, textvariable=contractor_var, state='readonly', width=40); contractor_cb.grid(row=0, column=3, sticky='w', padx=6)
            refresh_btn = tk.Button(filt, text="Refresh", bg="#3498db", fg="white"); refresh_btn.grid(row=0, column=4, padx=6)
            # Action filter and Details button
            tk.Label(filt, text="Action:", bg='white').grid(row=1, column=0, sticky='e')
            action_var_c = tk.StringVar(value='All Actions')
            action_cb_c = ttk.Combobox(filt, textvariable=action_var_c, state='readonly', width=46)
            action_cb_c.grid(row=1, column=1, sticky='w', padx=6, pady=4)
            details_btn_c = tk.Button(filt, text="View Details")
            details_btn_c.grid(row=1, column=4, padx=6)
            frame = tk.Frame(win, bg='white'); frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("Time","User","Action","Details"); tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols: tree.heading(c, text=c); tree.column(c, width=220 if c in ("Details","Time") else 180)
            tree.pack(fill='both', expand=True, side='left'); sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview); tree.configure(yscrollcommand=sy.set); sy.pack(side='right', fill='y')
            contract_map = {"All My Contracts": None}; contractor_map = {"All Contractors": None}
            def load_filters():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT id, title, COALESCE(contractor_id,0) FROM contracts WHERE contract_owner_id=? ORDER BY created_date DESC", (self.current_user['id'],))
                    rows = cur.fetchall()
                    values = ["All My Contracts"]
                    contractors = set()
                    for cid, title, contr_id in rows:
                        disp = f"{cid} - {title}"; contract_map[disp] = cid; values.append(disp)
                        if contr_id:
                            contractors.add(contr_id)
                    contract_cb['values'] = values; contract_cb.set(values[0] if values else "All My Contracts")
                    # Load contractors from users table for those ids (if any)
                    contractor_values = ["All Contractors"]
                    if contractors:
                        q = "SELECT id, COALESCE(full_name, username) FROM users WHERE id IN (%s)" % (",".join(str(x) for x in contractors))
                        cur.execute(q); rows2 = cur.fetchall()
                        for mid, name in rows2:
                            disp = f"{mid} - {name}"; contractor_map[disp] = mid; contractor_values.append(disp)
                    contractor_cb['values'] = contractor_values; contractor_cb.set(contractor_values[0])
                    conn.close()
                except Exception:
                    contract_cb['values'] = ["All My Contracts"]; contract_cb.set("All My Contracts")
                    contractor_cb['values'] = ["All Contractors"]; contractor_cb.set("All Contractors")
            def refresh():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    q = ("SELECT a.timestamp, COALESCE(u.full_name,u.username), a.action, COALESCE(a.details,'') "
                         "FROM audit_log a LEFT JOIN users u ON u.id = a.user_id WHERE u.role='contractor' ")
                    params = []
                    cid = contract_map.get(contract_var.get()); contr_id = contractor_map.get(contractor_var.get())
                    act = (action_var_c.get() or '').strip()
                    if contr_id: q += "AND u.id = ? "; params.append(contr_id)
                    if act and act != 'All Actions': q += "AND a.action = ? "; params.append(act)
                    # Note: audit_log doesn't link to contract_id directly; we cannot reliably filter by contract
                    q += "ORDER BY a.timestamp DESC LIMIT 500"
                    cur.execute(q, params); rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try: messagebox.showerror("Activities", f"Failed to load: {str(e)}")
                    except Exception: pass
                    rows = []
                for it in tree.get_children(): tree.delete(it)
                for r in rows: tree.insert('', 'end', values=r)
                try:
                    self.log_audit_action(self.current_user['id'], "View Contractor Activities", json.dumps({"contract": contract_var.get(), "contractor": contractor_var.get()}))
                except Exception: pass
            def view_details_c():
                sel = tree.selection()
                if not sel:
                    try:
                        messagebox.showinfo("Details", "Select a record first")
                    except Exception:
                        pass
                    return
                vals = tree.item(sel[0])['values']
                details_text = vals[3] if len(vals) > 3 else ''
                try:
                    parsed = None
                    try:
                        parsed = json.loads(details_text)
                    except Exception:
                        parsed = None
                    pretty = json.dumps(parsed, indent=2, ensure_ascii=False) if parsed is not None else str(details_text)
                    d = tk.Toplevel(win); d.title("Activity Details"); d.geometry("600x420"); d.configure(bg='white'); d.grab_set()
                    txt = tk.Text(d, wrap='word'); txt.pack(fill='both', expand=True, padx=8, pady=8)
                    txt.insert('1.0', pretty); txt.config(state='disabled')
                    tk.Button(d, text='Close', command=d.destroy).pack(pady=6)
                except Exception:
                    try:
                        messagebox.showinfo("Details", str(details_text))
                    except Exception:
                        pass

            # Populate actions for contractors filter
            try:
                connC = self.db_manager.create_connection(); curC = connC.cursor()
                curC.execute("SELECT DISTINCT a.action FROM audit_log a JOIN users u ON u.id=a.user_id WHERE u.role='contractor' ORDER BY a.action")
                actsC = [r[0] for r in curC.fetchall()]; connC.close()
                action_cb_c['values'] = ['All Actions'] + actsC
                action_cb_c.set('All Actions')
            except Exception:
                action_cb_c['values'] = ['All Actions']; action_cb_c.set('All Actions')

            refresh_btn.config(command=refresh); details_btn_c.config(command=view_details_c); contract_var.trace('w', lambda *a: refresh()); contractor_var.trace('w', lambda *a: refresh()); action_var_c.trace('w', lambda *a: refresh())
            load_filters(); refresh()
        except Exception as e:
            try: messagebox.showerror("Error", f"Failed to open Contractor Activities: {str(e)}")
            except Exception: pass

    def show_contractor_reports(self):
        try:
            if not getattr(self, 'current_user', None) or self.current_user.get('role') != 'contract_owner':
                messagebox.showwarning("Access", "Only Contract Owners can view contractor reports."); return
            win = tk.Toplevel(self.root); win.title("Contractor Reports"); win.geometry("720x500"); win.configure(bg='white'); win.grab_set()
            tk.Label(win, text="Contractor Reports (Summary)", font=('Arial',16,'bold'), bg='white').pack(pady=10)
            txt = tk.Text(win, height=16); txt.pack(fill='both', expand=True, padx=10, pady=10)
            def refresh():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Contractors linked to this owner's contracts
                    cur.execute("SELECT COALESCE(u.full_name,u.username), COUNT(a.id) FROM users u LEFT JOIN audit_log a ON a.user_id=u.id WHERE u.role='contractor' GROUP BY u.id ORDER BY 2 DESC")
                    rows = cur.fetchall(); conn.close()
                    txt.config(state='normal'); txt.delete('1.0','end')
                    txt.insert('end', "Contractor Activity Counts (from audit log)\n\n")
                    for name, cnt in rows:
                        txt.insert('end', f"- {name}: {cnt} activities logged\n")
                    txt.config(state='disabled')
                except Exception as e:
                    txt.config(state='normal'); txt.delete('1.0','end'); txt.insert('end', f"Failed to load: {str(e)}"); txt.config(state='disabled')
            def export():
                try:
                    from tkinter import filedialog as fd
                    filename = fd.asksaveasfilename(title="Export Contractor Report", defaultextension=".txt")
                    if not filename: return
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(txt.get('1.0','end'))
                    messagebox.showinfo("Export", "Report saved")
                except Exception as e:
                    try: messagebox.showerror("Export", f"Failed: {str(e)}")
                    except Exception: pass
            btns = tk.Frame(win, bg='white'); btns.pack(fill='x', padx=10, pady=8)
            tk.Button(btns, text="Refresh", bg="#3498db", fg="white", command=refresh).pack(side='left')
            tk.Button(btns, text="Export", command=export).pack(side='left', padx=8)
            tk.Button(btns, text="Close", command=win.destroy).pack(side='right')
            refresh()
        except Exception as e:
            try: messagebox.showerror("Error", f"Failed to open Contractor Reports: {str(e)}")
            except Exception: pass

    def create_employer_menu(self, menubar):
        # Jobs menu
        jobs_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Jobs", menu=jobs_menu)
        # Use safe getattr to avoid AttributeError if some builds miss these methods
        post_cmd = getattr(self, 'show_post_job', lambda: messagebox.showinfo("Jobs", "Post Job is unavailable."))
        manage_cmd = getattr(self, 'open_manage_jobs', getattr(self, 'show_manage_jobs', getattr(self, 'show_manage_job', lambda: messagebox.showinfo("Jobs", "Manage Jobs is unavailable."))))
        view_apps_cmd = getattr(self, 'show_view_applicants', lambda: messagebox.showinfo("Jobs", "View Applicants is unavailable."))
        sched_cmd = getattr(self, 'show_schedule_interview', lambda: messagebox.showinfo("Jobs", "Schedule Interview is unavailable."))
        jobs_menu.add_command(label="Post Job", command=post_cmd)
        jobs_menu.add_command(label="Manage Jobs", command=manage_cmd)
        jobs_menu.add_command(label="View Applicants", command=view_apps_cmd)
        jobs_menu.add_command(label="Schedule Interview", command=sched_cmd)

    def logout(self):
        if self.current_user:
            self.log_audit_action(self.current_user['id'], "Logout",
                                  f"User {self.current_user['username']} logged out")
        self.current_user = None
        self.show_login()

    # Dashboard methods for different roles
    def show_payments_center(self):
        """Open the Payments Center UI.

        Creates a modal window with tabs for making payments, confirming incoming payments,
        managing refunds, viewing history, and configuring store receipt settings. The UI
        registers multiple nested callbacks that interact with the SQLite database via
        DatabaseManager. Behavior is preserved and side effects are limited to UI creation
        and database reads/writes.

        Raises:
            tk.TclError: If the Tkinter root window is not available.
        """
        try:
            if not getattr(self, 'current_user', None):
                messagebox.showerror('Payments', 'You must be logged in to manage payments.')
                return
            win = tk.Toplevel(self.root)
            win.title('Payments Center')
            win.geometry('1000x650')
            win.configure(bg='white')
            win.grab_set()

            nb = ttk.Notebook(win)
            nb.pack(fill='both', expand=True)

            # Tabs
            tab_make = tk.Frame(nb, bg='white')
            tab_incoming = tk.Frame(nb, bg='white')
            tab_refunds = tk.Frame(nb, bg='white')
            tab_history = tk.Frame(nb, bg='white')
            tab_settings = tk.Frame(nb, bg='white')

            nb.add(tab_make, text='Make Payment')
            nb.add(tab_incoming, text='Incoming (Confirm)')
            nb.add(tab_refunds, text='Refunds')
            nb.add(tab_history, text='History')
            nb.add(tab_settings, text='Store Receipt Settings')

            # ---------- Helpers ----------
            def _now():
                return datetime.now().isoformat(sep=' ')

            def _gen_ref(prefix):
                ts = datetime.now().strftime('%Y%m%d-%H%M%S')
                return f"{prefix}-{ts}-{self.current_user['id']}"

            def _load_users():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT id, COALESCE(full_name, username) FROM users WHERE is_active=1 ORDER BY full_name, username")
                    rows = cur.fetchall(); conn.close()
                    return [(r[0], r[1]) for r in rows]
                except Exception:
                    return []

            def _load_my_stores():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Owner or manager
                    cur.execute("SELECT id, name FROM stores WHERE owner_id=? OR manager_id=? ORDER BY name", (self.current_user['id'], self.current_user['id']))
                    rows = cur.fetchall(); conn.close()
                    return [(r[0], r[1]) for r in rows]
                except Exception:
                    return []

            def _print_receipt_decision(store_id, require_receipt_flag):
                should_print = False
                if store_id:
                    try:
                        conn = self.db_manager.create_connection(); cur = conn.cursor()
                        cur.execute("SELECT COALESCE(print_receipt_default,1) FROM stores WHERE id=?", (store_id,))
                        r = cur.fetchone(); conn.close()
                        should_print = bool(r[0]) if r else False
                    except Exception:
                        should_print = False
                # If explicitly required by payer, force printing
                if require_receipt_flag:
                    should_print = True
                # If store or payer requires printing, do it silently; otherwise ask the user
                if should_print:
                    return True
                try:
                    return messagebox.askyesno('Receipt', 'Print receipt for this transaction?')
                except Exception:
                    return False

            def _render_and_print_receipt(payment_id):
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute(
                        '''
                        SELECT p.reference, p.created_at, p.amount, p.currency, p.method, p.purpose,
                               p.payer_id, p.payee_id, p.store_id, COALESCE(s.name,''), COALESCE(s.receipt_template,''),
                               COALESCE(u1.full_name,u1.username), COALESCE(u2.full_name,u2.username),
                               COALESCE(p.link_type,''), COALESCE(p.link_id,'')
                        FROM payments p
                        LEFT JOIN stores s ON s.id = p.store_id
                        LEFT JOIN users u1 ON u1.id = p.payer_id
                        LEFT JOIN users u2 ON u2.id = p.payee_id
                        WHERE p.id = ?
                        ''', (payment_id,)
                    )
                    row = cur.fetchone(); conn.close()
                    if not row:
                        messagebox.showerror('Receipt', 'Payment not found for receipt.'); return
                    (reference, created_at, amount, currency, method, purpose,
                     payer_id, payee_id, store_id, store_name, template,
                     payer_name, payee_name, link_type, link_id) = row
                    if not template:
                        template = (
                            '--- Payment Receipt ---\n'
                            'Ref: {reference}\nDate: {date}\n'
                            'Payer: {payer}\nPayee: {payee}\n'
                            'Amount: {amount} {currency}\nMethod: {method}\nPurpose: {purpose}\n'
                            'Store: {store}\nLinked: {link_type} #{link_id}\n'
                            '------------------------\n'
                        )
                    data = {
                        'reference': reference,
                        'date': created_at,
                        'payer': payer_name,
                        'payee': payee_name,
                        'amount': f"{float(amount):,.0f}" if amount is not None else '',
                        'currency': currency or '',
                        'method': method or '',
                        'purpose': purpose or '',
                        'store': store_name or '',
                        'link_type': link_type or '',
                        'link_id': link_id or ''
                    }
                    try:
                        rendered = template.format(**data)
                    except Exception:
                        # fallback safe rendering
                        rendered = template
                        for k, v in data.items():
                            rendered = rendered.replace('{' + k + '}', str(v))
                    # Preview window
                    d = tk.Toplevel(win); d.title('Receipt Preview'); d.geometry('520x520'); d.configure(bg='white'); d.grab_set()
                    txt = tk.Text(d, wrap='word'); txt.pack(fill='both', expand=True, padx=8, pady=8)
                    txt.insert('1.0', rendered); txt.config(state='disabled')
                    btns = tk.Frame(d, bg='white'); btns.pack(fill='x')
                    def save_txt():
                        try:
                            from tkinter import filedialog as fd
                            fn = fd.asksaveasfilename(defaultextension='.txt', initialfile=f'{reference}_receipt.txt')
                            if not fn: return
                            with open(fn, 'w', encoding='utf-8') as f: f.write(rendered)
                            messagebox.showinfo('Receipt', f'Receipt saved to {fn}')
                        except Exception as ex:
                            messagebox.showerror('Receipt', f'Failed to save: {ex}')
                    def mark_printed_and_close():
                        try:
                            conn2 = self.db_manager.create_connection(); c2 = conn2.cursor()
                            c2.execute('UPDATE payments SET receipt_printed=1 WHERE id=?', (payment_id,))
                            conn2.commit(); conn2.close()
                        except Exception:
                            pass
                        d.destroy()
                    tk.Button(btns, text='Save As...', command=save_txt).pack(side='left', padx=6, pady=6)
                    tk.Button(btns, text='Mark Printed', bg='#27ae60', fg='white', command=mark_printed_and_close).pack(side='right', padx=6, pady=6)
                except Exception as ex:
                    try: messagebox.showerror('Receipt', f'Failed to render receipt: {ex}')
                    except Exception: pass

            # ---------- Make Payment Tab ----------
            frm = tk.Frame(tab_make, bg='white'); frm.pack(fill='x', padx=12, pady=12)
            tk.Label(frm, text='Payee:', bg='white').grid(row=0, column=0, sticky='e', padx=6, pady=6)
            payee_var = tk.StringVar(); payee_cb = ttk.Combobox(frm, textvariable=payee_var, state='readonly', width=40); payee_cb.grid(row=0, column=1, sticky='w')
            tk.Label(frm, text='Amount:', bg='white').grid(row=1, column=0, sticky='e', padx=6, pady=6)
            amount_var = tk.StringVar(); tk.Entry(frm, textvariable=amount_var, width=20).grid(row=1, column=1, sticky='w')
            tk.Label(frm, text='Currency:', bg='white').grid(row=0, column=2, sticky='e', padx=6)
            currency_var = tk.StringVar(value='XAF'); ttk.Combobox(frm, textvariable=currency_var, values=['XAF','USD','EUR'], state='readonly', width=8).grid(row=0, column=3, sticky='w')
            tk.Label(frm, text='Method:', bg='white').grid(row=1, column=2, sticky='e', padx=6)
            method_var = tk.StringVar(value='Cash'); method_cb = ttk.Combobox(frm, textvariable=method_var, values=['Cash','Mobile Money','Bank'], state='readonly', width=16); method_cb.grid(row=1, column=3, sticky='w')
            tk.Label(frm, text='Purpose:', bg='white').grid(row=2, column=0, sticky='e', padx=6, pady=6)
            purpose_var = tk.StringVar(value='Advance'); tk.Entry(frm, textvariable=purpose_var, width=30).grid(row=2, column=1, sticky='w')
            tk.Label(frm, text='Store (optional):', bg='white').grid(row=2, column=2, sticky='e', padx=6, pady=6)
            store_var = tk.StringVar(); store_cb = ttk.Combobox(frm, textvariable=store_var, state='readonly', width=38); store_cb.grid(row=2, column=3, sticky='w')

            # Account details and linkage
            tk.Label(frm, text='Payer Account Number:', bg='white').grid(row=3, column=0, sticky='e', padx=6, pady=6)
            payer_account_var = tk.StringVar(); tk.Entry(frm, textvariable=payer_account_var, width=30).grid(row=3, column=1, sticky='w')
            method_account_label = tk.Label(frm, text='Method Account:', bg='white'); method_account_label.grid(row=3, column=2, sticky='e', padx=6, pady=6)
            method_account_var = tk.StringVar(); method_account_entry = tk.Entry(frm, textvariable=method_account_var, width=30); method_account_entry.grid(row=3, column=3, sticky='w')

            tk.Label(frm, text='Link Type:', bg='white').grid(row=4, column=0, sticky='e', padx=6, pady=6)
            link_type_var = tk.StringVar(value='Material'); link_type_cb = ttk.Combobox(frm, textvariable=link_type_var, values=['Material','Labour','Contract','Salary'], state='readonly', width=16); link_type_cb.grid(row=4, column=1, sticky='w')
            tk.Label(frm, text='Link ID:', bg='white').grid(row=4, column=2, sticky='e', padx=6, pady=6)
            link_id_var = tk.StringVar(); tk.Entry(frm, textvariable=link_id_var, width=20).grid(row=4, column=3, sticky='w')

            require_receipt = tk.IntVar(value=0); tk.Checkbutton(frm, text='Require Receipt', variable=require_receipt, bg='white').grid(row=5, column=1, sticky='w', padx=2, pady=6)
            submit_btn = tk.Button(frm, text='Submit Payment', bg='#27ae60', fg='white'); submit_btn.grid(row=5, column=3, sticky='e')

            # Load combobox values
            users = _load_users(); user_map = {f"{uid} - {name}": uid for uid, name in users if uid != self.current_user['id']}
            payee_cb['values'] = list(user_map.keys())
            stores = _load_my_stores(); store_map = {f"{sid} - {name}": sid for sid, name in stores}
            store_cb['values'] = list(store_map.keys())

            def _update_method_fields(*args):
                m = method_var.get()
                if m == 'Mobile Money':
                    method_account_label.config(text='Mobile Money Number:')
                    method_account_entry.config(state='normal')
                elif m == 'Bank':
                    method_account_label.config(text='Bank Account Number:')
                    method_account_entry.config(state='normal')
                else:
                    method_account_label.config(text='Method Account:')
                    method_account_entry.config(state='disabled')
                    method_account_var.set('')
            method_var.trace('w', _update_method_fields); _update_method_fields()

            def _prompt_password_and_verify():
                d = tk.Toplevel(win); d.title('Confirm Identity'); d.geometry('380x160'); d.configure(bg='white'); d.grab_set();
                tk.Label(d, text='Enter your password to proceed:', bg='white').pack(pady=8)
                pwd_var = tk.StringVar(); e = tk.Entry(d, textvariable=pwd_var, show='*', width=36); e.pack(pady=6); e.focus_set()
                result = {'ok': False}
                def ok():
                    pw = pwd_var.get().strip()
                    if not pw:
                        try: messagebox.showerror('Security','Password is required.');
                        except Exception: pass
                        return
                    try:
                        conn = self.db_manager.create_connection(); cur = conn.cursor()
                        cur.execute('SELECT password_hash FROM users WHERE id=?', (self.current_user['id'],))
                        stored = cur.fetchone()[0]; conn.close()
                        if self.security_manager.verify_password(pw, stored):
                            result['ok'] = True; d.destroy()
                        else:
                            messagebox.showerror('Security','Invalid password.');
                    except Exception as ex:
                        try: messagebox.showerror('Security', f'Error verifying password: {ex}')
                        except Exception: pass
                tk.Button(d, text='Confirm', bg='#27ae60', fg='white', command=ok).pack()
                tk.Button(d, text='Cancel', command=d.destroy).pack(pady=4)
                d.wait_window()
                return result['ok']

            def do_submit_payment():
                if not payee_var.get():
                    messagebox.showwarning('Validation', 'Select a payee.'); return
                try:
                    amt = float(amount_var.get()); assert amt > 0
                except Exception:
                    messagebox.showerror('Validation', 'Enter a valid amount (> 0).'); return
                if not payer_account_var.get().strip():
                    messagebox.showerror('Validation', 'Payer Account Number is required.'); return
                m = method_var.get()
                if m in ('Mobile Money','Bank') and not method_account_var.get().strip():
                    needed = 'Mobile Money Number' if m=='Mobile Money' else 'Bank Account Number'
                    messagebox.showerror('Validation', f'{needed} is required for method {m}.'); return
                lt = link_type_var.get(); lid_raw = link_id_var.get().strip()
                try:
                    lid = int(lid_raw); assert lid > 0
                except Exception:
                    messagebox.showerror('Validation', 'Link ID must be a positive integer.'); return
                pid = self.current_user['id']; payee = user_map.get(payee_var.get())
                if not payee or payee == pid:
                    messagebox.showerror('Validation', 'Invalid payee selected.'); return
                sid = store_map.get(store_var.get()) if store_var.get() else None
                # Password confirm
                if not _prompt_password_and_verify():
                    return
                # Encrypt sensitive data
                payer_acct = payer_account_var.get().strip()
                method_acct = method_account_var.get().strip() if m in ('Mobile Money','Bank') else ''
                try:
                    if hasattr(self, 'security_manager') and self.security_manager:
                        payer_acct = self.security_manager.encrypt_data(payer_acct)
                        if method_acct:
                            method_acct = self.security_manager.encrypt_data(method_acct)
                except Exception:
                    pass
                ref = _gen_ref('PAY')
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute(
                        """
                        INSERT INTO payments (
                            reference, payer_id, payee_id, store_id, amount, currency, method, purpose,
                            status, created_at, meta, require_receipt, receipt_printed,
                            payer_account, method_account, link_type, link_id
                        )
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'Pending', ?, ?, ?, 0, ?, ?, ?, ?)
                        """,
                        (ref, pid, payee, sid, amt, currency_var.get(), m, purpose_var.get().strip(), _now(), json.dumps({}), int(require_receipt.get()), payer_acct, method_acct, lt, lid)
                    )
                    conn.commit(); conn.close()
                    try: self.log_audit_action(pid, 'Create Payment', json.dumps({'reference': ref, 'payee_id': payee, 'amount': amt, 'link_type': lt, 'link_id': lid}))
                    except Exception: pass
                    messagebox.showinfo('Payment', f'Payment {ref} created and pending confirmation by receiver.')
                    amount_var.set(''); purpose_var.set('Advance'); require_receipt.set(0); payer_account_var.set(''); method_account_var.set(''); link_id_var.set('')
                except Exception as e:
                    messagebox.showerror('Payment', f'Failed to create payment: {e}')

            submit_btn.config(command=do_submit_payment)

            # ---------- Incoming Tab ----------
            top_in = tk.Frame(tab_incoming, bg='white'); top_in.pack(fill='both', expand=True, padx=10, pady=10)
            tk.Label(top_in, text='Pending Payments To Me', font=('Arial', 12, 'bold'), bg='white').pack(anchor='w')
            cols_p = ('ID','Reference','From','Amount','Currency','Method','Purpose','Created','Store')
            tree_p = ttk.Treeview(top_in, columns=cols_p, show='headings', height=8)
            for c in cols_p:
                tree_p.heading(c, text=c); tree_p.column(c, width=120 if c not in ('Purpose','Reference') else 180)
            tree_p.pack(fill='x', padx=0, pady=6)
            btns_p = tk.Frame(top_in, bg='white'); btns_p.pack(fill='x')
            btn_confirm = tk.Button(btns_p, text='Confirm Payment', bg='#27ae60', fg='white')
            btn_reject = tk.Button(btns_p, text='Reject/Cancel', bg='#c0392b', fg='white')
            btn_refresh_in = tk.Button(btns_p, text='Refresh')
            btn_confirm.pack(side='left'); btn_reject.pack(side='left', padx=6); btn_refresh_in.pack(side='right')

            tk.Label(top_in, text='Pending Refunds To Me', font=('Arial', 12, 'bold'), bg='white').pack(anchor='w', pady=(10,0))
            cols_r = ('ID','PaymentRef','From(Payee)','Amount','Status','RequestedAt')
            tree_r = ttk.Treeview(top_in, columns=cols_r, show='headings', height=8)
            for c in cols_r:
                tree_r.heading(c, text=c); tree_r.column(c, width=140 if c!='PaymentRef' else 180)
            tree_r.pack(fill='x', padx=0, pady=6)
            btns_r = tk.Frame(top_in, bg='white'); btns_r.pack(fill='x')
            btn_mark_sent = tk.Button(btns_r, text='Mark Refund Sent', bg='#8e44ad', fg='white')
            btn_confirm_refund = tk.Button(btns_r, text='Confirm Receipt', bg='#27ae60', fg='white')
            btn_reject_refund = tk.Button(btns_r, text='Reject', bg='#c0392b', fg='white')
            btn_mark_sent.pack(side='left'); btn_confirm_refund.pack(side='left', padx=6); btn_reject_refund.pack(side='left', padx=6)

            def refresh_incoming():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Payments pending to me
                    cur.execute(
                        """
                        SELECT p.id, p.reference, COALESCE(u.full_name,u.username), p.amount, p.currency, p.method, p.purpose, p.created_at, COALESCE(s.name,'')
                        FROM payments p
                        JOIN users u ON u.id = p.payer_id
                        LEFT JOIN stores s ON s.id = p.store_id
                        WHERE p.payee_id = ? AND p.status = 'Pending'
                        ORDER BY p.created_at DESC
                        """,
                        (self.current_user['id'],)
                    )
                    rows_p = cur.fetchall()
                    # Refunds to me (I am receiver): find refunds with status 'Awaiting Receiver' and payment.payer_id = me
                    cur.execute(
                        """
                        SELECT r.id, p.reference, COALESCE(u.full_name,u.username) AS from_user, r.amount, r.status, r.requested_at
                        FROM refunds r
                        JOIN payments p ON p.id = r.payment_id
                        JOIN users u ON u.id = p.payee_id
                        WHERE (p.payee_id = ? AND r.status IN ('Pending'))
                           OR (p.payer_id = ? AND r.status IN ('Awaiting Receiver'))
                        ORDER BY r.requested_at DESC
                        """,
                        (self.current_user['id'], self.current_user['id'])
                    )
                    rows_r = cur.fetchall(); conn.close()
                except Exception as e:
                    try: messagebox.showerror('Incoming', f'Failed to load: {e}')
                    except Exception: pass
                    rows_p, rows_r = [], []
                for it in tree_p.get_children(): tree_p.delete(it)
                for r in rows_p: tree_p.insert('', 'end', values=r)
                for it in tree_r.get_children(): tree_r.delete(it)
                for r in rows_r: tree_r.insert('', 'end', values=r)

            def _get_sel(tree):
                sel = tree.selection()
                if not sel: return None
                return tree.item(sel[0])['values']

            def confirm_selected_payment():
                vals = _get_sel(tree_p)
                if not vals:
                    messagebox.showinfo('Payments', 'Select a pending payment.'); return
                pid = vals[0]
                try:
                    # Load details
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT store_id, require_receipt FROM payments WHERE id=? AND payee_id=?", (pid, self.current_user['id']))
                    row = cur.fetchone()
                    if not row:
                        conn.close(); messagebox.showerror('Payments', 'Not authorized to confirm this payment.'); return
                    store_id, req_flag = row
                    cur.execute("UPDATE payments SET status='Confirmed', confirmed_at=?, confirmed_by=? WHERE id=?", (_now(), self.current_user['id'], pid))
                    conn.commit(); conn.close()
                    try: self.log_audit_action(self.current_user['id'], 'Confirm Payment', json.dumps({'payment_id': pid}))
                    except Exception: pass
                    # Receipt decision
                    if _print_receipt_decision(store_id, int(req_flag or 0)):
                        _render_and_print_receipt(pid)
                    refresh_incoming()
                except Exception as e:
                    messagebox.showerror('Payments', f'Failed to confirm: {e}')

            def reject_selected_payment():
                vals = _get_sel(tree_p)
                if not vals:
                    messagebox.showinfo('Payments', 'Select a pending payment.'); return
                pid = vals[0]
                try:
                    if not messagebox.askyesno('Cancel', 'Reject/cancel this payment?'): return
                except Exception: pass
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("UPDATE payments SET status='Cancelled' WHERE id=? AND payee_id=?", (pid, self.current_user['id']))
                    conn.commit(); conn.close(); refresh_incoming()
                    try: self.log_audit_action(self.current_user['id'], 'Cancel Payment', json.dumps({'payment_id': pid}))
                    except Exception: pass
                except Exception as e:
                    messagebox.showerror('Payments', f'Failed to cancel: {e}')

            def mark_refund_sent():
                vals = _get_sel(tree_r)
                if not vals:
                    messagebox.showinfo('Refunds', 'Select a refund to mark sent.'); return
                rid = vals[0]
                try:
                    # Only original payee (who will send money back) may mark sent
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT r.id, p.payee_id FROM refunds r JOIN payments p ON p.id=r.payment_id WHERE r.id=?", (rid,))
                    row = cur.fetchone()
                    if not row or row[1] != self.current_user['id']:
                        conn.close(); messagebox.showerror('Refunds', 'Only the original receiver can mark the refund as sent.'); return
                    # Put a note in meta
                    cur.execute("UPDATE refunds SET status='Awaiting Receiver' WHERE id=?", (rid,))
                    conn.commit(); conn.close()
                    try: self.log_audit_action(self.current_user['id'], 'Refund Mark Sent', json.dumps({'refund_id': rid}))
                    except Exception: pass
                    refresh_incoming()
                except Exception as e:
                    messagebox.showerror('Refunds', f'Failed: {e}')

            def confirm_refund_received():
                vals = _get_sel(tree_r)
                if not vals:
                    messagebox.showinfo('Refunds', 'Select a refund to confirm.'); return
                rid = vals[0]
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Authorization: I must be the original payer
                    cur.execute("SELECT r.payment_id, r.amount, p.payer_id, p.store_id FROM refunds r JOIN payments p ON p.id=r.payment_id WHERE r.id=?", (rid,))
                    row = cur.fetchone()
                    if not row or row[2] != self.current_user['id']:
                        conn.close(); messagebox.showerror('Refunds', 'Not authorized to confirm this refund.'); return
                    payment_store_id = row[3]
                    cur.execute("UPDATE refunds SET status='Confirmed', confirmed_at=?, confirmed_by=? WHERE id=?", (_now(), self.current_user['id'], rid))
                    conn.commit(); conn.close()
                    # Receipt?
                    if _print_receipt_decision(payment_store_id, 0):
                        messagebox.showinfo('Receipt', 'Receipt printed for refund.')
                    try: self.log_audit_action(self.current_user['id'], 'Confirm Refund', json.dumps({'refund_id': rid}))
                    except Exception: pass
                    refresh_incoming()
                except Exception as e:
                    messagebox.showerror('Refunds', f'Failed: {e}')

            def reject_refund():
                vals = _get_sel(tree_r)
                if not vals:
                    messagebox.showinfo('Refunds', 'Select a refund to reject.'); return
                rid = vals[0]
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Original payee may reject prior to sending, or receiver may reject after sent
                    cur.execute("SELECT p.payee_id, p.payer_id, r.status FROM refunds r JOIN payments p ON p.id=r.payment_id WHERE r.id=?", (rid,))
                    row = cur.fetchone()
                    if not row:
                        conn.close(); return
                    payee_id, payer_id, status = row
                    can = False
                    if status == 'Pending' and payee_id == self.current_user['id']: can = True
                    if status == 'Awaiting Receiver' and payer_id == self.current_user['id']: can = True
                    if not can:
                        conn.close(); messagebox.showerror('Refunds', 'You cannot reject this refund at current stage.'); return
                    cur.execute("UPDATE refunds SET status='Cancelled' WHERE id=?", (rid,))
                    conn.commit(); conn.close(); refresh_incoming()
                    try: self.log_audit_action(self.current_user['id'], 'Cancel Refund', json.dumps({'refund_id': rid}))
                    except Exception: pass
                except Exception as e:
                    messagebox.showerror('Refunds', f'Failed: {e}')

            btn_confirm.config(command=confirm_selected_payment)
            btn_reject.config(command=reject_selected_payment)
            btn_refresh_in.config(command=refresh_incoming)
            btn_mark_sent.config(command=mark_refund_sent)
            btn_confirm_refund.config(command=confirm_refund_received)
            btn_reject_refund.config(command=reject_refund)

            # ---------- Refunds Tab ----------
            rf = tk.Frame(tab_refunds, bg='white'); rf.pack(fill='both', expand=True, padx=10, pady=10)
            tk.Label(rf, text='Request Refund for My Confirmed Payments', font=('Arial', 12, 'bold'), bg='white').pack(anchor='w')
            cols_pr = ('PaymentID','Reference','From(Me)','To','Amount','ConfirmedAt')
            tree_pr = ttk.Treeview(rf, columns=cols_pr, show='headings', height=8)
            for c in cols_pr: tree_pr.heading(c, text=c); tree_pr.column(c, width=140 if c!='Reference' else 180)
            tree_pr.pack(fill='x', pady=6)
            form_rf = tk.Frame(rf, bg='white'); form_rf.pack(fill='x')
            tk.Label(form_rf, text='Refund Amount:', bg='white').grid(row=0, column=0, sticky='e', padx=6)
            r_amount_var = tk.StringVar(); tk.Entry(form_rf, textvariable=r_amount_var, width=18).grid(row=0, column=1, sticky='w')
            tk.Label(form_rf, text='Reason:', bg='white').grid(row=0, column=2, sticky='e', padx=6)
            r_reason_var = tk.StringVar(); tk.Entry(form_rf, textvariable=r_reason_var, width=40).grid(row=0, column=3, sticky='w')
            btn_req_refund = tk.Button(form_rf, text='Request Refund', bg='#e67e22', fg='white'); btn_req_refund.grid(row=0, column=4, padx=8)

            def load_confirmed_mine():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute(
                        """
                        SELECT p.id, p.reference, COALESCE(u1.full_name,u1.username) AS from_me, COALESCE(u2.full_name,u2.username) AS to_user, p.amount, p.confirmed_at
                        FROM payments p
                        JOIN users u1 ON u1.id = p.payer_id
                        JOIN users u2 ON u2.id = p.payee_id
                        WHERE p.payer_id=? AND p.status='Confirmed'
                        ORDER BY p.confirmed_at DESC
                        """,
                        (self.current_user['id'],)
                    )
                    rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try: messagebox.showerror('Refunds', f'Failed to load: {e}')
                    except Exception: pass
                    rows = []
                for it in tree_pr.get_children(): tree_pr.delete(it)
                for r in rows: tree_pr.insert('', 'end', values=r)

            def request_refund():
                sel = tree_pr.selection()
                if not sel: messagebox.showinfo('Refunds', 'Select a payment first.'); return
                vals = tree_pr.item(sel[0])['values']
                pay_id, ref, _from, to_user, amt_total, _cAt = vals
                try:
                    val = float(r_amount_var.get()); assert 0 < val <= float(amt_total)
                except Exception:
                    messagebox.showerror('Refunds', 'Enter a valid refund amount (>0 and <= payment amount).'); return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute(
                        """
                        INSERT INTO refunds (payment_id, amount, reason, status, requested_by, requested_at)
                        VALUES (?, ?, ?, 'Pending', ?, ?)
                        """,
                        (pay_id, val, r_reason_var.get().strip(), self.current_user['id'], _now())
                    )
                    conn.commit(); conn.close()
                    try: self.log_audit_action(self.current_user['id'], 'Request Refund', json.dumps({'payment_id': int(pay_id), 'amount': val}))
                    except Exception: pass
                    r_amount_var.set(''); r_reason_var.set(''); load_confirmed_mine(); refresh_incoming()
                    messagebox.showinfo('Refunds', 'Refund requested. The original receiver must process and mark as sent before you can confirm receipt.')
                except Exception as e:
                    messagebox.showerror('Refunds', f'Failed to request refund: {e}')

            btn_req_refund.config(command=request_refund)

            # ---------- History Tab ----------
            hf = tk.Frame(tab_history, bg='white'); hf.pack(fill='both', expand=True, padx=10, pady=10)
            tk.Label(hf, text='My Payments (Outgoing and Incoming)', font=('Arial', 12, 'bold'), bg='white').pack(anchor='w')
            cols_h = ('Reference','Role','Counterparty','Amount','Currency','Status','Created/Confirmed','Purpose')
            tree_h = ttk.Treeview(hf, columns=cols_h, show='headings')
            for c in cols_h: tree_h.heading(c, text=c); tree_h.column(c, width=140 if c not in ('Reference','Purpose') else 180)
            tree_h.pack(fill='both', expand=True, pady=6)

            def load_history():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Outgoing
                    cur.execute(
                        """
                        SELECT reference, 'Outgoing', COALESCE(u.full_name,u.username), amount, currency, status, COALESCE(confirmed_at, created_at), purpose
                        FROM payments p JOIN users u ON u.id = p.payee_id
                        WHERE p.payer_id = ?
                        UNION ALL
                        SELECT reference, 'Incoming', COALESCE(u.full_name,u.username), amount, currency, status, COALESCE(confirmed_at, created_at), purpose
                        FROM payments p JOIN users u ON u.id = p.payer_id
                        WHERE p.payee_id = ?
                        ORDER BY 7 DESC
                        """,
                        (self.current_user['id'], self.current_user['id'])
                    )
                    rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try: messagebox.showerror('History', f'Failed to load: {e}')
                    except Exception: pass
                    rows = []
                for it in tree_h.get_children(): tree_h.delete(it)
                for r in rows: tree_h.insert('', 'end', values=r)

            # ---------- Settings Tab ----------
            sf = tk.Frame(tab_settings, bg='white'); sf.pack(fill='both', expand=True, padx=10, pady=10)
            tk.Label(sf, text='Store Receipt Printing', font=('Arial', 12, 'bold'), bg='white').pack(anchor='w')
            cols_s = ('StoreID','Store','Print Receipt by Default')
            tree_s = ttk.Treeview(sf, columns=cols_s, show='headings')
            for c in cols_s: tree_s.heading(c, text=c); tree_s.column(c, width=220 if c=='Store' else 180)
            tree_s.pack(fill='x', pady=6)
            btns_s = tk.Frame(sf, bg='white'); btns_s.pack(fill='x')
            btn_toggle = tk.Button(btns_s, text='Toggle Setting', bg='#3498db', fg='white')
            btn_design = tk.Button(btns_s, text='Design Template', bg='#8e44ad', fg='white')
            btn_refresh_s = tk.Button(btns_s, text='Refresh')
            btn_toggle.pack(side='left'); btn_design.pack(side='left', padx=6); btn_refresh_s.pack(side='right')

            def load_store_settings():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT id, name, COALESCE(print_receipt_default,1) FROM stores WHERE owner_id=? OR manager_id=? ORDER BY name", (self.current_user['id'], self.current_user['id']))
                    rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try: messagebox.showerror('Settings', f'Failed to load: {e}')
                    except Exception: pass
                    rows = []
                for it in tree_s.get_children(): tree_s.delete(it)
                for sid, name, pref in rows:
                    tree_s.insert('', 'end', values=(sid, name, 'Yes' if pref else 'No'))

            def toggle_setting():
                sel = tree_s.selection()
                if not sel: messagebox.showinfo('Settings', 'Select a store, then toggle.'); return
                vals = tree_s.item(sel[0])['values']; sid = vals[0]
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Flip preference
                    cur.execute("UPDATE stores SET print_receipt_default = CASE COALESCE(print_receipt_default,1) WHEN 1 THEN 0 ELSE 1 END WHERE id=? AND (owner_id=? OR manager_id=?)", (sid, self.current_user['id'], self.current_user['id']))
                    conn.commit(); conn.close(); load_store_settings()
                    try: self.log_audit_action(self.current_user['id'], 'Toggle Receipt Setting', json.dumps({'store_id': sid}))
                    except Exception: pass
                except Exception as e:
                    messagebox.showerror('Settings', f'Failed to update: {e}')

            def design_template():
                sel = tree_s.selection()
                if not sel:
                    messagebox.showinfo('Receipt Template', 'Select a store first.'); return
                vals = tree_s.item(sel[0])['values']; sid, sname = vals[0], vals[1]
                # Load existing template
                tpl = ''
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute('SELECT COALESCE(receipt_template, "") FROM stores WHERE id=?', (sid,))
                    r = cur.fetchone(); conn.close(); tpl = r[0] if r and r[0] else ''
                except Exception:
                    tpl = ''
                d = tk.Toplevel(sf); d.title(f'Design Receipt Template - {sname}'); d.geometry('740x520'); d.configure(bg='white'); d.grab_set()
                hint = (
                    'Use placeholders: {reference}, {date}, {payer}, {payee}, {amount}, {currency}, {method}, {purpose}, {store}, {link_type}, {link_id}\n'
                    'Example:\nRef: {reference} | Date: {date}\nPayer: {payer} -> Payee: {payee}\nAmount: {amount} {currency} via {method}\nPurpose: {purpose}\nStore: {store}\nLinked: {link_type} #{link_id}\n'
                )
                tk.Label(d, text=hint, bg='white', justify='left').pack(anchor='w', padx=10, pady=(10,4))
                txt = tk.Text(d, wrap='word'); txt.pack(fill='both', expand=True, padx=10, pady=6)
                txt.insert('1.0', tpl or '')
                btns = tk.Frame(d, bg='white'); btns.pack(fill='x', padx=10, pady=6)
                def save_tpl():
                    content = txt.get('1.0','end-1c')
                    try:
                        conn = self.db_manager.create_connection(); cur = conn.cursor()
                        cur.execute('UPDATE stores SET receipt_template=? WHERE id=? AND (owner_id=? OR manager_id=?)', (content, sid, self.current_user['id'], self.current_user['id']))
                        if cur.rowcount == 0:
                            # Allow admin override
                            cur.execute('UPDATE stores SET receipt_template=? WHERE id=?', (content, sid))
                        conn.commit(); conn.close()
                        try: self.log_audit_action(self.current_user['id'], 'Save Receipt Template', json.dumps({'store_id': sid}))
                        except Exception: pass
                        messagebox.showinfo('Receipt Template', 'Template saved.')
                        d.destroy()
                    except Exception as ex:
                        messagebox.showerror('Receipt Template', f'Failed to save: {ex}')
                tk.Button(btns, text='Save', bg='#27ae60', fg='white', command=save_tpl).pack(side='left')
                tk.Button(btns, text='Cancel', command=d.destroy).pack(side='right')

            btn_toggle.config(command=toggle_setting)
            btn_design.config(command=design_template)
            btn_refresh_s.config(command=load_store_settings)

            # Initial loads
            refresh_incoming(); load_confirmed_mine(); load_history(); load_store_settings()
        except Exception as e:
            try: messagebox.showerror('Payments', f'Failed to open Payments Center: {e}')
            except Exception: pass

    def show_admin_dashboard(self):
        # Clear content
        for widget in self.main_content.winfo_children():
            widget.destroy()

        # Dashboard title
        title = tk.Label(self.main_content, text="Administrator Dashboard",
                         font=('Arial', 18, 'bold'), bg='white')
        title.pack(pady=20)

        # Stats cards
        stats_frame = tk.Frame(self.main_content, bg='white')
        stats_frame.pack(fill='x', padx=20, pady=10)

        # Get statistics
        conn = self.db_manager.create_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT COUNT(*) FROM users")
        total_users = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM stores")
        total_stores = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM contracts")
        total_contracts = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM jobs WHERE status = 'Open'")
        active_jobs = cursor.fetchone()[0]

        conn.close()

        # Create stat cards
        stats = [
            ("Total Users", total_users, "#3498db"),
            ("Total Stores", total_stores, "#2ecc71"),
            ("Contracts", total_contracts, "#f39c12"),
            ("Active Jobs", active_jobs, "#e74c3c")
        ]

        for i, (label, value, color) in enumerate(stats):
            card = tk.Frame(stats_frame, bg=color, width=200, height=100)
            card.grid(row=0, column=i, padx=10, pady=10, sticky='nsew')
            card.grid_propagate(False)

            tk.Label(card, text=str(value), font=('Arial', 24, 'bold'),
                     bg=color, fg='white').pack(expand=True)
            tk.Label(card, text=label, font=('Arial', 12),
                     bg=color, fg='white').pack()

        # Configure grid weights
        for i in range(4):
            stats_frame.grid_columnconfigure(i, weight=1)

        # Recent activities
        activities_frame = tk.LabelFrame(self.main_content, text="Recent Activities",
                                         font=('Arial', 12, 'bold'), bg='white')
        activities_frame.pack(fill='both', expand=True, padx=20, pady=20)

        # Activities list
        activities_tree = ttk.Treeview(activities_frame, columns=('Time', 'User', 'Action'), show='headings')
        activities_tree.pack(fill='both', expand=True, padx=10, pady=10)

        activities_tree.heading('Time', text='Time')
        activities_tree.heading('User', text='User')
        activities_tree.heading('Action', text='Action')

        # Load recent activities
        conn = self.db_manager.create_connection()
        cursor = conn.cursor()
        cursor.execute('''
                       SELECT a.timestamp, u.username, a.action
                       FROM audit_log a
                                JOIN users u ON a.user_id = u.id
                       ORDER BY a.timestamp DESC LIMIT 10
                       ''')

        for row in cursor.fetchall():
            activities_tree.insert('', 'end', values=row)

        conn.close()

    def show_retail_dashboard(self):
        # Similar structure for retail dashboard
        for widget in self.main_content.winfo_children():
            widget.destroy()

        title = tk.Label(self.main_content, text="Retail Store Dashboard",
                         font=('Arial', 18, 'bold'), bg='white')
        title.pack(pady=20)

        # Store selection if user owns multiple stores
        store_frame = tk.Frame(self.main_content, bg='white')
        store_frame.pack(fill='x', padx=20, pady=10)

        tk.Label(store_frame, text="Select Store:", font=('Arial', 12),
                 bg='white').pack(side='left')

        self.store_var = tk.StringVar()
        store_combo = ttk.Combobox(store_frame, textvariable=self.store_var, state='readonly')
        store_combo.pack(side='left', padx=10)

        # Load user's stores
        conn = self.db_manager.create_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT id, name FROM stores WHERE owner_id = ?', (self.current_user['id'],))
        stores = cursor.fetchall()

        if stores:
            store_combo['values'] = [f"{store[0]} - {store[1]}" for store in stores]
            store_combo.current(0)

        conn.close()

        # Quick actions
        actions_frame = tk.Frame(self.main_content, bg='white')
        actions_frame.pack(fill='x', padx=20, pady=20)

        tk.Button(actions_frame, text="New Sale", font=('Arial', 12, 'bold'),
                  bg='#27ae60', fg='white', width=15,
                  command=self.show_new_sale).pack(side='left', padx=10)

        tk.Button(actions_frame, text="View Inventory", font=('Arial', 12, 'bold'),
                  bg='#3498db', fg='white', width=15,
                  command=self.show_view_inventory).pack(side='left', padx=10)

        tk.Button(actions_frame, text="View Analytics", font=('Arial', 12, 'bold'),
                  bg='#f39c12', fg='white', width=15,
                  command=self.show_store_analytics).pack(side='left', padx=10)

    def show_contract_owner_dashboard(self):
        # Contract owner dashboard
        for widget in self.main_content.winfo_children():
            widget.destroy()

        title = tk.Label(self.main_content, text="Contract Owner Dashboard",
                         font=('Arial', 18, 'bold'), bg='white')
        title.pack(pady=20)

        # Quick stats
        stats_frame = tk.Frame(self.main_content, bg='white')
        stats_frame.pack(fill='x', padx=20, pady=10)

        conn = self.db_manager.create_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT COUNT(*) FROM contracts WHERE contract_owner_id = ?",
                       (self.current_user['id'],))
        my_contracts = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM stores WHERE owner_id = ?",
                       (self.current_user['id'],))
        my_stores = cursor.fetchone()[0]

        conn.close()

        # Stats display
        tk.Label(stats_frame, text=f"My Contracts: {my_contracts}",
                 font=('Arial', 14), bg='white').pack(side='left', padx=20)
        tk.Label(stats_frame, text=f"My Stores: {my_stores}",
                 font=('Arial', 14), bg='white').pack(side='left', padx=20)

    def show_contractor_dashboard(self):
        # Contractor dashboard
        for widget in self.main_content.winfo_children():
            widget.destroy()

        title = tk.Label(self.main_content, text="Contractor Dashboard",
                         font=('Arial', 18, 'bold'), bg='white')
        title.pack(pady=20)

        # Available contracts
        contracts_frame = tk.LabelFrame(self.main_content, text="Available Contracts",
                                        font=('Arial', 12, 'bold'), bg='white')
        contracts_frame.pack(fill='both', expand=True, padx=20, pady=20)

        contracts_tree = ttk.Treeview(contracts_frame,
                                      columns=('Title', 'Budget', 'Start Date', 'Status'),
                                      show='headings')
        contracts_tree.pack(fill='both', expand=True, padx=10, pady=10)

        contracts_tree.heading('Title', text='Title')
        contracts_tree.heading('Budget', text='Budget (FCFA)')
        contracts_tree.heading('Start Date', text='Start Date')
        contracts_tree.heading('Status', text='Status')

        # Load available contracts
        conn = self.db_manager.create_connection()
        cursor = conn.cursor()
        cursor.execute('''
                       SELECT title, budget, start_date, status
                       FROM contracts
                       WHERE contractor_id IS NULL
                          OR contractor_id = ?
                       ORDER BY created_date DESC
                       ''', (self.current_user['id'],))

        for row in cursor.fetchall():
            contracts_tree.insert('', 'end', values=row)

        conn.close()

    def show_manager_dashboard(self):
        # Manager dashboard (limited access)
        for widget in self.main_content.winfo_children():
            widget.destroy()

        title = tk.Label(self.main_content, text="Store Manager Dashboard",
                         font=('Arial', 18, 'bold'), bg='white')
        title.pack(pady=20)

        # Show managed stores
        conn = self.db_manager.create_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT name, location FROM stores WHERE manager_id = ?',
                       (self.current_user['id'],))
        managed_stores = cursor.fetchall()
        conn.close()

        if managed_stores:
            for store_name, location in managed_stores:
                tk.Label(self.main_content, text=f"Managing: {store_name} - {location}",
                         font=('Arial', 14), bg='white').pack(pady=5)

    def show_job_seeker_dashboard(self):
        # Clear the main content area
        for widget in self.main_content.winfo_children():
            widget.destroy()

        # Dashboard header
        header_frame = tk.Frame(self.main_content, bg='#3498db', height=80)
        header_frame.pack(fill='x', pady=(0, 20))
        header_frame.pack_propagate(False)

        tk.Label(header_frame, text=f"Job Seeker Dashboard - Welcome, {self.current_user['full_name']}",
                 font=('Arial', 18, 'bold'), bg='#3498db', fg='white').pack(pady=20)

        # Main dashboard content
        dashboard_frame = tk.Frame(self.main_content, bg='white')
        dashboard_frame.pack(fill='both', expand=True)

        # Statistics frame
        stats_frame = tk.Frame(dashboard_frame, bg='white')
        stats_frame.pack(fill='x', padx=20, pady=20)

        # Quick stats
        try:
            conn = self.db_manager.create_connection()
            cursor = conn.cursor()

            # Count total applications
            cursor.execute("SELECT COUNT(*) FROM job_applications WHERE applicant_id = ?", (self.current_user['id'],))
            total_apps = cursor.fetchone()[0]

            # Count pending applications
            cursor.execute("SELECT COUNT(*) FROM job_applications WHERE applicant_id = ? AND status = 'Submitted'", (self.current_user['id'],))
            pending_apps = cursor.fetchone()[0]

            # Count accepted applications
            cursor.execute("SELECT COUNT(*) FROM job_applications WHERE applicant_id = ? AND status = 'Accepted'", (self.current_user['id'],))
            accepted_apps = cursor.fetchone()[0]

            # Count open jobs
            cursor.execute("SELECT COUNT(*) FROM jobs WHERE status = 'Open'")
            open_jobs = cursor.fetchone()[0]

            conn.close()
        except Exception:
            total_apps = pending_apps = accepted_apps = open_jobs = 0

        # Stats boxes
        stat_boxes = [
            ("Total Applications", total_apps, "#3498db"),
            ("Pending Applications", pending_apps, "#f39c12"),
            ("Accepted Applications", accepted_apps, "#27ae60"),
            ("Available Jobs", open_jobs, "#8e44ad")
        ]

        for i, (label, value, color) in enumerate(stat_boxes):
            stat_box = tk.Frame(stats_frame, bg=color, width=180, height=100)
            stat_box.pack(side='left', padx=10, pady=10)
            stat_box.pack_propagate(False)

            tk.Label(stat_box, text=str(value), font=('Arial', 28, 'bold'),
                    bg=color, fg='white').pack(pady=(15, 5))
            tk.Label(stat_box, text=label, font=('Arial', 10),
                    bg=color, fg='white').pack()

        # Quick actions frame
        actions_frame = tk.Frame(dashboard_frame, bg='white')
        actions_frame.pack(fill='x', padx=20, pady=20)

        tk.Label(actions_frame, text="Quick Actions", font=('Arial', 16, 'bold'),
                bg='white').pack(anchor='w', pady=(0, 15))

        # Action buttons in a grid
        buttons_frame = tk.Frame(actions_frame, bg='white')
        buttons_frame.pack(fill='x')

        action_buttons = [
            ("Edit Profile", getattr(self, 'show_edit_profile', lambda: messagebox.showinfo("Profile", "Edit Profile is currently unavailable.")), "#34495e"),
            ("Upload Resume", getattr(self, 'show_upload_resume', lambda: messagebox.showinfo("Resume", "Upload Resume feature will be implemented here.")), "#27ae60"),
            ("Search Jobs", getattr(self, 'show_search_jobs', lambda: messagebox.showinfo("Jobs", "Search Jobs feature will be implemented here.")), "#3498db"),
            ("My Applications", getattr(self, 'show_my_applications', lambda: messagebox.showinfo("Applications", "My Applications feature will be implemented here.")), "#e67e22")
        ]

        for i, (text, command, color) in enumerate(action_buttons):
            btn = tk.Button(buttons_frame, text=text, font=('Arial', 12),
                          bg=color, fg='white', width=15, height=2,
                          command=command)
            btn.grid(row=i//2, column=i%2, padx=10, pady=10, sticky='ew')

        buttons_frame.columnconfigure(0, weight=1)
        buttons_frame.columnconfigure(1, weight=1)

        # Recent activity frame
        activity_frame = tk.Frame(dashboard_frame, bg='white')
        activity_frame.pack(fill='both', expand=True, padx=20, pady=20)

        tk.Label(activity_frame, text="Recent Activity", font=('Arial', 16, 'bold'),
                bg='white').pack(anchor='w', pady=(0, 15))

        # Activity list
        activity_tree_frame = tk.Frame(activity_frame, bg='white')
        activity_tree_frame.pack(fill='both', expand=True)

        columns = ("Date", "Activity", "Details", "Status")
        activity_tree = ttk.Treeview(activity_tree_frame, columns=columns, show='headings', height=8)

        for col in columns:
            activity_tree.heading(col, text=col)
            if col == "Date":
                activity_tree.column(col, width=100)
            elif col == "Status":
                activity_tree.column(col, width=100)
            else:
                activity_tree.column(col, width=200)

        # Scrollbar
        scrollbar = ttk.Scrollbar(activity_tree_frame, orient='vertical', command=activity_tree.yview)
        activity_tree.configure(yscrollcommand=scrollbar.set)

        activity_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')

        # Load recent activity
        try:
            conn = self.db_manager.create_connection()
            cursor = conn.cursor()
            cursor.execute('''
                SELECT ja.application_date, j.title, j.location, ja.status
                FROM job_applications ja
                JOIN jobs j ON ja.job_id = j.id
                WHERE ja.applicant_id = ?
                ORDER BY ja.application_date DESC
                LIMIT 10
            ''', (self.current_user['id'],))

            activities = cursor.fetchall()
            conn.close()

            for activity in activities:
                date_str = activity[0] if activity[0] else "Unknown"
                activity_tree.insert('', 'end', values=(
                    date_str,
                    f"Applied for {activity[1]}",
                    f"Location: {activity[2] or 'Not specified'}",
                    activity[3]
                ))

            if not activities:
                activity_tree.insert('', 'end', values=(
                    "No activity yet",
                    "Start by searching for jobs",
                    "Use the Search Jobs button above",
                    ""
                ))

        except Exception as e:
            activity_tree.insert('', 'end', values=(
                "Error",
                f"Could not load activity: {str(e)}",
                "",
                ""
            ))

    def show_employer_dashboard(self):
        # Employer dashboard
        for widget in self.main_content.winfo_children():
            widget.destroy()

        title = tk.Label(self.main_content, text="Employer Dashboard",
                         font=('Arial', 18, 'bold'), bg='white')
        title.pack(pady=20)

        # My job postings
        jobs_frame = tk.LabelFrame(self.main_content, text="My Job Postings",
                                   font=('Arial', 12, 'bold'), bg='white')
        jobs_frame.pack(fill='both', expand=True, padx=20, pady=20)

        jobs_tree = ttk.Treeview(jobs_frame,
                                 columns=('Title', 'Applications', 'Status', 'Posted'),
                                 show='headings')
        jobs_tree.pack(fill='both', expand=True, padx=10, pady=10)

        jobs_tree.heading('Title', text='Job Title')
        jobs_tree.heading('Applications', text='Applications')
        jobs_tree.heading('Status', text='Status')
        jobs_tree.heading('Posted', text='Posted Date')

        # Load my jobs
        conn = self.db_manager.create_connection()
        cursor = conn.cursor()
        cursor.execute('''
                       SELECT j.title,
                              (SELECT COUNT(*) FROM job_applications ja WHERE ja.job_id = j.id) as applications,
                              j.status,
                              j.posted_date
                       FROM jobs j
                       WHERE j.employer_id = ?
                       ORDER BY j.posted_date DESC
                       ''', (self.current_user['id'],))

        for row in cursor.fetchall():
            jobs_tree.insert('', 'end', values=row)

        conn.close()

    #============= UI Methods (placeholder implementations)======================
    def show_create_user(self, default_role: Optional[str] = None):
        """Open the Create User form.

        Args:
            default_role: Optional role to preselect in the role dropdown. If not in
                the allowed roles for the current user, it will be ignored.
        """
        # Create user window
        create_user_window = tk.Toplevel(self.root)
        create_user_window.title("Create New User")
        create_user_window.geometry("600x700")
        create_user_window.configure(bg='#34495e')
        create_user_window.grab_set()  # Make modal
        create_user_window.resizable(False, False)

        # Center the window
        create_user_window.transient(self.root)

        # Main container
        main_frame = tk.Frame(create_user_window, bg='#34495e', padx=30, pady=20)
        main_frame.pack(fill='both', expand=True)

        # Title
        title_label = tk.Label(main_frame, text="Create New User Account",
                               font=('Arial', 18, 'bold'), bg='#34495e', fg='white')
        title_label.pack(pady=(0, 30))

        # Form frame with scrollbar support
        canvas = tk.Canvas(main_frame, bg='#34495e', highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#34495e')

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Form fields dictionary to store all entries
        form_entries = {}

        # Basic Information Section
        basic_section = tk.LabelFrame(scrollable_frame, text="Basic Information",
                                      font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        basic_section.pack(fill='x', pady=(0, 20), padx=5)

        basic_fields = [
            ("Full Name *", "full_name", "text"),
            ("Username *", "username", "text"),
            ("Email *", "email", "text"),
            ("Phone Number", "phone", "text"),
            ("Address", "address", "text")
        ]

        for label_text, field_name, field_type in basic_fields:
            field_frame = tk.Frame(basic_section, bg='#34495e')
            field_frame.pack(fill='x', padx=10, pady=8)

            tk.Label(field_frame, text=label_text, font=('Arial', 11),
                     bg='#34495e', fg='white', width=15, anchor='w').pack(side='left')

            if field_type == "text":
                entry = tk.Entry(field_frame, font=('Arial', 11), width=35)
                entry.pack(side='left', padx=(10, 0))
                form_entries[field_name] = entry

        # Security Section
        security_section = tk.LabelFrame(scrollable_frame, text="Security Settings",
                                         font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        security_section.pack(fill='x', pady=(0, 20), padx=5)

        # Password fields
        password_frame = tk.Frame(security_section, bg='#34495e')
        password_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(password_frame, text="Password *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=15, anchor='w').pack(side='left')
        password_entry = tk.Entry(password_frame, show="*", font=('Arial', 11), width=35)
        password_entry.pack(side='left', padx=(10, 0))
        form_entries['password'] = password_entry

        confirm_password_frame = tk.Frame(security_section, bg='#34495e')
        confirm_password_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(confirm_password_frame, text="Confirm Password *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=15, anchor='w').pack(side='left')
        confirm_password_entry = tk.Entry(confirm_password_frame, show="*", font=('Arial', 11), width=35)
        confirm_password_entry.pack(side='left', padx=(10, 0))
        form_entries['confirm_password'] = confirm_password_entry

        # Role selection
        role_frame = tk.Frame(security_section, bg='#34495e')
        role_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(role_frame, text="User Role *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=15, anchor='w').pack(side='left')

        role_var = tk.StringVar(master=create_user_window)
        role_combo = ttk.Combobox(role_frame, textvariable=role_var, font=('Arial', 11),
                                  width=32, state='readonly')
        # Limit selectable roles based on current user's role
        try:
            _my_role = self.current_user.get('role') if getattr(self, 'current_user', None) else None
        except Exception:
            _my_role = None
        allowed_roles = ['administrator', 'retail_store', 'contract_owner', 'contractor', 'manager', 'job_seeker', 'employer']
        if _my_role == 'contract_owner':
            allowed_roles = ['contractor', 'manager']
        elif _my_role == 'retail_store':
            allowed_roles = ['manager']
        role_combo['values'] = allowed_roles
        # Preselect default_role if provided and allowed; otherwise first allowed
        try:
            if default_role and default_role in allowed_roles:
                role_var.set(default_role)
            elif allowed_roles:
                role_var.set(allowed_roles[0])
        except Exception:
            if allowed_roles:
                role_var.set(allowed_roles[0])
        role_combo.pack(side='left', padx=(10, 0))
        form_entries['role'] = role_combo

        # Account Status Section
        status_section = tk.LabelFrame(scrollable_frame, text="Account Status",
                                       font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        status_section.pack(fill='x', pady=(0, 20), padx=5)

        # Active status
        active_frame = tk.Frame(status_section, bg='#34495e')
        active_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(active_frame, text="Account Active", font=('Arial', 11),
                 bg='#34495e', fg='white', width=15, anchor='w').pack(side='left')

        active_var = tk.BooleanVar(value=True)
        active_check = tk.Checkbutton(active_frame, variable=active_var, bg='#34495e',
                                      activebackground='#34495e', selectcolor='#2c3e50')
        active_check.pack(side='left', padx=(10, 0))
        form_entries['is_active'] = active_var

        # First login password change
        first_login_frame = tk.Frame(status_section, bg='#34495e')
        first_login_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(first_login_frame, text="Require Password Change", font=('Arial', 11),
                 bg='#34495e', fg='white', width=15, anchor='w').pack(side='left')

        first_login_var = tk.BooleanVar(value=True)
        first_login_check = tk.Checkbutton(first_login_frame, variable=first_login_var,
                                           bg='#34495e', activebackground='#34495e',
                                           selectcolor='#2c3e50')
        first_login_check.pack(side='left', padx=(10, 0))
        form_entries['first_login'] = first_login_var

        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Validation functions
        def validate_email(email):
            import re
            pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            return re.match(pattern, email) is not None

        def validate_phone(phone):
            if not phone:  # Phone is optional
                return True
            # Cameroon phone number pattern (basic validation)
            import re
            pattern = r'^(\+237|237)?[6-9]\d{8}$'
            return re.match(pattern, phone.replace(' ', '').replace('-', '')) is not None

        def validate_password(password):
            if len(password) < 6:
                return False, "Password must be at least 6 characters long"
            if not any(c.isupper() for c in password):
                return False, "Password must contain at least one uppercase letter"
            if not any(c.islower() for c in password):
                return False, "Password must contain at least one lowercase letter"
            if not any(c.isdigit() for c in password):
                return False, "Password must contain at least one number"
            return True, "Password is valid"

        # Create user function
        def create_new_user():
            try:
                # Get all form data
                form_data = {}
                for field_name, widget in form_entries.items():
                    if isinstance(widget, tk.BooleanVar):
                        form_data[field_name] = widget.get()
                    elif hasattr(widget, 'get'):
                        form_data[field_name] = widget.get().strip()
                    else:
                        form_data[field_name] = ""

                # Validation
                errors = []

                # Required fields validation
                required_fields = ['full_name', 'username', 'email', 'password', 'role']
                for field in required_fields:
                    if not form_data.get(field):
                        field_display = field.replace('_', ' ').title()
                        errors.append(f"{field_display} is required")

                # Password confirmation
                if form_data.get('password') != form_data.get('confirm_password'):
                    errors.append("Passwords do not match")

                # Email validation
                if form_data.get('email') and not validate_email(form_data['email']):
                    errors.append("Please enter a valid email address")

                # Phone validation
                if form_data.get('phone') and not validate_phone(form_data['phone']):
                    errors.append("Please enter a valid Cameroon phone number (+237XXXXXXXXX)")

                # Password strength validation
                if form_data.get('password'):
                    is_valid, message = validate_password(form_data['password'])
                    if not is_valid:
                        errors.append(message)

                # Show validation errors
                if errors:
                    error_message = "Please fix the following errors:\n\n" + "\n".join(f"• {error}" for error in errors)
                    messagebox.showerror("Validation Error", error_message)
                    return

                # Database operations
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Check if username or email already exists
                cursor.execute('SELECT username, email FROM users WHERE username = ? OR email = ?',
                               (form_data['username'], form_data['email']))
                existing_user = cursor.fetchone()

                if existing_user:
                    if existing_user[0] == form_data['username']:
                        messagebox.showerror("Error", "Username already exists!")
                    else:
                        messagebox.showerror("Error", "Email already exists!")
                    conn.close()
                    return

                # Hash password
                password_hash = self.security_manager.hash_password(form_data['password'])

                # Determine activation policy based on creator role
                creator_role = (self.current_user.get('role') if getattr(self, 'current_user', None) else None) or ''
                restricted_creator = creator_role in ('contract_owner', 'retail_store', 'contractor')
                # If creator is restricted, force new account inactive pending admin activation
                is_active_value = False if restricted_creator else bool(form_data['is_active'])

                # Insert new user
                cursor.execute('''
                               INSERT INTO users (username, email, password_hash, role, full_name, phone, address,
                                                  created_date, is_active, first_login, failed_login_attempts, created_by)
                               VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                               ''', (
                                   form_data['username'],
                                   form_data['email'],
                                   password_hash,
                                   form_data['role'],
                                   form_data['full_name'],
                                   form_data['phone'] or None,
                                   form_data['address'] or None,
                                   date.today(),
                                   1 if is_active_value else 0,
                                   form_data['first_login'],
                                   0,
                                   (self.current_user['id'] if getattr(self, 'current_user', None) else None)
                               ))

                # Get the created user ID
                user_id = cursor.lastrowid

                conn.commit()
                conn.close()

                # Log the action
                self.log_audit_action(
                    self.current_user['id'],
                    "Create User",
                    f"Created new user: {form_data['username']} with role {form_data['role']}"
                )

                # Show success message
                success_message = (
                    f"User created successfully!\n\n"
                    f"Username: {form_data['username']}\n"
                    f"Email: {form_data['email']}\n"
                    f"Role: {form_data['role'].replace('_', ' ').title()}\n"
                    f"Account Status: {'Active' if is_active_value else 'Inactive'}"
                )

                # If creator is restricted, instruct to contact admin for activation
                if restricted_creator:
                    success_message += ("\n\nActivation required. Please contact the Admin via WhatsApp: +237683786186 "
                                        "to activate this account.")

                messagebox.showinfo("Success", success_message)

                # Close the window
                create_user_window.destroy()

                # Refresh any user management views if they exist
                try:
                    self.refresh_user_management()
                except AttributeError:
                    pass  # Method doesn't exist yet

            except Exception as e:
                messagebox.showerror("Error", f"Failed to create user: {str(e)}")

        # Clear form function
        def clear_form():
            for field_name, widget in form_entries.items():
                if isinstance(widget, tk.BooleanVar):
                    if field_name == 'is_active' or field_name == 'first_login':
                        widget.set(True)
                    else:
                        widget.set(False)
                elif hasattr(widget, 'delete'):
                    widget.delete(0, 'end')
                elif hasattr(widget, 'set'):
                    widget.set('')

        # Button frame
        button_frame = tk.Frame(main_frame, bg='#34495e')
        button_frame.pack(fill='x', pady=(20, 0))

        # Buttons
        tk.Button(button_frame, text="Create User", font=('Arial', 12, 'bold'),
                  bg='#27ae60', fg='white', width=15, height=2,
                  command=create_new_user).pack(side='left', padx=(0, 10))

        tk.Button(button_frame, text="Clear Form", font=('Arial', 12),
                  bg='#f39c12', fg='white', width=15, height=2,
                  command=clear_form).pack(side='left', padx=(0, 10))

        tk.Button(button_frame, text="Cancel", font=('Arial', 12),
                  bg='#e74c3c', fg='white', width=15, height=2,
                  command=create_user_window.destroy).pack(side='right')

        # Keyboard shortcuts
        def on_enter(event):
            if event.widget == confirm_password_entry:
                create_new_user()
            else:
                # Move to next field
                event.widget.tk_focusNext().focus()

        def on_escape(event):
            create_user_window.destroy()

        # Bind keyboard events
        create_user_window.bind('<Escape>', on_escape)

        for widget in form_entries.values():
            if hasattr(widget, 'bind'):
                widget.bind('<Return>', on_enter)

        # Set focus to first field
        form_entries['full_name'].focus()

        # Add helpful tooltips/hints
        help_frame = tk.Frame(main_frame, bg='#34495e')
        help_frame.pack(fill='x', pady=(10, 0))

        help_text = (
            "Tips:\n"
            "• Required fields are marked with *\n"
            "• Passwords must contain uppercase, lowercase, and numbers\n"
            "• Phone numbers should be in Cameroon format (+237XXXXXXXXX)\n"
            "• Users with 'Require Password Change' will be prompted on first login"
        )

        tk.Label(help_frame, text=help_text, font=('Arial', 9),
                 bg='#34495e', fg='#bdc3c7', justify='left').pack(anchor='w')

    # =================== User management window admin dashboard===========================
    def show_manage_users(self):

        manage_window = tk.Toplevel(self.root)
        manage_window.title("Manage Users")
        manage_window.geometry("1200x700")
        manage_window.configure(bg='white')
        manage_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(manage_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="User Management", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Search and filter frame
        search_frame = tk.Frame(header_frame, bg='white')
        search_frame.pack(side='right')

        # Search entry
        tk.Label(search_frame, text="Search:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        search_var = tk.StringVar()
        search_entry = tk.Entry(search_frame, textvariable=search_var, font=('Arial', 10), width=20)
        search_entry.pack(side='left', padx=(0, 10))

        # Role filter
        tk.Label(search_frame, text="Filter by Role:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        role_filter_var = tk.StringVar()
        role_filter = ttk.Combobox(search_frame, textvariable=role_filter_var, width=15, state='readonly')
        role_filter['values'] = ['All', 'administrator', 'retail_store', 'contract_owner',
                                 'contractor', 'manager', 'job_seeker', 'employer']
        role_filter.set('All')
        role_filter.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(search_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left')

        # Users treeview frame
        tree_frame = tk.Frame(main_frame, bg='white')
        tree_frame.pack(fill='both', expand=True, pady=(0, 20))

        # Treeview with scrollbars
        tree_scroll_y = ttk.Scrollbar(tree_frame)
        tree_scroll_y.pack(side='right', fill='y')

        tree_scroll_x = ttk.Scrollbar(tree_frame, orient='horizontal')
        tree_scroll_x.pack(side='bottom', fill='x')

        users_tree = ttk.Treeview(tree_frame,
                                  columns=('ID', 'Username', 'Full Name', 'Email', 'Role', 'Status', 'Last Login',
                                           'Created'),
                                  show='headings',
                                  yscrollcommand=tree_scroll_y.set,
                                  xscrollcommand=tree_scroll_x.set)
        users_tree.pack(fill='both', expand=True)

        tree_scroll_y.config(command=users_tree.yview)
        tree_scroll_x.config(command=users_tree.xview)

        # Configure columns
        columns_config = [
            ('ID', 50, 'center'),
            ('Username', 120, 'w'),
            ('Full Name', 150, 'w'),
            ('Email', 180, 'w'),
            ('Role', 120, 'center'),
            ('Status', 80, 'center'),
            ('Last Login', 130, 'center'),
            ('Created', 100, 'center')
        ]

        for col, width, anchor in columns_config:
            users_tree.heading(col, text=col)
            users_tree.column(col, width=width, anchor=anchor)

        # Action buttons frame
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(0, 10))

        # Left side buttons (user actions)
        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')

        edit_btn = tk.Button(left_buttons, text="Edit User", font=('Arial', 10, 'bold'),
                             bg='#f39c12', fg='white', width=12)
        edit_btn.pack(side='left', padx=(0, 5))

        activate_btn = tk.Button(left_buttons, text="Activate", font=('Arial', 10, 'bold'),
                                 bg='#27ae60', fg='white', width=10)
        activate_btn.pack(side='left', padx=(0, 5))

        deactivate_btn = tk.Button(left_buttons, text="Deactivate", font=('Arial', 10, 'bold'),
                                   bg='#e67e22', fg='white', width=10)
        deactivate_btn.pack(side='left', padx=(0, 5))

        reset_pwd_btn = tk.Button(left_buttons, text="Reset Password", font=('Arial', 10, 'bold'),
                                  bg='#9b59b6', fg='white', width=12)
        reset_pwd_btn.pack(side='left', padx=(0, 5))

        delete_btn = tk.Button(left_buttons, text="Delete User", font=('Arial', 10, 'bold'),
                               bg='#e74c3c', fg='white', width=12)
        delete_btn.pack(side='left', padx=(0, 5))

        # Right side buttons (window actions)
        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')

        export_btn = tk.Button(right_buttons, text="Export CSV", font=('Arial', 10),
                               bg='#34495e', fg='white', width=10)
        export_btn.pack(side='left', padx=(0, 5))

        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10),
                              bg='#95a5a6', fg='white', width=10,
                              command=manage_window.destroy)
        close_btn.pack(side='left')

        # Status frame for showing statistics
        status_frame = tk.Frame(main_frame, bg='#ecf0f1', relief='raised', bd=1)
        status_frame.pack(fill='x', pady=(5, 0))

        status_label = tk.Label(status_frame, text="", font=('Arial', 9),
                                bg='#ecf0f1', fg='#2c3e50')
        status_label.pack(pady=5)

        # Load and display users function
        def load_users():
            # Clear existing items
            for item in users_tree.get_children():
                users_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Build query based on filters
                search_text = search_var.get().strip()
                role_filter_text = role_filter_var.get()

                query = '''
                        SELECT id, \
                               username, \
                               full_name, \
                               email, \
                               role,
                               CASE WHEN is_active = 1 THEN 'Active' ELSE 'Inactive' END as status,
                               CASE \
                                   WHEN last_login IS NULL THEN 'Never' \
                                   ELSE strftime('%Y-%m-%d', last_login) END             as last_login,
                               strftime('%Y-%m-%d', created_date)                        as created_date
                        FROM users
                        WHERE 1 = 1 \
                        '''
                params = []

                if search_text:
                    query += ' AND (username LIKE ? OR full_name LIKE ? OR email LIKE ?)'
                    search_pattern = f'%{search_text}%'
                    params.extend([search_pattern, search_pattern, search_pattern])

                if role_filter_text and role_filter_text != 'All':
                    query += ' AND role = ?'
                    params.append(role_filter_text)

                query += ' ORDER BY created_date DESC'

                cursor.execute(query, params)
                users = cursor.fetchall()

                # Insert users into tree
                for user in users:
                    # Format role for display
                    role_display = user[4].replace('_', ' ').title()

                    # Color code based on status
                    tags = []
                    if user[5] == 'Inactive':
                        tags.append('inactive')
                    elif user[4] == 'administrator':
                        tags.append('admin')

                    users_tree.insert('', 'end', values=(
                        user[0], user[1], user[2], user[3], role_display,
                        user[5], user[6], user[7]
                    ), tags=tags)

                # Update status
                total_users = len(users)
                active_users = sum(1 for user in users if user[5] == 'Active')
                inactive_users = total_users - active_users

                status_text = f"Total Users: {total_users} | Active: {active_users} | Inactive: {inactive_users}"
                status_label.config(text=status_text)

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load users: {str(e)}")

        # Configure tree tags for styling
        users_tree.tag_configure('inactive', foreground='#7f8c8d')
        users_tree.tag_configure('admin', foreground='#c0392b', font=('Arial', 10, 'bold'))

        # Edit user function
        def edit_user():
            selected = users_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a user to edit")
                return

            user_id = users_tree.item(selected[0])['values'][0]

            # Create edit window
            edit_window = tk.Toplevel(manage_window)
            edit_window.title("Edit User")
            edit_window.geometry("500x600")
            edit_window.configure(bg='#34495e')
            edit_window.grab_set()
            edit_window.transient(manage_window)

            # Load user data
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT username, email, full_name, phone, address, role, is_active
                               FROM users
                               WHERE id = ?
                               ''', (user_id,))
                user_data = cursor.fetchone()
                conn.close()

                if not user_data:
                    messagebox.showerror("Error", "User not found")
                    edit_window.destroy()
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load user data: {str(e)}")
                edit_window.destroy()
                return

            # Edit form
            form_frame = tk.Frame(edit_window, bg='#34495e', padx=30, pady=30)
            form_frame.pack(fill='both', expand=True)

            tk.Label(form_frame, text=f"Edit User: {user_data[0]}", font=('Arial', 16, 'bold'),
                     bg='#34495e', fg='white').pack(pady=(0, 20))

            # Form fields
            edit_entries = {}
            fields = [
                ("Full Name", "full_name", user_data[2]),
                ("Email", "email", user_data[1]),
                ("Phone", "phone", user_data[3] or ""),
                ("Address", "address", user_data[4] or "")
            ]

            for label_text, field_name, current_value in fields:
                tk.Label(form_frame, text=f"{label_text}:", font=('Arial', 11),
                         bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))

                entry = tk.Entry(form_frame, font=('Arial', 11), width=40)
                entry.insert(0, current_value)
                entry.pack(pady=(0, 10))
                edit_entries[field_name] = entry

            # Role selection
            tk.Label(form_frame, text="Role:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))

            role_var = tk.StringVar(value=user_data[5])
            role_combo = ttk.Combobox(form_frame, textvariable=role_var, width=37, state='readonly')
            role_combo['values'] = ['administrator', 'retail_store', 'contract_owner',
                                    'contractor', 'manager', 'job_seeker', 'employer']
            role_combo.pack(pady=(0, 10))

            # Active status
            tk.Label(form_frame, text="Account Status:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))

            active_var = tk.BooleanVar(value=bool(user_data[6]))
            tk.Checkbutton(form_frame, text="Account Active", variable=active_var,
                           bg='#34495e', fg='white', selectcolor='#2c3e50').pack(anchor='w')

            def save_changes():
                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    cursor.execute('''
                                   UPDATE users
                                   SET full_name = ?,
                                       email     = ?,
                                       phone     = ?,
                                       address   = ?,
                                       role      = ?,
                                       is_active = ?
                                   WHERE id = ?
                                   ''', (
                                       edit_entries['full_name'].get(),
                                       edit_entries['email'].get(),
                                       edit_entries['phone'].get() or None,
                                       edit_entries['address'].get() or None,
                                       role_var.get(),
                                       active_var.get(),
                                       user_id
                                   ))

                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        "Edit User",
                        f"Modified user {user_data[0]} (ID: {user_id})"
                    )

                    messagebox.showinfo("Success", "User updated successfully!")
                    edit_window.destroy()
                    load_users()  # Refresh the list

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to update user: {str(e)}")

            # Buttons
            btn_frame = tk.Frame(form_frame, bg='#34495e')
            btn_frame.pack(pady=(20, 0))

            tk.Button(btn_frame, text="Save Changes", font=('Arial', 11, 'bold'),
                      bg='#27ae60', fg='white', width=15,
                      command=save_changes).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Cancel", font=('Arial', 11),
                      bg='#e74c3c', fg='white', width=15,
                      command=edit_window.destroy).pack(side='left')

        # Activate/Deactivate user functions
        def toggle_user_status(activate=True):
            selected = users_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a user")
                return

            user_id = users_tree.item(selected[0])['values'][0]
            username = users_tree.item(selected[0])['values'][1]

            action = "activate" if activate else "deactivate"

            if messagebox.askyesno("Confirm", f"Are you sure you want to {action} user '{username}'?"):
                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    cursor.execute('UPDATE users SET is_active = ? WHERE id = ?', (activate, user_id))
                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        f"{'Activate' if activate else 'Deactivate'} User",
                        f"{'Activated' if activate else 'Deactivated'} user {username}"
                    )

                    messagebox.showinfo("Success",
                                        f"User {username} has been {'activated' if activate else 'deactivated'}")
                    load_users()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to {action} user: {str(e)}")

        # Reset password function
        def reset_password():
            selected = users_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a user")
                return

            user_id = users_tree.item(selected[0])['values'][0]
            username = users_tree.item(selected[0])['values'][1]

            if messagebox.askyesno("Confirm",
                                   f"Reset password for user '{username}'?\nA temporary password will be generated."):
                try:
                    import random
                    import string

                    # Generate temporary password
                    temp_password = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
                    temp_password_hash = self.security_manager.hash_password(temp_password)

                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    cursor.execute('''
                                   UPDATE users
                                   SET password_hash         = ?,
                                       first_login           = 1,
                                       failed_login_attempts = 0
                                   WHERE id = ?
                                   ''', (temp_password_hash, user_id))

                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        "Reset Password",
                        f"Reset password for user {username}"
                    )

                    messagebox.showinfo("Password Reset",
                                        f"Password reset successfully!\n\n"
                                        f"Username: {username}\n"
                                        f"Temporary Password: {temp_password}\n\n"
                                        f"User will be required to change password on next login.")

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to reset password: {str(e)}")

        # Delete user function
        def delete_user():
            selected = users_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a user to delete")
                return

            user_id = users_tree.item(selected[0])['values'][0]
            username = users_tree.item(selected[0])['values'][1]

            # Prevent deleting current user
            if user_id == self.current_user['id']:
                messagebox.showerror("Error", "You cannot delete your own account!")
                return

            if messagebox.askyesno("Confirm",
                                   f"Deactivate (soft delete) user '{username}'?\n\n"
                                   f"This will deactivate the account and anonymize credentials to free the username/email."):
                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    # Optional dependency check (informational only)
                    cursor.execute('SELECT COUNT(*) FROM stores WHERE owner_id = ? OR manager_id = ?', (user_id, user_id))
                    store_count = cursor.fetchone()[0]
                    cursor.execute('SELECT COUNT(*) FROM contracts WHERE contract_owner_id = ? OR contractor_id = ?', (user_id, user_id))
                    contract_count = cursor.fetchone()[0]

                    # Soft delete: deactivate and anonymize to avoid foreign key failures and free UNIQUE fields
                    # Fetch current username/email for audit
                    cursor.execute('SELECT username, email FROM users WHERE id = ?', (user_id,))
                    row = cursor.fetchone()
                    old_username = row[0] if row else username
                    old_email = row[1] if row and len(row) > 1 else ''

                    # Append timestamp suffix to make unique values
                    cursor.execute("SELECT strftime('%Y%m%d%H%M%S','now')")
                    ts = cursor.fetchone()[0]
                    new_username = old_username + '.deleted.' + ts
                    new_email = (old_email or old_username + '@local.invalid') + '.deleted.' + ts

                    cursor.execute(
                        '''UPDATE users
                           SET is_active = 0,
                               username = ?,
                               email = ?
                           WHERE id = ?''',
                        (new_username, new_email, user_id)
                    )

                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        "Soft Delete User",
                        json.dumps({
                            "user_id": user_id,
                            "old_username": old_username,
                            "old_email": old_email,
                            "stores": store_count,
                            "contracts": contract_count
                        })
                    )

                    messagebox.showinfo("Deactivated",
                                        f"User '{username}' has been deactivated and credentials anonymized.\n"
                                        f"Note: {store_count} stores, {contract_count} contracts remain linked to this user ID (historical records).")
                    load_users()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to deactivate user: {str(e)}")

        # Export to CSV function
        def export_csv():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".csv",
                    filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                    title="Save Users Export"
                )

                if filename:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('''
                                   SELECT username,
                                          full_name,
                                          email,
                                          phone,
                                          role,
                                          CASE WHEN is_active = 1 THEN 'Active' ELSE 'Inactive' END,
                                          created_date,
                                          last_login
                                   FROM users
                                   ORDER BY created_date DESC
                                   ''')

                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerow(
                            ['Username', 'Full Name', 'Email', 'Phone', 'Role', 'Status', 'Created', 'Last Login'])
                        writer.writerows(cursor.fetchall())

                    conn.close()
                    messagebox.showinfo("Success", f"Users exported to {filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to export users: {str(e)}")

        # Bind button commands
        edit_btn.config(command=edit_user)
        activate_btn.config(command=lambda: toggle_user_status(True))
        deactivate_btn.config(command=lambda: toggle_user_status(False))
        reset_pwd_btn.config(command=reset_password)
        delete_btn.config(command=delete_user)
        export_btn.config(command=export_csv)
        refresh_btn.config(command=load_users)

        # Bind search and filter events
        def on_filter_change(*args):
            load_users()

        search_var.trace('w', on_filter_change)
        role_filter_var.trace('w', on_filter_change)

        # Double-click to edit
        users_tree.bind('<Double-1>', lambda e: edit_user())

        # Initial load
        load_users()

        # Keyboard shortcuts
        manage_window.bind('<F5>', lambda e: load_users())
        manage_window.bind('<Escape>', lambda e: manage_window.destroy())


#========= all user activities. admin dashboard ================
    def show_user_activity(self):
        # User Activity monitoring window
        activity_window = tk.Toplevel(self.root)
        activity_window.title("User Activity Monitor")
        activity_window.geometry("1200x700")
        activity_window.configure(bg='white')
        activity_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(activity_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="User Activity Monitor", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Filter controls frame
        filter_frame = tk.Frame(header_frame, bg='white')
        filter_frame.pack(side='right')

        # User filter
        tk.Label(filter_frame, text="User:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        user_filter_var = tk.StringVar()
        user_filter = ttk.Combobox(filter_frame, textvariable=user_filter_var, width=15, state='readonly')
        user_filter.pack(side='left', padx=(0, 10))

        # Action filter
        tk.Label(filter_frame, text="Action:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        action_filter_var = tk.StringVar()
        action_filter = ttk.Combobox(filter_frame, textvariable=action_filter_var, width=15, state='readonly')
        action_filter.pack(side='left', padx=(0, 10))

        # Date range filter
        tk.Label(filter_frame, text="Date Range:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        date_filter_var = tk.StringVar()
        date_filter = ttk.Combobox(filter_frame, textvariable=date_filter_var, width=12, state='readonly')
        date_filter['values'] = ['All Time', 'Today', 'Last 7 Days', 'Last 30 Days', 'This Month']
        date_filter.set('Last 7 Days')
        date_filter.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(filter_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left', padx=(0, 5))

        # Export button
        export_btn = tk.Button(filter_frame, text="Export", font=('Arial', 10),
                               bg='#27ae60', fg='white', width=8)
        export_btn.pack(side='left')

        # Statistics frame
        stats_frame = tk.Frame(main_frame, bg='#ecf0f1', relief='raised', bd=1)
        stats_frame.pack(fill='x', pady=(0, 10))

        stats_inner = tk.Frame(stats_frame, bg='#ecf0f1')
        stats_inner.pack(pady=10)

        # Statistics labels
        total_activities_label = tk.Label(stats_inner, text="Total Activities: 0", font=('Arial', 10, 'bold'),
                                          bg='#ecf0f1', fg='#2c3e50')
        total_activities_label.pack(side='left', padx=20)

        active_users_label = tk.Label(stats_inner, text="Active Users: 0", font=('Arial', 10, 'bold'),
                                      bg='#ecf0f1', fg='#2c3e50')
        active_users_label.pack(side='left', padx=20)

        most_active_label = tk.Label(stats_inner, text="Most Active: N/A", font=('Arial', 10, 'bold'),
                                     bg='#ecf0f1', fg='#2c3e50')
        most_active_label.pack(side='left', padx=20)

        # Activity log frame with scrollbars
        log_frame = tk.Frame(main_frame, bg='white')
        log_frame.pack(fill='both', expand=True, pady=(0, 10))

        # Treeview with scrollbars
        tree_scroll_y = ttk.Scrollbar(log_frame)
        tree_scroll_y.pack(side='right', fill='y')

        tree_scroll_x = ttk.Scrollbar(log_frame, orient='horizontal')
        tree_scroll_x.pack(side='bottom', fill='x')

        activity_tree = ttk.Treeview(log_frame,
                                     columns=('ID', 'Timestamp', 'User', 'Role', 'Action', 'Details', 'IP Address'),
                                     show='headings',
                                     yscrollcommand=tree_scroll_y.set,
                                     xscrollcommand=tree_scroll_x.set)
        activity_tree.pack(fill='both', expand=True)

        tree_scroll_y.config(command=activity_tree.yview)
        tree_scroll_x.config(command=activity_tree.xview)

        # Configure columns
        columns_config = [
            ('ID', 60, 'center'),
            ('Timestamp', 140, 'center'),
            ('User', 120, 'w'),
            ('Role', 100, 'center'),
            ('Action', 120, 'center'),
            ('Details', 300, 'w'),
            ('IP Address', 120, 'center')
        ]

        for col, width, anchor in columns_config:
            activity_tree.heading(col, text=col)
            activity_tree.column(col, width=width, anchor=anchor)

        # Configure row colors
        activity_tree.tag_configure('login', background='#d5f4e6')
        activity_tree.tag_configure('logout', background='#ffeaa7')
        activity_tree.tag_configure('create', background='#e8f4fd')
        activity_tree.tag_configure('edit', background='#fff2e6')
        activity_tree.tag_configure('delete', background='#ffebee')
        activity_tree.tag_configure('error', background='#ffcdd2')

        # Bottom buttons frame
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x')

        # Left side buttons
        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')

        details_btn = tk.Button(left_buttons, text="View Details", font=('Arial', 10),
                                bg='#3498db', fg='white', width=12)
        details_btn.pack(side='left', padx=(0, 5))

        clear_log_btn = tk.Button(left_buttons, text="Clear Old Logs", font=('Arial', 10),
                                  bg='#e74c3c', fg='white', width=12)
        clear_log_btn.pack(side='left', padx=(0, 5))

        # Right side buttons
        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')

        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10),
                              bg='#95a5a6', fg='white', width=10,
                              command=activity_window.destroy)
        close_btn.pack()

        # Load filters function
        def load_filters():
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Load users for filter
                cursor.execute(
                    'SELECT DISTINCT u.username FROM users u JOIN audit_log a ON u.id = a.user_id ORDER BY u.username')
                users = ['All Users'] + [row[0] for row in cursor.fetchall()]
                user_filter['values'] = users
                user_filter.set('All Users')

                # Load actions for filter
                cursor.execute('SELECT DISTINCT action FROM audit_log ORDER BY action')
                actions = ['All Actions'] + [row[0] for row in cursor.fetchall()]
                action_filter['values'] = actions
                action_filter.set('All Actions')

                conn.close()
            except Exception as e:
                print(f"Error loading filters: {e}")

        # Load activities function
        def load_activities():
            # Clear existing items
            for item in activity_tree.get_children():
                activity_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Build query based on filters
                user_filter_text = user_filter_var.get()
                action_filter_text = action_filter_var.get()
                date_filter_text = date_filter_var.get()

                query = '''
                        SELECT a.id,
                               datetime(a.timestamp, 'localtime') as timestamp,
                               COALESCE(u.username, 'System')     as username,
                               COALESCE(u.role, 'System')         as role,
                               a.action,
                               a.details,
                               COALESCE(a.ip_address, 'N/A')      as ip_address
                        FROM audit_log a
                                 LEFT JOIN users u ON a.user_id = u.id
                        WHERE 1 = 1
                        '''
                params = []

                # Apply user filter
                if user_filter_text and user_filter_text != 'All Users':
                    query += ' AND u.username = ?'
                    params.append(user_filter_text)

                # Apply action filter
                if action_filter_text and action_filter_text != 'All Actions':
                    query += ' AND a.action = ?'
                    params.append(action_filter_text)

                # Apply date filter
                if date_filter_text == 'Today':
                    query += ' AND DATE(a.timestamp) = DATE("now", "localtime")'
                elif date_filter_text == 'Last 7 Days':
                    query += ' AND a.timestamp >= datetime("now", "localtime", "-7 days")'
                elif date_filter_text == 'Last 30 Days':
                    query += ' AND a.timestamp >= datetime("now", "localtime", "-30 days")'
                elif date_filter_text == 'This Month':
                    query += ' AND strftime("%Y-%m", a.timestamp) = strftime("%Y-%m", "now", "localtime")'

                query += ' ORDER BY a.timestamp DESC LIMIT 1000'

                cursor.execute(query, params)
                activities = cursor.fetchall()

                # Insert activities into tree
                for activity in activities:
                    activity_id, timestamp, username, role, action, details, ip_address = activity

                    # Format timestamp
                    try:
                        from datetime import datetime as dt
                        timestamp_obj = dt.strptime(timestamp, '%Y-%m-%d %H:%M:%S')
                        formatted_time = timestamp_obj.strftime('%Y-%m-%d %H:%M')
                    except:
                        formatted_time = timestamp

                    # Format role
                    role_display = role.replace('_', ' ').title() if role != 'System' else 'System'

                    # Determine row color based on action
                    tags = []
                    action_lower = action.lower()
                    if 'login' in action_lower:
                        tags.append('login')
                    elif 'logout' in action_lower:
                        tags.append('logout')
                    elif 'create' in action_lower:
                        tags.append('create')
                    elif 'edit' in action_lower or 'update' in action_lower or 'modify' in action_lower:
                        tags.append('edit')
                    elif 'delete' in action_lower:
                        tags.append('delete')
                    elif 'error' in action_lower or 'fail' in action_lower:
                        tags.append('error')

                    activity_tree.insert('', 'end', values=(
                        activity_id, formatted_time, username, role_display,
                        action, details[:100] + '...' if len(details) > 100 else details, ip_address
                    ), tags=tags)

                # Update statistics
                total_count = len(activities)

                # Get active users count (users with activity in selected period)
                cursor.execute(f'''
                              SELECT COUNT(DISTINCT u.username)
                              FROM audit_log a
                              LEFT JOIN users u ON a.user_id = u.id
                              WHERE 1=1 {' AND ' + query.split('WHERE 1=1')[1].split('ORDER BY')[0] if 'WHERE 1=1' in query else ''}
                              ''', params)
                active_users_count = cursor.fetchone()[0]

                # Get most active user
                cursor.execute(f'''
                              SELECT u.username, COUNT(*) as activity_count
                              FROM audit_log a
                              LEFT JOIN users u ON a.user_id = u.id
                              WHERE 1=1 {' AND ' + query.split('WHERE 1=1')[1].split('ORDER BY')[0] if 'WHERE 1=1' in query else ''}
                              GROUP BY u.username
                              ORDER BY activity_count DESC
                              LIMIT 1
                              ''', params)
                most_active_result = cursor.fetchone()
                most_active = f"{most_active_result[0]} ({most_active_result[1]} activities)" if most_active_result else "N/A"

                # Update statistics labels
                total_activities_label.config(text=f"Total Activities: {total_count}")
                active_users_label.config(text=f"Active Users: {active_users_count}")
                most_active_label.config(text=f"Most Active: {most_active}")

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load activities: {str(e)}")

        # View activity details function
        def view_details():
            selected = activity_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select an activity to view details")
                return

            activity_values = activity_tree.item(selected[0])['values']
            activity_id = activity_values[0]

            # Create details window
            details_window = tk.Toplevel(activity_window)
            details_window.title("Activity Details")
            details_window.geometry("600x500")
            details_window.configure(bg='#34495e')
            details_window.grab_set()
            details_window.transient(activity_window)

            # Load full activity details
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT a.id,
                                      a.timestamp,
                                      u.username,
                                      u.full_name,
                                      u.role,
                                      a.action,
                                      a.details,
                                      a.ip_address
                               FROM audit_log a
                                        LEFT JOIN users u ON a.user_id = u.id
                               WHERE a.id = ?
                               ''', (activity_id,))

                activity_detail = cursor.fetchone()
                conn.close()

                if not activity_detail:
                    messagebox.showerror("Error", "Activity not found")
                    details_window.destroy()
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load activity details: {str(e)}")
                details_window.destroy()
                return

            # Details form
            form_frame = tk.Frame(details_window, bg='#34495e', padx=30, pady=30)
            form_frame.pack(fill='both', expand=True)

            tk.Label(form_frame, text="Activity Details", font=('Arial', 16, 'bold'),
                     bg='#34495e', fg='white').pack(pady=(0, 20))

            # Activity information
            details_info = [
                ("Activity ID:", str(activity_detail[0])),
                ("Timestamp:", str(activity_detail[1])),
                ("Username:", activity_detail[2] or 'System'),
                ("Full Name:", activity_detail[3] or 'N/A'),
                ("User Role:", (activity_detail[4] or 'System').replace('_', ' ').title()),
                ("Action:", activity_detail[5]),
                ("IP Address:", activity_detail[7] or 'N/A')
            ]

            for label_text, value in details_info:
                info_frame = tk.Frame(form_frame, bg='#34495e')
                info_frame.pack(fill='x', pady=5)

                tk.Label(info_frame, text=label_text, font=('Arial', 11, 'bold'),
                         bg='#34495e', fg='white', width=15, anchor='w').pack(side='left')

                tk.Label(info_frame, text=value, font=('Arial', 11),
                         bg='#34495e', fg='#ecf0f1', wraplength=400, justify='left').pack(side='left', padx=(10, 0))

            # Details text area
            tk.Label(form_frame, text="Details:", font=('Arial', 11, 'bold'),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(20, 5))

            details_text = tk.Text(form_frame, height=10, width=60, font=('Arial', 10),
                                   wrap='word', state='normal')
            details_text.pack(fill='both', expand=True, pady=(0, 20))
            details_text.insert('1.0', activity_detail[6])
            details_text.config(state='disabled')

            # Close button
            tk.Button(form_frame, text="Close", font=('Arial', 11),
                      bg='#e74c3c', fg='white', width=15,
                      command=details_window.destroy).pack()

        # Clear old logs function
        def clear_old_logs():
            if messagebox.askyesno("Confirm",
                                   "This will delete audit logs older than 90 days.\n\n"
                                   "Are you sure you want to continue?"):
                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    cursor.execute('''
                                   DELETE
                                   FROM audit_log
                                   WHERE timestamp < datetime('now', '-90 days')
                                   ''')

                    deleted_count = cursor.rowcount
                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        "Clear Audit Logs",
                        f"Cleared {deleted_count} old audit log entries"
                    )

                    messagebox.showinfo("Success", f"Deleted {deleted_count} old log entries")
                    load_activities()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to clear logs: {str(e)}")

        # Export activities function
        def export_activities():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".csv",
                    filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                    title="Export User Activities"
                )

                if filename:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    # Same query as load_activities but without LIMIT
                    user_filter_text = user_filter_var.get()
                    action_filter_text = action_filter_var.get()
                    date_filter_text = date_filter_var.get()

                    query = '''
                            SELECT datetime(a.timestamp, 'localtime') as timestamp,
                                   COALESCE(u.username, 'System')     as username,
                                   COALESCE(u.full_name, 'System')    as full_name,
                                   COALESCE(u.role, 'System')         as role,
                                   a.action,
                                   a.details,
                                   COALESCE(a.ip_address, 'N/A')      as ip_address
                            FROM audit_log a
                                     LEFT JOIN users u ON a.user_id = u.id
                            WHERE 1 = 1
                            '''
                    params = []

                    if user_filter_text and user_filter_text != 'All Users':
                        query += ' AND u.username = ?'
                        params.append(user_filter_text)

                    if action_filter_text and action_filter_text != 'All Actions':
                        query += ' AND a.action = ?'
                        params.append(action_filter_text)

                    if date_filter_text == 'Today':
                        query += ' AND DATE(a.timestamp) = DATE("now", "localtime")'
                    elif date_filter_text == 'Last 7 Days':
                        query += ' AND a.timestamp >= datetime("now", "localtime", "-7 days")'
                    elif date_filter_text == 'Last 30 Days':
                        query += ' AND a.timestamp >= datetime("now", "localtime", "-30 days")'
                    elif date_filter_text == 'This Month':
                        query += ' AND strftime("%Y-%m", a.timestamp) = strftime("%Y-%m", "now", "localtime")'

                    query += ' ORDER BY a.timestamp DESC'

                    cursor.execute(query, params)

                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerow(
                            ['Timestamp', 'Username', 'Full Name', 'Role', 'Action', 'Details', 'IP Address'])
                        writer.writerows(cursor.fetchall())

                    conn.close()
                    messagebox.showinfo("Success", f"Activities exported to {filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to export activities: {str(e)}")

        # Bind button commands
        details_btn.config(command=view_details)
        clear_log_btn.config(command=clear_old_logs)
        export_btn.config(command=export_activities)
        refresh_btn.config(command=load_activities)

        # Bind filter change events
        def on_filter_change(*args):
            load_activities()

        user_filter_var.trace('w', on_filter_change)
        action_filter_var.trace('w', on_filter_change)
        date_filter_var.trace('w', on_filter_change)

        # Double-click to view details
        activity_tree.bind('<Double-1>', lambda e: view_details())

        # Keyboard shortcuts
        activity_window.bind('<F5>', lambda e: load_activities())
        activity_window.bind('<Escape>', lambda e: activity_window.destroy())

        # Auto-refresh every 30 seconds
        def auto_refresh():
            if activity_window.winfo_exists():
                try:
                    load_activities()
                    activity_window.after(30000, auto_refresh)  # 30 seconds
                except:
                    pass

        # Initial load
        load_filters()
        load_activities()

        # Start auto-refresh
        activity_window.after(30000, auto_refresh)

    def show_materials_database(self):
        # Materials database window
        materials_window = tk.Toplevel(self.root)
        materials_window.title("Building Materials Database")
        materials_window.geometry("1000x600")
        materials_window.configure(bg='white')

        # Materials tree
        tree_frame = tk.Frame(materials_window, bg='white')
        tree_frame.pack(fill='both', expand=True, padx=10, pady=10)

        materials_tree = ttk.Treeview(tree_frame,
                                      columns=('Name', 'Category', 'Unit', 'Price', 'Supplier', 'Local Name'),
                                      show='headings')
        materials_tree.pack(fill='both', expand=True)

        # Configure columns
        materials_tree.heading('Name', text='Material Name')
        materials_tree.heading('Category', text='Category')
        materials_tree.heading('Unit', text='Unit')
        materials_tree.heading('Price', text='Price (FCFA)')
        materials_tree.heading('Supplier', text='Supplier')
        materials_tree.heading('Local Name', text='Local Name')

        # Load materials
        conn = self.db_manager.create_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT name, category, unit, standard_price, supplier, local_name FROM building_materials')

        for row in cursor.fetchall():
            materials_tree.insert('', 'end', values=row)

        conn.close()

#=============== all system statistics======================
    def show_system_statistics(self):
        # System Statistics window
        stats_window = tk.Toplevel(self.root)
        stats_window.title("System Statistics Dashboard")
        stats_window.geometry("1400x800")
        stats_window.configure(bg='#f8f9fa')
        stats_window.grab_set()  # Make modal

        # Main container with scrollable canvas
        main_canvas = tk.Canvas(stats_window, bg='#f8f9fa')
        scrollbar = ttk.Scrollbar(stats_window, orient="vertical", command=main_canvas.yview)
        scrollable_frame = tk.Frame(main_canvas, bg='#f8f9fa')

        scrollable_frame.bind(
            "<Configure>",
            lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
        )

        main_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        main_canvas.configure(yscrollcommand=scrollbar.set)

        # Header
        header_frame = tk.Frame(scrollable_frame, bg='#2c3e50', height=80)
        header_frame.pack(fill='x', pady=(0, 20))
        header_frame.pack_propagate(False)

        tk.Label(header_frame, text="System Statistics Dashboard",
                 font=('Arial', 20, 'bold'), bg='#2c3e50', fg='white').pack(expand=True)

        # Refresh button in header
        refresh_btn = tk.Button(header_frame, text="🔄 Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=10)
        refresh_btn.place(relx=0.95, rely=0.5, anchor='center')

        try:
            conn = self.db_manager.create_connection()
            cursor = conn.cursor()

            # === OVERVIEW STATISTICS CARDS ===
            overview_frame = tk.LabelFrame(scrollable_frame, text="System Overview",
                                           font=('Arial', 14, 'bold'), bg='#f8f9fa',
                                           fg='#2c3e50', padx=10, pady=10)
            overview_frame.pack(fill='x', padx=20, pady=(0, 20))

            cards_frame = tk.Frame(overview_frame, bg='#f8f9fa')
            cards_frame.pack(fill='x', pady=10)

            # Get overview statistics
            cursor.execute("SELECT COUNT(*) FROM users")
            total_users = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM users WHERE is_active = 1")
            active_users = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM stores")
            total_stores = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM contracts")
            total_contracts = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM jobs WHERE status = 'Open'")
            active_jobs = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM transactions")
            total_transactions = cursor.fetchone()[0]

            # Create overview cards
            overview_stats = [
                ("Total Users", total_users, "#3498db", "👥"),
                ("Active Users", active_users, "#2ecc71", "✅"),
                ("Stores", total_stores, "#e67e22", "🏪"),
                ("Contracts", total_contracts, "#9b59b6", "📋"),
                ("Active Jobs", active_jobs, "#f39c12", "💼"),
                ("Transactions", total_transactions, "#e74c3c", "💰")
            ]

            for i, (label, value, color, icon) in enumerate(overview_stats):
                card = tk.Frame(cards_frame, bg=color, width=200, height=100, relief='raised', bd=2)
                card.grid(row=i // 3, column=i % 3, padx=10, pady=10, sticky='nsew')
                card.grid_propagate(False)

                tk.Label(card, text=icon, font=('Arial', 20), bg=color, fg='white').pack(pady=(5, 0))
                tk.Label(card, text=str(value), font=('Arial', 18, 'bold'),
                         bg=color, fg='white').pack()
                tk.Label(card, text=label, font=('Arial', 10, 'bold'),
                         bg=color, fg='white').pack(pady=(0, 5))

            # Configure grid weights
            for i in range(3):
                cards_frame.grid_columnconfigure(i, weight=1)

            # === USER STATISTICS ===
            users_frame = tk.LabelFrame(scrollable_frame, text="User Analytics",
                                        font=('Arial', 14, 'bold'), bg='#f8f9fa',
                                        fg='#2c3e50', padx=10, pady=10)
            users_frame.pack(fill='x', padx=20, pady=(0, 20))

            # User role distribution
            cursor.execute('''
                           SELECT role, COUNT(*) as count
                           FROM users
                           GROUP BY role
                           ORDER BY count DESC
                           ''')
            role_data = cursor.fetchall()

            users_left = tk.Frame(users_frame, bg='#f8f9fa')
            users_left.pack(side='left', fill='both', expand=True, padx=(0, 10))

            tk.Label(users_left, text="Users by Role", font=('Arial', 12, 'bold'),
                     bg='#f8f9fa').pack(anchor='w')

            role_tree = ttk.Treeview(users_left, columns=('Role', 'Count', 'Percentage'),
                                     show='headings', height=8)
            role_tree.pack(fill='both', expand=True, pady=5)

            role_tree.heading('Role', text='Role')
            role_tree.heading('Count', text='Count')
            role_tree.heading('Percentage', text='Percentage')

            for role, count in role_data:
                percentage = f"{(count / total_users) * 100:.1f}%"
                role_display = role.replace('_', ' ').title()
                role_tree.insert('', 'end', values=(role_display, count, percentage))

            # Recent user activity
            users_right = tk.Frame(users_frame, bg='#f8f9fa')
            users_right.pack(side='right', fill='both', expand=True, padx=(10, 0))

            tk.Label(users_right, text="User Registration Trend (Last 30 Days)",
                     font=('Arial', 12, 'bold'), bg='#f8f9fa').pack(anchor='w')

            cursor.execute('''
                           SELECT DATE(created_date) as date, COUNT(*) as count
                           FROM users
                           WHERE created_date >= date('now', '-30 days')
                           GROUP BY DATE(created_date)
                           ORDER BY date DESC LIMIT 10
                           ''')
            recent_users = cursor.fetchall()

            user_trend_tree = ttk.Treeview(users_right, columns=('Date', 'New Users'),
                                           show='headings', height=8)
            user_trend_tree.pack(fill='both', expand=True, pady=5)

            user_trend_tree.heading('Date', text='Date')
            user_trend_tree.heading('New Users', text='New Users')

            for date, count in recent_users:
                user_trend_tree.insert('', 'end', values=(date, count))

            # === BUSINESS STATISTICS ===
            business_frame = tk.LabelFrame(scrollable_frame, text="Business Analytics",
                                           font=('Arial', 14, 'bold'), bg='#f8f9fa',
                                           fg='#2c3e50', padx=10, pady=10)
            business_frame.pack(fill='x', padx=20, pady=(0, 20))

            # Left side - Store Statistics
            business_left = tk.Frame(business_frame, bg='#f8f9fa')
            business_left.pack(side='left', fill='both', expand=True, padx=(0, 10))

            tk.Label(business_left, text="Store Performance", font=('Arial', 12, 'bold'),
                     bg='#f8f9fa').pack(anchor='w')

            cursor.execute('''
                           SELECT s.name,
                                  COUNT(t.id)                      as transaction_count,
                                  COALESCE(SUM(t.total_amount), 0) as total_revenue
                           FROM stores s
                                    LEFT JOIN transactions t ON s.id = t.store_id
                           GROUP BY s.id, s.name
                           ORDER BY total_revenue DESC LIMIT 10
                           ''')
            store_performance = cursor.fetchall()

            store_tree = ttk.Treeview(business_left, columns=('Store', 'Transactions', 'Revenue'),
                                      show='headings', height=8)
            store_tree.pack(fill='both', expand=True, pady=5)

            store_tree.heading('Store', text='Store Name')
            store_tree.heading('Transactions', text='Transactions')
            store_tree.heading('Revenue', text='Revenue (FCFA)')

            for store_name, trans_count, revenue in store_performance:
                store_tree.insert('', 'end', values=(
                    store_name[:30] + '...' if len(store_name) > 30 else store_name,
                    trans_count,
                    f"{revenue:,.0f}"
                ))

            # Right side - Contract Statistics
            business_right = tk.Frame(business_frame, bg='#f8f9fa')
            business_right.pack(side='right', fill='both', expand=True, padx=(10, 0))

            tk.Label(business_right, text="Contract Status Distribution",
                     font=('Arial', 12, 'bold'), bg='#f8f9fa').pack(anchor='w')

            cursor.execute('''
                           SELECT status, COUNT(*) as count, AVG(budget) as avg_budget
                           FROM contracts
                           GROUP BY status
                           ORDER BY count DESC
                           ''')
            contract_status = cursor.fetchall()

            contract_tree = ttk.Treeview(business_right, columns=('Status', 'Count', 'Avg Budget'),
                                         show='headings', height=8)
            contract_tree.pack(fill='both', expand=True, pady=5)

            contract_tree.heading('Status', text='Status')
            contract_tree.heading('Count', text='Count')
            contract_tree.heading('Avg Budget', text='Avg Budget (FCFA)')

            for status, count, avg_budget in contract_status:
                avg_budget_formatted = f"{avg_budget:,.0f}" if avg_budget else "0"
                contract_tree.insert('', 'end', values=(status, count, avg_budget_formatted))

            # === INVENTORY STATISTICS ===
            inventory_frame = tk.LabelFrame(scrollable_frame, text="Inventory & Materials",
                                            font=('Arial', 14, 'bold'), bg='#f8f9fa',
                                            fg='#2c3e50', padx=10, pady=10)
            inventory_frame.pack(fill='x', padx=20, pady=(0, 20))

            # Material categories
            inventory_left = tk.Frame(inventory_frame, bg='#f8f9fa')
            inventory_left.pack(side='left', fill='both', expand=True, padx=(0, 10))

            tk.Label(inventory_left, text="Materials by Category", font=('Arial', 12, 'bold'),
                     bg='#f8f9fa').pack(anchor='w')

            cursor.execute('''
                           SELECT category, COUNT(*) as material_count, AVG(standard_price) as avg_price
                           FROM building_materials
                           GROUP BY category
                           ORDER BY material_count DESC
                           ''')
            material_categories = cursor.fetchall()

            material_tree = ttk.Treeview(inventory_left, columns=('Category', 'Materials', 'Avg Price'),
                                         show='headings', height=8)
            material_tree.pack(fill='both', expand=True, pady=5)

            material_tree.heading('Category', text='Category')
            material_tree.heading('Materials', text='Materials')
            material_tree.heading('Avg Price', text='Avg Price (FCFA)')

            for category, count, avg_price in material_categories:
                avg_price_formatted = f"{avg_price:,.0f}" if avg_price else "0"
                material_tree.insert('', 'end', values=(category, count, avg_price_formatted))

            # Low stock alerts
            inventory_right = tk.Frame(inventory_frame, bg='#f8f9fa')
            inventory_right.pack(side='right', fill='both', expand=True, padx=(10, 0))

            tk.Label(inventory_right, text="Low Stock Alerts", font=('Arial', 12, 'bold'),
                     bg='#f8f9fa').pack(anchor='w')

            cursor.execute('''
                           SELECT s.name  as store_name,
                                  bm.name as material_name,
                                  i.quantity,
                                  i.reorder_level
                           FROM inventory i
                                    JOIN stores s ON i.store_id = s.id
                                    JOIN building_materials bm ON i.material_id = bm.id
                           WHERE i.quantity <= i.reorder_level
                           ORDER BY i.quantity ASC LIMIT 10
                           ''')
            low_stock = cursor.fetchall()

            stock_tree = ttk.Treeview(inventory_right, columns=('Store', 'Material', 'Quantity', 'Reorder'),
                                      show='headings', height=8)
            stock_tree.pack(fill='both', expand=True, pady=5)

            stock_tree.heading('Store', text='Store')
            stock_tree.heading('Material', text='Material')
            stock_tree.heading('Quantity', text='Qty')
            stock_tree.heading('Reorder', text='Reorder Level')

            for store, material, qty, reorder in low_stock:
                stock_tree.insert('', 'end', values=(
                    store[:15] + '...' if len(store) > 15 else store,
                    material[:20] + '...' if len(material) > 20 else material,
                    qty, reorder
                ))

            # === FINANCIAL SUMMARY ===
            financial_frame = tk.LabelFrame(scrollable_frame, text="Financial Summary",
                                            font=('Arial', 14, 'bold'), bg='#f8f9fa',
                                            fg='#2c3e50', padx=10, pady=10)
            financial_frame.pack(fill='x', padx=20, pady=(0, 20))

            # Calculate financial metrics
            cursor.execute("SELECT SUM(total_amount) FROM transactions")
            total_revenue = cursor.fetchone()[0] or 0

            cursor.execute("SELECT SUM(total_amount) FROM transactions WHERE DATE(transaction_date) = DATE('now')")
            today_revenue = cursor.fetchone()[0] or 0

            cursor.execute(
                "SELECT SUM(total_amount) FROM transactions WHERE DATE(transaction_date) >= DATE('now', '-7 days')")
            week_revenue = cursor.fetchone()[0] or 0

            cursor.execute(
                "SELECT SUM(total_amount) FROM transactions WHERE strftime('%Y-%m', transaction_date) = strftime('%Y-%m', 'now')")
            month_revenue = cursor.fetchone()[0] or 0

            cursor.execute("SELECT AVG(total_amount) FROM transactions")
            avg_transaction = cursor.fetchone()[0] or 0

            # Financial metrics display
            fin_metrics_frame = tk.Frame(financial_frame, bg='#f8f9fa')
            fin_metrics_frame.pack(fill='x', pady=10)

            financial_metrics = [
                ("Total Revenue", f"{total_revenue:,.0f} FCFA", "#27ae60"),
                ("Today's Revenue", f"{today_revenue:,.0f} FCFA", "#3498db"),
                ("Week Revenue", f"{week_revenue:,.0f} FCFA", "#f39c12"),
                ("Month Revenue", f"{month_revenue:,.0f} FCFA", "#e74c3c"),
                ("Avg Transaction", f"{avg_transaction:,.0f} FCFA", "#9b59b6")
            ]

            for i, (label, value, color) in enumerate(financial_metrics):
                metric_card = tk.Frame(fin_metrics_frame, bg=color, width=220, height=70,
                                       relief='raised', bd=2)
                metric_card.grid(row=i // 3, column=i % 3, padx=10, pady=5, sticky='nsew')
                metric_card.grid_propagate(False)

                tk.Label(metric_card, text=label, font=('Arial', 10, 'bold'),
                         bg=color, fg='white').pack(pady=(5, 0))
                tk.Label(metric_card, text=value, font=('Arial', 12, 'bold'),
                         bg=color, fg='white').pack(pady=(0, 5))

            for i in range(3):
                fin_metrics_frame.grid_columnconfigure(i, weight=1)

            # === SYSTEM HEALTH ===
            health_frame = tk.LabelFrame(scrollable_frame, text="System Health",
                                         font=('Arial', 14, 'bold'), bg='#f8f9fa',
                                         fg='#2c3e50', padx=10, pady=10)
            health_frame.pack(fill='x', padx=20, pady=(0, 20))

            # Database statistics
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            table_count = len(cursor.fetchall())

            cursor.execute("SELECT COUNT(*) FROM audit_log")
            audit_records = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM audit_log WHERE DATE(timestamp) = DATE('now')")
            today_activities = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM users WHERE last_login >= datetime('now', '-24 hours')")
            active_24h = cursor.fetchone()[0]

            # Database size (approximate)
            import os
            try:
                db_size = os.path.getsize(self.db_manager.db_name) / (1024 * 1024)  # MB
                db_size_str = f"{db_size:.2f} MB"
            except:
                db_size_str = "Unknown"

            health_info = [
                ("Database Tables", str(table_count)),
                ("Database Size", db_size_str),
                ("Audit Records", f"{audit_records:,}"),
                ("Today's Activities", str(today_activities)),
                ("Active (24h)", str(active_24h)),
                ("System Status", "🟢 Healthy")
            ]

            health_display = tk.Frame(health_frame, bg='#f8f9fa')
            health_display.pack(fill='x', pady=10)

            for i, (label, value) in enumerate(health_info):
                info_frame = tk.Frame(health_display, bg='#ecf0f1', relief='solid', bd=1)
                info_frame.grid(row=i // 3, column=i % 3, padx=5, pady=5, sticky='nsew')

                tk.Label(info_frame, text=label, font=('Arial', 9, 'bold'),
                         bg='#ecf0f1', fg='#2c3e50').pack(pady=(5, 0))
                tk.Label(info_frame, text=value, font=('Arial', 11, 'bold'),
                         bg='#ecf0f1', fg='#27ae60' if '🟢' in value else '#2c3e50').pack(pady=(0, 5))

            for i in range(3):
                health_display.grid_columnconfigure(i, weight=1)

            conn.close()

        except Exception as e:
            error_frame = tk.Frame(scrollable_frame, bg='#f8f9fa')
            error_frame.pack(fill='both', expand=True, padx=20, pady=20)

            tk.Label(error_frame, text="Error Loading Statistics",
                     font=('Arial', 16, 'bold'), bg='#f8f9fa', fg='#e74c3c').pack(pady=20)
            tk.Label(error_frame, text=f"Error: {str(e)}",
                     font=('Arial', 12), bg='#f8f9fa', fg='#e74c3c').pack()

        # Footer with last updated time
        footer_frame = tk.Frame(scrollable_frame, bg='#34495e', height=40)
        footer_frame.pack(fill='x', pady=(20, 0))
        footer_frame.pack_propagate(False)

        from datetime import datetime
        last_updated = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        tk.Label(footer_frame, text=f"Last Updated: {last_updated}",
                 font=('Arial', 10), bg='#34495e', fg='white').pack(expand=True)

        # Pack canvas and scrollbar
        main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Refresh function
        def refresh_stats():
            stats_window.destroy()
            self.show_system_statistics()

        refresh_btn.config(command=refresh_stats)

        # Close button
        close_frame = tk.Frame(stats_window, bg='#f8f9fa', height=50)
        close_frame.pack(fill='x', side='bottom')
        close_frame.pack_propagate(False)

        tk.Button(close_frame, text="Close", font=('Arial', 12, 'bold'),
                  bg='#e74c3c', fg='white', width=15,
                  command=stats_window.destroy).pack(expand=True)

        # Keyboard shortcuts
        stats_window.bind('<F5>', lambda e: refresh_stats())
        stats_window.bind('<Escape>', lambda e: stats_window.destroy())

        # Mouse wheel scrolling
        def on_mousewheel(event):
            main_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

        main_canvas.bind("<MouseWheel>", on_mousewheel)

        # Log the action
        self.log_audit_action(
            self.current_user['id'],
            "View System Statistics",
            "Accessed system statistics dashboard"
        )
    def show_audit_log(self):
        try:
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Audit Log", "You must be logged in to view the audit log.")
                return
            # Allow all roles to view their actions; admins can view all users
            role = self.current_user.get('role')

            win = tk.Toplevel(self.root)
            win.title("Audit Log")
            win.geometry("1000x620")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Audit Log", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filt = tk.Frame(win, bg='white')
            filt.pack(fill='x', padx=10)
            tk.Label(filt, text="User:", bg='white').grid(row=0, column=0, sticky='e', padx=6, pady=6)
            user_var = tk.StringVar()
            user_cb = ttk.Combobox(filt, textvariable=user_var, state='readonly', width=30)
            user_cb.grid(row=0, column=1, sticky='w')
            tk.Label(filt, text="From (YYYY-MM-DD):", bg='white').grid(row=0, column=2, sticky='e', padx=6)
            from_var = tk.StringVar()
            tk.Entry(filt, textvariable=from_var, width=16).grid(row=0, column=3, sticky='w')
            tk.Label(filt, text="To (YYYY-MM-DD):", bg='white').grid(row=0, column=4, sticky='e', padx=6)
            to_var = tk.StringVar()
            tk.Entry(filt, textvariable=to_var, width=16).grid(row=0, column=5, sticky='w')
            tk.Label(filt, text="Action contains:", bg='white').grid(row=0, column=6, sticky='e', padx=6)
            q_var = tk.StringVar()
            tk.Entry(filt, textvariable=q_var, width=22).grid(row=0, column=7, sticky='w')
            refresh_btn = tk.Button(filt, text="Refresh", bg="#3498db", fg="white")
            refresh_btn.grid(row=0, column=8, padx=6)
            export_btn = tk.Button(filt, text="Export CSV")
            export_btn.grid(row=0, column=9)

            # Table
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("Time","User","Action","Details","IP")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=160 if c in ("Time","User","Action") else 260)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            user_map = {"All Users": None}
            def load_users():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    if role == 'administrator':
                        cur.execute("SELECT id, COALESCE(full_name, username) FROM users ORDER BY full_name, username")
                    else:
                        # Non-admin sees only self in dropdown
                        cur.execute("SELECT id, COALESCE(full_name, username) FROM users WHERE id=?", (self.current_user['id'],))
                    rows = cur.fetchall(); conn.close()
                    values = ["All Users"] if role == 'administrator' else []
                    for uid, name in rows:
                        disp = f"{uid} - {name}"; user_map[disp] = uid; values.append(disp)
                    if not values:
                        values = [f"{self.current_user['id']} - {self.current_user['username']}"]
                        user_map[values[0]] = self.current_user['id']
                    user_cb['values'] = values; user_cb.set(values[0])
                except Exception:
                    user_cb['values'] = ["All Users"]; user_cb.set("All Users")

            def refresh():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    query = (
                        "SELECT a.timestamp, COALESCE(u.full_name,u.username) AS user, a.action, substr(COALESCE(a.details,''),1,200), COALESCE(a.ip_address,'') "
                        "FROM audit_log a LEFT JOIN users u ON u.id = a.user_id WHERE 1=1 "
                    )
                    params = []
                    uid = user_map.get(user_var.get())
                    if role != 'administrator':
                        query += "AND a.user_id = ? "; params.append(self.current_user['id'])
                    elif uid:
                        query += "AND a.user_id = ? "; params.append(uid)
                    f = from_var.get().strip()
                    if f:
                        query += "AND date(a.timestamp) >= ? "; params.append(f)
                    t = to_var.get().strip()
                    if t:
                        query += "AND date(a.timestamp) <= ? "; params.append(t)
                    q = q_var.get().strip()
                    if q:
                        query += "AND (a.action LIKE ? OR a.details LIKE ?) "; like = f"%{q}%"; params.extend([like, like])
                    query += "ORDER BY a.timestamp DESC LIMIT 500"
                    cur.execute(query, params)
                    rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Audit Log", f"Failed to load audit log: {str(e)}")
                    except Exception:
                        pass
                    rows = []
                for it in tree.get_children():
                    tree.delete(it)
                for r in rows:
                    tree.insert('', 'end', values=r)

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"audit_log_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Audit Log", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"),("All files","*.*")])
                    if not filename:
                        return
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    query = (
                        "SELECT a.timestamp, COALESCE(u.full_name,u.username) AS user, a.action, a.details, COALESCE(a.ip_address,'') "
                        "FROM audit_log a LEFT JOIN users u ON u.id = a.user_id WHERE 1=1 "
                    )
                    params = []
                    uid = user_map.get(user_var.get())
                    if role != 'administrator':
                        query += "AND a.user_id = ? "; params.append(self.current_user['id'])
                    elif uid:
                        query += "AND a.user_id = ? "; params.append(uid)
                    f = from_var.get().strip()
                    if f:
                        query += "AND date(a.timestamp) >= ? "; params.append(f)
                    t = to_var.get().strip()
                    if t:
                        query += "AND date(a.timestamp) <= ? "; params.append(t)
                    q = q_var.get().strip()
                    if q:
                        query += "AND (a.action LIKE ? OR a.details LIKE ?) "; like = f"%{q}%"; params.extend([like, like])
                    query += "ORDER BY a.timestamp DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall(); conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        w = csv.writer(f)
                        w.writerow(["Time","User","Action","Details","IP"])
                        for r in rows:
                            w.writerow(r)
                    messagebox.showinfo("Export", "Audit log exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Export", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            # Wire
            refresh_btn.config(command=refresh)
            export_btn.config(command=export_csv)
            user_var.trace('w', lambda *a: refresh())
            q_var.trace('w', lambda *a: refresh())

            # Init
            load_users(); refresh()

            try:
                self.log_audit_action(self.current_user['id'], "Open Audit Log", "")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Audit Log", f"Failed to open Audit Log: {str(e)}")
            except Exception:
                pass
#================ create store functionality==========================
    def show_create_store(self):
        # Create Store window
        create_store_window = tk.Toplevel(self.root)
        create_store_window.title("Create New Store")
        create_store_window.geometry("700x800")
        create_store_window.configure(bg='#34495e')
        create_store_window.grab_set()  # Make modal
        create_store_window.resizable(False, False)

        # Center the window
        create_store_window.transient(self.root)

        # Main container
        main_frame = tk.Frame(create_store_window, bg='#34495e', padx=30, pady=20)
        main_frame.pack(fill='both', expand=True)

        # Title
        title_label = tk.Label(main_frame, text="Create New Store",
                               font=('Arial', 18, 'bold'), bg='#34495e', fg='white')
        title_label.pack(pady=(0, 30))

        # Form frame with scrollbar support
        canvas = tk.Canvas(main_frame, bg='#34495e', highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#34495e')

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Form entries dictionary
        form_entries = {}

        # Basic Store Information Section
        basic_section = tk.LabelFrame(scrollable_frame, text="Basic Store Information",
                                      font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        basic_section.pack(fill='x', pady=(0, 20), padx=5)

        # Store Name
        name_frame = tk.Frame(basic_section, bg='#34495e')
        name_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(name_frame, text="Store Name *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        name_entry = tk.Entry(name_frame, font=('Arial', 11), width=35)
        name_entry.pack(side='left', padx=(10, 0))
        form_entries['name'] = name_entry

        # Store Description
        desc_frame = tk.Frame(basic_section, bg='#34495e')
        desc_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(desc_frame, text="Description", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        desc_entry = tk.Entry(desc_frame, font=('Arial', 11), width=35)
        desc_entry.pack(side='left', padx=(10, 0))
        form_entries['description'] = desc_entry

        # Store Category
        category_frame = tk.Frame(basic_section, bg='#34495e')
        category_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(category_frame, text="Store Category *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        category_var = tk.StringVar()
        category_combo = ttk.Combobox(category_frame, textvariable=category_var,
                                      font=('Arial', 11), width=32, state='readonly')
        category_combo['values'] = [
            'General Building Materials',
            'Cement & Concrete',
            'Steel & Metal Products',
            'Timber & Wood Products',
            'Roofing Materials',
            'Plumbing & Electrical',
            'Paint & Finishes',
            'Tools & Equipment',
            'Wholesale Distributor',
            'Retail Outlet',
            'onside supply store'
        ]
        category_combo.pack(side='left', padx=(10, 0))
        form_entries['category'] = category_combo

        # Location Information Section
        location_section = tk.LabelFrame(scrollable_frame, text="Location Information",
                                         font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        location_section.pack(fill='x', pady=(0, 20), padx=5)

        # Region/Province
        region_frame = tk.Frame(location_section, bg='#34495e')
        region_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(region_frame, text="Region/Province *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        region_var = tk.StringVar()
        region_combo = ttk.Combobox(region_frame, textvariable=region_var,
                                    font=('Arial', 11), width=32, state='readonly')
        region_combo['values'] = [
            'Adamawa', 'Centre', 'East', 'Far North', 'Littoral',
            'North', 'Northwest', 'South', 'Southwest', 'West'
        ]
        region_combo.pack(side='left', padx=(10, 0))
        form_entries['region'] = region_combo

        # City/Town
        city_frame = tk.Frame(location_section, bg='#34495e')
        city_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(city_frame, text="City/Town *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        city_entry = tk.Entry(city_frame, font=('Arial', 11), width=35)
        city_entry.pack(side='left', padx=(10, 0))
        form_entries['city'] = city_entry

        # Full Address
        address_frame = tk.Frame(location_section, bg='#34495e')
        address_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(address_frame, text="Full Address *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        address_text = tk.Text(address_frame, font=('Arial', 11), width=35, height=3)
        address_text.pack(side='left', padx=(10, 0))
        form_entries['address'] = address_text

        # GPS Coordinates (Optional)
        gps_frame = tk.Frame(location_section, bg='#34495e')
        gps_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(gps_frame, text="GPS Coordinates", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        gps_entry = tk.Entry(gps_frame, font=('Arial', 11), width=35)
        gps_entry.pack(side='left', padx=(10, 0))
        form_entries['gps'] = gps_entry

        # Contact Information Section
        contact_section = tk.LabelFrame(scrollable_frame, text="Contact Information",
                                        font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        contact_section.pack(fill='x', pady=(0, 20), padx=5)

        # Primary Phone
        phone_frame = tk.Frame(contact_section, bg='#34495e')
        phone_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(phone_frame, text="Primary Phone *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        phone_entry = tk.Entry(phone_frame, font=('Arial', 11), width=35)
        phone_entry.pack(side='left', padx=(10, 0))
        form_entries['phone'] = phone_entry

        # Secondary Phone
        phone2_frame = tk.Frame(contact_section, bg='#34495e')
        phone2_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(phone2_frame, text="Secondary Phone", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        phone2_entry = tk.Entry(phone2_frame, font=('Arial', 11), width=35)
        phone2_entry.pack(side='left', padx=(10, 0))
        form_entries['phone2'] = phone2_entry

        # Email
        email_frame = tk.Frame(contact_section, bg='#34495e')
        email_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(email_frame, text="Email Address", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        email_entry = tk.Entry(email_frame, font=('Arial', 11), width=35)
        email_entry.pack(side='left', padx=(10, 0))
        form_entries['email'] = email_entry

        # Business Information Section
        business_section = tk.LabelFrame(scrollable_frame, text="Business Information",
                                         font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        business_section.pack(fill='x', pady=(0, 20), padx=5)

        # Registration Number
        reg_frame = tk.Frame(business_section, bg='#34495e')
        reg_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(reg_frame, text="Registration Number", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        reg_entry = tk.Entry(reg_frame, font=('Arial', 11), width=35)
        reg_entry.pack(side='left', padx=(10, 0))
        form_entries['registration'] = reg_entry

        # Tax ID
        tax_frame = tk.Frame(business_section, bg='#34495e')
        tax_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(tax_frame, text="Tax ID Number", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        tax_entry = tk.Entry(tax_frame, font=('Arial', 11), width=35)
        tax_entry.pack(side='left', padx=(10, 0))
        form_entries['tax_id'] = tax_entry

        # Store Manager Assignment
        manager_section = tk.LabelFrame(scrollable_frame, text="Management Assignment",
                                        font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        manager_section.pack(fill='x', pady=(0, 20), padx=5)

        # Manager Selection
        manager_frame = tk.Frame(manager_section, bg='#34495e')
        manager_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(manager_frame, text="Store Manager", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        manager_var = tk.StringVar()
        manager_combo = ttk.Combobox(manager_frame, textvariable=manager_var,
                                     font=('Arial', 11), width=32, state='readonly')

        # Load available managers
        try:
            conn = self.db_manager.create_connection()
            cursor = conn.cursor()
            cursor.execute('''
                           SELECT id, username, full_name
                           FROM users
                           WHERE role IN ('manager', 'retail_store')
                             AND is_active = 1
                           ORDER BY full_name
                           ''')
            managers = cursor.fetchall()
            manager_options = ['None'] + [f"{m[0]} - {m[2]} ({m[1]})" for m in managers]
            manager_combo['values'] = manager_options
            manager_combo.set('None')
            conn.close()
        except Exception as e:
            manager_combo['values'] = ['None']
            manager_combo.set('None')

        manager_combo.pack(side='left', padx=(10, 0))
        form_entries['manager'] = manager_combo

        # Store Settings Section
        settings_section = tk.LabelFrame(scrollable_frame, text="Store Settings",
                                         font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        settings_section.pack(fill='x', pady=(0, 20), padx=5)

        # Operating Hours
        hours_frame = tk.Frame(settings_section, bg='#34495e')
        hours_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(hours_frame, text="Operating Hours", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        hours_entry = tk.Entry(hours_frame, font=('Arial', 11), width=35)
        hours_entry.insert(0, "Mon-Fri: 8:00-18:00, Sat: 8:00-17:00")
        hours_entry.pack(side='left', padx=(10, 0))
        form_entries['hours'] = hours_entry

        # Currency
        currency_frame = tk.Frame(settings_section, bg='#34495e')
        currency_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(currency_frame, text="Currency", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        currency_var = tk.StringVar(value='FCFA')
        currency_combo = ttk.Combobox(currency_frame, textvariable=currency_var,
                                      font=('Arial', 11), width=32, state='readonly')
        currency_combo['values'] = ['FCFA', 'USD', 'EUR']
        currency_combo.pack(side='left', padx=(10, 0))
        form_entries['currency'] = currency_combo

        # Store Status
        status_frame = tk.Frame(settings_section, bg='#34495e')
        status_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(status_frame, text="Store Status", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')

        active_var = tk.BooleanVar(value=True)
        active_check = tk.Checkbutton(status_frame, text="Store Active", variable=active_var,
                                      bg='#34495e', fg='white', selectcolor='#2c3e50',
                                      activebackground='#34495e')
        active_check.pack(side='left', padx=(10, 0))
        form_entries['is_active'] = active_var

        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Validation functions
        def validate_phone(phone):
            if not phone:
                return False, "Phone number is required"
            import re
            # Cameroon phone number pattern
            pattern = r'^(\+237|237)?[6-9]\d{8}$'
            if not re.match(pattern, phone.replace(' ', '').replace('-', '')):
                return False, "Please enter a valid Cameroon phone number (+237XXXXXXXXX)"
            return True, "Valid"

        def validate_email(email):
            if not email:  # Email is optional
                return True, "Valid"
            import re
            pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            if not re.match(pattern, email):
                return False, "Please enter a valid email address"
            return True, "Valid"

        # Create store function
        def create_new_store():
            try:
                # Get all form data
                form_data = {}

                # Get text entries
                text_fields = ['name', 'description', 'city', 'gps', 'phone', 'phone2',
                               'email', 'registration', 'tax_id', 'hours']
                for field in text_fields:
                    widget = form_entries[field]
                    if hasattr(widget, 'get'):
                        form_data[field] = widget.get().strip()
                    else:
                        form_data[field] = ""

                # Get text widget (address)
                form_data['address'] = form_entries['address'].get('1.0', 'end-1c').strip()

                # Get combo boxes
                combo_fields = ['category', 'region', 'manager', 'currency']
                for field in combo_fields:
                    form_data[field] = form_entries[field].get()

                # Get boolean
                form_data['is_active'] = form_entries['is_active'].get()

                # Validation
                errors = []

                # Required fields
                required_fields = ['name', 'category', 'region', 'city', 'address', 'phone']
                for field in required_fields:
                    if not form_data.get(field):
                        field_display = field.replace('_', ' ').title()
                        errors.append(f"{field_display} is required")

                # Phone validation
                if form_data.get('phone'):
                    is_valid, message = validate_phone(form_data['phone'])
                    if not is_valid:
                        errors.append(f"Primary phone: {message}")

                if form_data.get('phone2'):
                    is_valid, message = validate_phone(form_data['phone2'])
                    if not is_valid:
                        errors.append(f"Secondary phone: {message}")

                # Email validation
                if form_data.get('email'):
                    is_valid, message = validate_email(form_data['email'])
                    if not is_valid:
                        errors.append(message)

                # Show validation errors
                if errors:
                    error_message = "Please fix the following errors:\n\n" + "\n".join(f"• {error}" for error in errors)
                    messagebox.showerror("Validation Error", error_message)
                    return

                # Prepare location string
                location = f"{form_data['city']}, {form_data['region']}, Cameroon"

                # Prepare contact info JSON
                contact_info = {
                    'phone': form_data['phone'],
                    'phone2': form_data['phone2'] if form_data['phone2'] else None,
                    'email': form_data['email'] if form_data['email'] else None,
                    'address': form_data['address'],
                    'gps': form_data['gps'] if form_data['gps'] else None,
                    'hours': form_data['hours'],
                    'category': form_data['category'],
                    'registration': form_data['registration'] if form_data['registration'] else None,
                    'tax_id': form_data['tax_id'] if form_data['tax_id'] else None,
                    'currency': form_data['currency']
                }

                # Parse manager ID if selected
                manager_id = None
                if form_data['manager'] != 'None' and form_data['manager']:
                    manager_id = int(form_data['manager'].split(' - ')[0])

                # Database operations
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Check if store name already exists for this owner
                cursor.execute('SELECT COUNT(*) FROM stores WHERE name = ? AND owner_id = ?',
                               (form_data['name'], self.current_user['id']))
                if cursor.fetchone()[0] > 0:
                    messagebox.showerror("Error", "You already have a store with this name!")
                    conn.close()
                    return

                # Insert new store
                cursor.execute('''
                               INSERT INTO stores (name, location, owner_id, manager_id, contact_info,
                                                   created_date, is_active)
                               VALUES (?, ?, ?, ?, ?, ?, ?)
                               ''', (
                                   form_data['name'],
                                   location,
                                   self.current_user['id'],
                                   manager_id,
                                   json.dumps(contact_info),
                                   date.today(),
                                   form_data['is_active']
                               ))

                store_id = cursor.lastrowid
                conn.commit()
                conn.close()

                # Log the action
                self.log_audit_action(
                    self.current_user['id'],
                    "Create Store",
                    f"Created new store: {form_data['name']} in {location}"
                )

                # Show success message
                success_message = (
                    f"Store created successfully!\n\n"
                    f"Store Name: {form_data['name']}\n"
                    f"Location: {location}\n"
                    f"Category: {form_data['category']}\n"
                    f"Store ID: {store_id}\n"
                    f"Status: {'Active' if form_data['is_active'] else 'Inactive'}"
                )

                messagebox.showinfo("Success", success_message)

                # Ask if user wants to add initial inventory
                if messagebox.askyesno("Initial Setup",
                                       "Would you like to set up initial inventory for this store?"):
                    # Close current window and open inventory setup
                    create_store_window.destroy()
                    self.setup_initial_inventory(store_id, form_data['name'])
                else:
                    create_store_window.destroy()

            except ValueError as e:
                messagebox.showerror("Error", "Please check manager selection format")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to create store: {str(e)}")

        # Clear form function
        def clear_form():
            for field_name, widget in form_entries.items():
                if isinstance(widget, tk.BooleanVar):
                    widget.set(True if field_name == 'is_active' else False)
                elif hasattr(widget, 'delete'):
                    if isinstance(widget, tk.Text):
                        widget.delete('1.0', 'end')
                    else:
                        widget.delete(0, 'end')

                        # Reset default values
                        if field_name == 'hours':
                            widget.insert(0, "Mon-Fri: 8:00-18:00, Sat: 8:00-17:00")
                elif hasattr(widget, 'set'):
                    if field_name == 'currency':
                        widget.set('FCFA')
                    elif field_name == 'manager':
                        widget.set('None')
                    else:
                        widget.set('')

        # Button frame
        button_frame = tk.Frame(main_frame, bg='#34495e')
        button_frame.pack(fill='x', pady=(20, 0))

        # Buttons
        tk.Button(button_frame, text="Create Store", font=('Arial', 12, 'bold'),
                  bg='#27ae60', fg='white', width=15, height=2,
                  command=create_new_store).pack(side='left', padx=(0, 10))

        tk.Button(button_frame, text="Clear Form", font=('Arial', 12),
                  bg='#f39c12', fg='white', width=15, height=2,
                  command=clear_form).pack(side='left', padx=(0, 10))

        tk.Button(button_frame, text="Cancel", font=('Arial', 12),
                  bg='#e74c3c', fg='white', width=15, height=2,
                  command=create_store_window.destroy).pack(side='right')

        # Help frame
        help_frame = tk.Frame(main_frame, bg='#34495e')
        help_frame.pack(fill='x', pady=(10, 0))

        help_text = (
            "Tips for creating a store:\n"
            "• Fields marked with * are required\n"
            "• Phone numbers should be in Cameroon format (+237XXXXXXXXX)\n"
            "• Choose appropriate category for better material recommendations\n"
            "• GPS coordinates help customers locate your store\n"
            "• You can assign a manager to help run the store"
        )

        tk.Label(help_frame, text=help_text, font=('Arial', 9),
                 bg='#34495e', fg='#bdc3c7', justify='left').pack(anchor='w')

        # Set focus to first field
        form_entries['name'].focus()

        # Keyboard shortcuts
        create_store_window.bind('<Escape>', lambda e: create_store_window.destroy())

    def setup_initial_inventory(self, store_id, store_name):
        """Setup initial inventory for a new store"""
        inventory_window = tk.Toplevel(self.root)
        inventory_window.title(f"Initial Inventory Setup - {store_name}")
        inventory_window.geometry("800x600")
        inventory_window.configure(bg='white')
        inventory_window.grab_set()

        # Title
        tk.Label(inventory_window, text=f"Initial Inventory Setup\n{store_name}",
                 font=('Arial', 16, 'bold'), bg='white', fg='#2c3e50').pack(pady=20)

        # Instructions
        tk.Label(inventory_window,
                 text="Select materials to add to your initial inventory:",
                 font=('Arial', 12), bg='white', fg='#34495e').pack(pady=(0, 10))

        # Materials selection frame
        materials_frame = tk.Frame(inventory_window, bg='white')
        materials_frame.pack(fill='both', expand=True, padx=20, pady=(0, 20))

        # Treeview for materials
        materials_tree = ttk.Treeview(materials_frame,
                                      columns=('Select', 'Name', 'Category', 'Unit', 'Price'),
                                      show='headings', height=15)
        materials_tree.pack(fill='both', expand=True)

        # Configure columns
        materials_tree.heading('Select', text='Select')
        materials_tree.heading('Name', text='Material Name')
        materials_tree.heading('Category', text='Category')
        materials_tree.heading('Unit', text='Unit')
        materials_tree.heading('Price', text='Standard Price')

        materials_tree.column('Select', width=60)
        materials_tree.column('Name', width=200)
        materials_tree.column('Category', width=120)
        materials_tree.column('Unit', width=100)
        materials_tree.column('Price', width=120)

        # Load materials
        try:
            conn = self.db_manager.create_connection()
            cursor = conn.cursor()
            cursor.execute(
                'SELECT id, name, category, unit, standard_price FROM building_materials ORDER BY category, name')
            materials = cursor.fetchall()
            conn.close()

            selected_materials = set()

            for material in materials:
                material_id, name, category, unit, price = material
                materials_tree.insert('', 'end', values=(
                    '☐', name, category, unit, f"{price:,.0f} FCFA"
                ), tags=(str(material_id),))

            def toggle_selection(event):
                item = materials_tree.selection()[0]
                current_values = list(materials_tree.item(item)['values'])
                material_id = materials_tree.item(item)['tags'][0]

                if current_values[0] == '☐':
                    current_values[0] = '☑'
                    selected_materials.add(int(material_id))
                else:
                    current_values[0] = '☐'
                    selected_materials.discard(int(material_id))

                materials_tree.item(item, values=current_values)

            materials_tree.bind('<Double-1>', toggle_selection)

        except Exception as e:
            tk.Label(materials_frame, text=f"Error loading materials: {str(e)}",
                     font=('Arial', 12), bg='white', fg='red').pack()

        # Buttons
        btn_frame = tk.Frame(inventory_window, bg='white')
        btn_frame.pack(pady=10)

        def setup_selected():
            if not selected_materials:
                messagebox.showinfo("Info", "No materials selected. Store created without initial inventory.")
                inventory_window.destroy()
                return

            messagebox.showinfo("Success",
                                f"Store created successfully with {len(selected_materials)} materials selected for inventory setup.\n\n"
                                "You can now manage inventory from the Store menu.")
            inventory_window.destroy()

        tk.Button(btn_frame, text="Complete Setup", font=('Arial', 12, 'bold'),
                  bg='#27ae60', fg='white', width=15,
                  command=setup_selected).pack(side='left', padx=(0, 10))

        tk.Button(btn_frame, text="Skip for Now", font=('Arial', 12),
                  bg='#95a5a6', fg='white', width=15,
                  command=lambda: [messagebox.showinfo("Info", "Store created successfully!"),
                                   inventory_window.destroy()]).pack(side='left')


# ================= store management ==================================

    def show_manage_stores(self):
        # Manage Stores window
        manage_window = tk.Toplevel(self.root)
        manage_window.title("Manage Stores")
        manage_window.geometry("1400x800")
        manage_window.configure(bg='white')
        manage_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(manage_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="Store Management", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Search and filter frame
        search_frame = tk.Frame(header_frame, bg='white')
        search_frame.pack(side='right')

        # Search entry
        tk.Label(search_frame, text="Search:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        search_var = tk.StringVar()
        search_entry = tk.Entry(search_frame, textvariable=search_var, font=('Arial', 10), width=20)
        search_entry.pack(side='left', padx=(0, 10))

        # Status filter
        tk.Label(search_frame, text="Status:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        status_filter_var = tk.StringVar()
        status_filter = ttk.Combobox(search_frame, textvariable=status_filter_var, width=12, state='readonly')
        status_filter['values'] = ['All', 'Active', 'Inactive']
        status_filter.set('All')
        status_filter.pack(side='left', padx=(0, 10))

        # Region filter
        tk.Label(search_frame, text="Region:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        region_filter_var = tk.StringVar()
        region_filter = ttk.Combobox(search_frame, textvariable=region_filter_var, width=12, state='readonly')
        region_filter['values'] = ['All', 'Adamawa', 'Centre', 'East', 'Far North', 'Littoral',
                                   'North', 'Northwest', 'South', 'Southwest', 'West']
        region_filter.set('All')
        region_filter.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(search_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left')

        # Statistics frame
        stats_frame = tk.Frame(main_frame, bg='#ecf0f1', relief='raised', bd=1)
        stats_frame.pack(fill='x', pady=(0, 10))

        stats_inner = tk.Frame(stats_frame, bg='#ecf0f1')
        stats_inner.pack(pady=10)

        # Statistics labels (will be updated by load_stores)
        total_stores_label = tk.Label(stats_inner, text="Total Stores: 0", font=('Arial', 10, 'bold'),
                                      bg='#ecf0f1', fg='#2c3e50')
        total_stores_label.pack(side='left', padx=20)

        active_stores_label = tk.Label(stats_inner, text="Active: 0", font=('Arial', 10, 'bold'),
                                       bg='#ecf0f1', fg='#27ae60')
        active_stores_label.pack(side='left', padx=20)

        inactive_stores_label = tk.Label(stats_inner, text="Inactive: 0", font=('Arial', 10, 'bold'),
                                         bg='#ecf0f1', fg='#e74c3c')
        inactive_stores_label.pack(side='left', padx=20)

        my_stores_label = tk.Label(stats_inner, text="My Stores: 0", font=('Arial', 10, 'bold'),
                                   bg='#ecf0f1', fg='#3498db')
        my_stores_label.pack(side='left', padx=20)

        # Stores treeview frame
        tree_frame = tk.Frame(main_frame, bg='white')
        tree_frame.pack(fill='both', expand=True, pady=(0, 20))

        # Treeview with scrollbars
        tree_scroll_y = ttk.Scrollbar(tree_frame)
        tree_scroll_y.pack(side='right', fill='y')

        tree_scroll_x = ttk.Scrollbar(tree_frame, orient='horizontal')
        tree_scroll_x.pack(side='bottom', fill='x')

        stores_tree = ttk.Treeview(tree_frame,
                                   columns=('ID', 'Name', 'Owner', 'Manager', 'Location', 'Category', 'Contact',
                                            'Status', 'Created'),
                                   show='headings',
                                   yscrollcommand=tree_scroll_y.set,
                                   xscrollcommand=tree_scroll_x.set)
        stores_tree.pack(fill='both', expand=True)

        tree_scroll_y.config(command=stores_tree.yview)
        tree_scroll_x.config(command=stores_tree.xview)

        # Configure columns
        columns_config = [
            ('ID', 60, 'center'),
            ('Name', 200, 'w'),
            ('Owner', 120, 'w'),
            ('Manager', 120, 'w'),
            ('Location', 150, 'w'),
            ('Category', 120, 'w'),
            ('Contact', 120, 'w'),
            ('Status', 80, 'center'),
            ('Created', 100, 'center')
        ]

        for col, width, anchor in columns_config:
            stores_tree.heading(col, text=col)
            stores_tree.column(col, width=width, anchor=anchor)

        # Configure row colors based on status and ownership
        stores_tree.tag_configure('active', background='#e8f5e8')
        stores_tree.tag_configure('inactive', background='#ffebee')
        stores_tree.tag_configure('my_store', background='#e3f2fd')

        # Action buttons frame
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(0, 10))

        # Left side buttons (store actions)
        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')

        new_store_btn = tk.Button(left_buttons, text="New Store", font=('Arial', 10, 'bold'),
                                  bg='#27ae60', fg='white', width=12)
        new_store_btn.pack(side='left', padx=(0, 5))

        view_btn = tk.Button(left_buttons, text="View Details", font=('Arial', 10, 'bold'),
                             bg='#3498db', fg='white', width=12)
        view_btn.pack(side='left', padx=(0, 5))

        edit_btn = tk.Button(left_buttons, text="Edit Store", font=('Arial', 10, 'bold'),
                             bg='#f39c12', fg='white', width=12)
        edit_btn.pack(side='left', padx=(0, 5))

        # New: Manager assignment controls
        assign_btn = tk.Button(left_buttons, text="Assign Manager", font=('Arial', 10, 'bold'),
                               bg='#8e44ad', fg='white', width=14)
        assign_btn.pack(side='left', padx=(0, 5))

        unassign_btn = tk.Button(left_buttons, text="Unassign Manager", font=('Arial', 10),
                                 bg='#6c757d', fg='white', width=14)
        unassign_btn.pack(side='left', padx=(0, 5))

        inventory_btn = tk.Button(left_buttons, text="Manage Inventory", font=('Arial', 10),
                                  bg='#9b59b6', fg='white', width=14)
        inventory_btn.pack(side='left', padx=(0, 5))

        view_inventory_btn = tk.Button(left_buttons, text="View Inventory", font=('Arial', 10),
                                       bg='#34495e', fg='white', width=14)
        view_inventory_btn.pack(side='left', padx=(0, 5))

        # Buy Materials: visible for Contract Owners only
        buy_btn = None
        if self.current_user.get('role') == 'contract_owner':
            buy_btn = tk.Button(left_buttons, text="Buy Materials", font=('Arial', 10, 'bold'),
                                 bg='#2ecc71', fg='white', width=12)
            buy_btn.pack(side='left', padx=(0, 5))

        analytics_btn = tk.Button(left_buttons, text="Store Analytics", font=('Arial', 10),
                                  bg='#17a2b8', fg='white', width=12)
        analytics_btn.pack(side='left', padx=(0, 5))

        toggle_status_btn = tk.Button(left_buttons, text="Toggle Status", font=('Arial', 10),
                                      bg='#fd7e14', fg='white', width=12)
        toggle_status_btn.pack(side='left', padx=(0, 5))

        # Delete Store action has been disabled by policy: no store deletion allowed.
        # (Button removed)

        # Right side buttons (reports and export)
        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')

        export_btn = tk.Button(right_buttons, text="Export CSV", font=('Arial', 10),
                               bg='#6c757d', fg='white', width=10)
        export_btn.pack(side='left', padx=(0, 5))

        report_btn = tk.Button(right_buttons, text="Store Report", font=('Arial', 10),
                               bg='#20c997', fg='white', width=12)
        report_btn.pack(side='left', padx=(0, 5))

        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10),
                              bg='#6c757d', fg='white', width=10,
                              command=manage_window.destroy)
        close_btn.pack(side='left')

        # Load and display stores function
        def load_stores():
            # Clear existing items
            for item in stores_tree.get_children():
                stores_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Build query based on filters and user role
                search_text = search_var.get().strip()
                status_filter_text = status_filter_var.get()
                region_filter_text = region_filter_var.get()

                query = '''
                        SELECT s.id,
                               s.name,
                               owner.full_name                             as owner_name,
                               COALESCE(manager.full_name, 'Not Assigned') as manager_name,
                               s.location,
                               s.contact_info,
                               s.is_active,
                               s.created_date,
                               s.owner_id
                        FROM stores s
                                 JOIN users owner ON s.owner_id = owner.id
                                 LEFT JOIN users manager ON s.manager_id = manager.id
                        WHERE 1 = 1
                        '''
                params = []

                # Apply user role-based filtering
                if self.current_user['role'] == 'retail_store':
                    # Retail store owners can only see their own stores
                    query += ' AND s.owner_id = ?'
                    params.append(self.current_user['id'])
                elif self.current_user['role'] == 'manager':
                    # Managers can see stores they manage
                    query += ' AND s.manager_id = ?'
                    params.append(self.current_user['id'])

                # Apply search filter
                if search_text:
                    query += ' AND (s.name LIKE ? OR s.location LIKE ? OR owner.full_name LIKE ?)'
                    search_pattern = f'%{search_text}%'
                    params.extend([search_pattern, search_pattern, search_pattern])

                # Apply status filter
                if status_filter_text == 'Active':
                    query += ' AND s.is_active = 1'
                elif status_filter_text == 'Inactive':
                    query += ' AND s.is_active = 0'

                # Apply region filter
                if region_filter_text != 'All':
                    query += ' AND s.location LIKE ?'
                    params.append(f'%{region_filter_text}%')

                query += ' ORDER BY s.created_date DESC'

                cursor.execute(query, params)
                stores = cursor.fetchall()

                # Statistics counters
                total_count = 0
                active_count = 0
                inactive_count = 0
                my_stores_count = 0

                # Insert stores into tree
                for store in stores:
                    store_id, name, owner_name, manager_name, location, contact_info, is_active, created_date, owner_id = store

                    # Parse contact info
                    category = "General"
                    phone = "N/A"
                    try:
                        contact_data = json.loads(contact_info) if contact_info else {}
                        category = contact_data.get('category', 'General')
                        phone = contact_data.get('phone', 'N/A')
                    except:
                        pass

                    # Format status
                    status = "Active" if is_active else "Inactive"

                    # Determine row styling
                    tags = []
                    if is_active:
                        tags.append('active')
                    else:
                        tags.append('inactive')

                    # Highlight user's own stores
                    if owner_id == self.current_user['id']:
                        tags.append('my_store')
                        my_stores_count += 1

                    stores_tree.insert('', 'end', values=(
                        store_id,
                        name[:30] + '...' if len(name) > 30 else name,
                        owner_name,
                        manager_name,
                        location[:25] + '...' if len(location) > 25 else location,
                        category,
                        phone,
                        status,
                        created_date
                    ), tags=tags)

                    # Update counters
                    total_count += 1
                    if is_active:
                        active_count += 1
                    else:
                        inactive_count += 1

                # Update statistics
                total_stores_label.config(text=f"Total Stores: {total_count}")
                active_stores_label.config(text=f"Active: {active_count}")
                inactive_stores_label.config(text=f"Inactive: {inactive_count}")
                my_stores_label.config(text=f"My Stores: {my_stores_count}")

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load stores: {str(e)}")

        # New store function
        def new_store():
            manage_window.destroy()
            self.show_create_store()

        # View store details function
        def view_store():
            selected = stores_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a store to view")
                return

            store_id = stores_tree.item(selected[0])['values'][0]

            # Create view window
            view_window = tk.Toplevel(manage_window)
            view_window.title("Store Details")
            view_window.geometry("800x700")
            view_window.configure(bg='#f8f9fa')
            view_window.grab_set()
            view_window.transient(manage_window)

            # Load store details
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT s.name,
                                      s.location,
                                      s.contact_info,
                                      s.is_active,
                                      s.created_date,
                                      owner.full_name                             as owner_name,
                                      owner.email                                 as owner_email,
                                      owner.phone                                 as owner_phone,
                                      COALESCE(manager.full_name, 'Not Assigned') as manager_name,
                                      COALESCE(manager.email, '')                 as manager_email
                               FROM stores s
                                        JOIN users owner ON s.owner_id = owner.id
                                        LEFT JOIN users manager ON s.manager_id = manager.id
                               WHERE s.id = ?
                               ''', (store_id,))

                store_data = cursor.fetchone()
                conn.close()

                if not store_data:
                    messagebox.showerror("Error", "Store not found")
                    view_window.destroy()
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load store details: {str(e)}")
                view_window.destroy()
                return

            # Display store information
            main_frame = tk.Frame(view_window, bg='#f8f9fa', padx=30, pady=20)
            main_frame.pack(fill='both', expand=True)

            # Title
            tk.Label(main_frame, text=f"Store Details - ID: {store_id}",
                     font=('Arial', 18, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))

            # Store information frame with scrollable content
            canvas = tk.Canvas(main_frame, bg='#f8f9fa')
            scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg='#f8f9fa')

            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )

            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)

            # Parse contact information
            contact_data = {}
            try:
                contact_data = json.loads(store_data[2]) if store_data[2] else {}
            except:
                pass

            # Basic information section
            basic_frame = tk.LabelFrame(scrollable_frame, text="Basic Information",
                                        font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            basic_frame.pack(fill='x', pady=(0, 15), padx=10)

            basic_info = [
                ("Store Name:", store_data[0]),
                ("Location:", store_data[1]),
                ("Category:", contact_data.get('category', 'Not specified')),
                ("Status:", "Active" if store_data[3] else "Inactive"),
                ("Created Date:", store_data[4]),
                ("Operating Hours:", contact_data.get('hours', 'Not specified')),
                ("Currency:", contact_data.get('currency', 'FCFA'))
            ]

            for label_text, value in basic_info:
                info_frame = tk.Frame(basic_frame, bg='#f8f9fa')
                info_frame.pack(fill='x', padx=10, pady=3)

                tk.Label(info_frame, text=label_text, font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#2c3e50', width=20, anchor='w').pack(side='left')
                tk.Label(info_frame, text=str(value), font=('Arial', 11),
                         bg='#f8f9fa', fg='#34495e', wraplength=400).pack(side='left', padx=(10, 0))

            # Contact information section
            contact_frame = tk.LabelFrame(scrollable_frame, text="Contact Information",
                                          font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            contact_frame.pack(fill='x', pady=(0, 15), padx=10)

            contact_info = [
                ("Primary Phone:", contact_data.get('phone', 'Not provided')),
                ("Secondary Phone:", contact_data.get('phone2', 'Not provided')),
                ("Email:", contact_data.get('email', 'Not provided')),
                ("Full Address:", contact_data.get('address', 'Not provided')),
                ("GPS Coordinates:", contact_data.get('gps', 'Not provided'))
            ]

            for label_text, value in contact_info:
                info_frame = tk.Frame(contact_frame, bg='#f8f9fa')
                info_frame.pack(fill='x', padx=10, pady=3)

                tk.Label(info_frame, text=label_text, font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#2c3e50', width=20, anchor='w').pack(side='left')
                tk.Label(info_frame, text=str(value), font=('Arial', 11),
                         bg='#f8f9fa', fg='#34495e', wraplength=400).pack(side='left', padx=(10, 0))

            # Owner information section
            owner_frame = tk.LabelFrame(scrollable_frame, text="Owner Information",
                                        font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            owner_frame.pack(fill='x', pady=(0, 15), padx=10)

            owner_info = [
                ("Owner Name:", store_data[5]),
                ("Owner Email:", store_data[6]),
                ("Owner Phone:", store_data[7])
            ]

            for label_text, value in owner_info:
                info_frame = tk.Frame(owner_frame, bg='#f8f9fa')
                info_frame.pack(fill='x', padx=10, pady=3)

                tk.Label(info_frame, text=label_text, font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#2c3e50', width=20, anchor='w').pack(side='left')
                tk.Label(info_frame, text=str(value or 'Not provided'), font=('Arial', 11),
                         bg='#f8f9fa', fg='#34495e').pack(side='left', padx=(10, 0))

            # Manager information section
            manager_frame = tk.LabelFrame(scrollable_frame, text="Manager Information",
                                          font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            manager_frame.pack(fill='x', pady=(0, 15), padx=10)

            manager_info = [
                ("Manager Name:", store_data[8]),
                ("Manager Email:", store_data[9] or 'Not assigned')
            ]

            for label_text, value in manager_info:
                info_frame = tk.Frame(manager_frame, bg='#f8f9fa')
                info_frame.pack(fill='x', padx=10, pady=3)

                tk.Label(info_frame, text=label_text, font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#2c3e50', width=20, anchor='w').pack(side='left')
                tk.Label(info_frame, text=str(value), font=('Arial', 11),
                         bg='#f8f9fa', fg='#34495e').pack(side='left', padx=(10, 0))

            # Business information section
            business_frame = tk.LabelFrame(scrollable_frame, text="Business Information",
                                           font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            business_frame.pack(fill='x', pady=(0, 15), padx=10)

            business_info = [
                ("Registration Number:", contact_data.get('registration', 'Not provided')),
                ("Tax ID:", contact_data.get('tax_id', 'Not provided'))
            ]

            for label_text, value in business_info:
                info_frame = tk.Frame(business_frame, bg='#f8f9fa')
                info_frame.pack(fill='x', padx=10, pady=3)

                tk.Label(info_frame, text=label_text, font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#2c3e50', width=20, anchor='w').pack(side='left')
                tk.Label(info_frame, text=str(value), font=('Arial', 11),
                         bg='#f8f9fa', fg='#34495e').pack(side='left', padx=(10, 0))

            # Pack canvas and scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")

            # Close button
            tk.Button(main_frame, text="Close", font=('Arial', 12, 'bold'),
                      bg='#6c757d', fg='white', width=15,
                      command=view_window.destroy).pack(pady=20)

            # Mouse wheel scrolling
            def on_mousewheel(event):
                canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

            canvas.bind("<MouseWheel>", on_mousewheel)

        # Edit store function
        def edit_store():
            selected = stores_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a store to edit")
                return

            store_id = stores_tree.item(selected[0])['values'][0]

            # Check if user has permission to edit this store
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('SELECT owner_id, manager_id FROM stores WHERE id = ?', (store_id,))
                store_ownership = cursor.fetchone()

                if not store_ownership:
                    messagebox.showerror("Error", "Store not found")
                    conn.close()
                    return

                owner_id, manager_id = store_ownership

                # Check permissions
                if (self.current_user['role'] not in ['administrator'] and
                        owner_id != self.current_user['id'] and
                        manager_id != self.current_user['id']):
                    messagebox.showerror("Error", "You don't have permission to edit this store")
                    conn.close()
                    return

                conn.close()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to check permissions: {str(e)}")
                return

            # Load store data for editing
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT name, location, contact_info, is_active, manager_id
                               FROM stores
                               WHERE id = ?
                               ''', (store_id,))
                store_data = cursor.fetchone()
                conn.close()

                if not store_data:
                    messagebox.showerror("Error", "Store not found")
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load store data: {str(e)}")
                return

            # Create edit window
            edit_window = tk.Toplevel(manage_window)
            edit_window.title(f"Edit Store - {store_data[0]}")
            edit_window.geometry("700x600")
            edit_window.configure(bg='#34495e')
            edit_window.grab_set()
            edit_window.transient(manage_window)

            # Edit form
            form_frame = tk.Frame(edit_window, bg='#34495e', padx=30, pady=30)
            form_frame.pack(fill='both', expand=True)

            tk.Label(form_frame, text=f"Edit Store (ID: {store_id})",
                     font=('Arial', 16, 'bold'), bg='#34495e', fg='white').pack(pady=(0, 20))

            # Parse current contact info
            contact_data = {}
            try:
                contact_data = json.loads(store_data[2]) if store_data[2] else {}
            except:
                pass

            # Form fields
            edit_entries = {}

            # Store Name
            tk.Label(form_frame, text="Store Name:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))
            name_entry = tk.Entry(form_frame, font=('Arial', 11), width=50)
            name_entry.insert(0, store_data[0])
            name_entry.pack(pady=(0, 10))
            edit_entries['name'] = name_entry

            # Location
            tk.Label(form_frame, text="Location:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))
            location_entry = tk.Entry(form_frame, font=('Arial', 11), width=50)
            location_entry.insert(0, store_data[1])
            location_entry.pack(pady=(0, 10))
            edit_entries['location'] = location_entry

            # Category
            tk.Label(form_frame, text="Category:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))
            category_var = tk.StringVar(value=contact_data.get('category', ''))
            category_combo = ttk.Combobox(form_frame, textvariable=category_var, width=47, state='readonly')
            category_combo['values'] = [
                'General Building Materials', 'Cement & Concrete', 'Steel & Metal Products',
                'Timber & Wood Products', 'Roofing Materials', 'Plumbing & Electrical',
                'Paint & Finishes', 'Tools & Equipment', 'Wholesale Distributor', 'Retail Outlet', 'onside supply store'
            ]
            category_combo.pack(pady=(0, 10))
            edit_entries['category'] = category_combo

            # Phone
            tk.Label(form_frame, text="Primary Phone:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))
            phone_entry = tk.Entry(form_frame, font=('Arial', 11), width=50)
            try:
                phone_entry.insert(0, str(contact_data.get('phone', '') or ''))
            except Exception:
                phone_entry.insert(0, '')
            phone_entry.pack(pady=(0, 10))
            edit_entries['phone'] = phone_entry

            # Email
            tk.Label(form_frame, text="Email:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))
            email_entry = tk.Entry(form_frame, font=('Arial', 11), width=50)
            try:
                email_entry.insert(0, str(contact_data.get('email', '') or ''))
            except Exception:
                email_entry.insert(0, '')
            email_entry.pack(pady=(0, 10))
            edit_entries['email'] = email_entry

            # Manager selection (only for store owners and administrators)
            if (self.current_user['role'] == 'administrator' or
                    owner_id == self.current_user['id']):

                tk.Label(form_frame, text="Store Manager:", font=('Arial', 11),
                         bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))

                manager_var = tk.StringVar()
                manager_combo = ttk.Combobox(form_frame, textvariable=manager_var, width=47, state='readonly')

                # Load available managers
                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('''
                                   SELECT id, username, full_name
                                   FROM users
                                   WHERE role IN ('manager', 'retail_store')
                                     AND is_active = 1
                                   ORDER BY full_name
                                   ''')
                    managers = cursor.fetchall()
                    manager_options = ['None'] + [f"{m[0]} - {m[2]} ({m[1]})" for m in managers]
                    manager_combo['values'] = manager_options

                    # Set current manager
                    if store_data[4]:  # manager_id
                        for manager in managers:
                            if manager[0] == store_data[4]:
                                manager_combo.set(f"{manager[0]} - {manager[2]} ({manager[1]})")
                                break
                    else:
                        manager_combo.set('None')

                    conn.close()
                except:
                    manager_combo['values'] = ['None']
                    manager_combo.set('None')

                manager_combo.pack(pady=(0, 10))
                edit_entries['manager'] = manager_combo

            # Status
            tk.Label(form_frame, text="Store Status:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))

            active_var = tk.BooleanVar(value=store_data[3])
            tk.Checkbutton(form_frame, text="Store Active", variable=active_var,
                           bg='#34495e', fg='white', selectcolor='#2c3e50').pack(anchor='w', pady=(0, 15))
            edit_entries['is_active'] = active_var

            def save_changes():
                try:
                    # Get manager ID if changed
                    manager_id = store_data[4]  # Keep current manager by default
                    if 'manager' in edit_entries:
                        manager_selection = edit_entries['manager'].get()
                        if manager_selection == 'None':
                            manager_id = None
                        elif manager_selection and manager_selection != 'None':
                            manager_id = int(manager_selection.split(' - ')[0])

                    # Update contact info
                    updated_contact_data = contact_data.copy()
                    updated_contact_data.update({
                        'category': edit_entries['category'].get(),
                        'phone': edit_entries['phone'].get(),
                        'email': edit_entries['email'].get()
                    })

                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    cursor.execute('''
                                   UPDATE stores
                                   SET name         = ?,
                                       location     = ?,
                                       contact_info = ?,
                                       manager_id   = ?,
                                       is_active    = ?
                                   WHERE id = ?
                                   ''', (
                                       edit_entries['name'].get(),
                                       edit_entries['location'].get(),
                                       json.dumps(updated_contact_data),
                                       manager_id,
                                       edit_entries['is_active'].get(),
                                       store_id
                                   ))

                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        "Edit Store",
                        f"Modified store {edit_entries['name'].get()} (ID: {store_id})"
                    )

                    messagebox.showinfo("Success", "Store updated successfully!")
                    edit_window.destroy()
                    load_stores()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to update store: {str(e)}")

            # Buttons
            btn_frame = tk.Frame(form_frame, bg='#34495e')
            btn_frame.pack(pady=(20, 0))

            tk.Button(btn_frame, text="Save Changes", font=('Arial', 11, 'bold'),
                      bg='#27ae60', fg='white', width=15,
                      command=save_changes).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Cancel", font=('Arial', 11),
                      bg='#e74c3c', fg='white', width=15,
                      command=edit_window.destroy).pack(side='left')

        # Toggle store status function
        def toggle_status():
            selected = stores_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a store to toggle status")
                return

            store_id = stores_tree.item(selected[0])['values'][0]
            store_name = stores_tree.item(selected[0])['values'][1]
            current_status = stores_tree.item(selected[0])['values'][7]

            # Check permissions
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('SELECT owner_id FROM stores WHERE id = ?', (store_id,))
                owner_id = cursor.fetchone()[0]

                if (self.current_user['role'] not in ['administrator'] and
                        owner_id != self.current_user['id']):
                    messagebox.showerror("Error", "You don't have permission to change this store's status")
                    conn.close()
                    return

                conn.close()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to check permissions: {str(e)}")
                return

            new_status = "Inactive" if current_status == "Active" else "Active"
            new_status_bool = new_status == "Active"

            if messagebox.askyesno("Confirm Status Change",
                                   f"Change store '{store_name}' status to {new_status}?"):
                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('UPDATE stores SET is_active = ? WHERE id = ?',
                                   (new_status_bool, store_id))
                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        "Toggle Store Status",
                        f"Changed store {store_name} status to {new_status}"
                    )

                    messagebox.showinfo("Success", f"Store status changed to {new_status}")
                    load_stores()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to update status: {str(e)}")

        # Delete store function disabled by policy
        def delete_store():
            try:
                messagebox.showinfo("Store", "Store deletion is disabled by policy. You can deactivate a store instead.")
            except Exception:
                pass
            return

        # Assign manager to store
        def assign_manager():
            sel = stores_tree.selection()
            if not sel:
                messagebox.showwarning("Assign Manager", "Please select a store first.")
                return
            store_id = stores_tree.item(sel[0])['values'][0]
            store_name = stores_tree.item(sel[0])['values'][1]
            try:
                conn = self.db_manager.create_connection(); cur = conn.cursor()
                cur.execute("SELECT owner_id, manager_id FROM stores WHERE id=?", (store_id,))
                row = cur.fetchone()
                if not row:
                    conn.close(); messagebox.showerror("Assign Manager", "Store not found"); return
                owner_id, current_manager_id = row
                if self.current_user.get('role') != 'administrator' and owner_id != self.current_user['id']:
                    conn.close(); messagebox.showerror("Assign Manager", "You don't have permission to assign a manager for this store"); return
                q = "SELECT id, full_name, username FROM users WHERE role = 'manager' AND is_active = 1 "
                params = []
                try:
                    if self.current_user.get('role') != 'administrator':
                        q += "AND created_by = ? "
                        params.append(self.current_user['id'])
                except Exception:
                    pass
                q += "ORDER BY full_name"
                cur.execute(q, params)
                managers = cur.fetchall()
                conn.close()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load managers: {str(e)}"); return
            dlg = tk.Toplevel(manage_window); dlg.title(f"Assign Manager - {store_name}"); dlg.geometry("420x180"); dlg.configure(bg='white'); dlg.grab_set(); dlg.transient(manage_window)
            tk.Label(dlg, text=f"Store: {store_name} (ID:{store_id})", bg='white', font=('Arial',11,'bold')).pack(anchor='w', padx=10, pady=(10,4))
            tk.Label(dlg, text="Select Manager:", bg='white').pack(anchor='w', padx=10)
            var = tk.StringVar(); cb = ttk.Combobox(dlg, textvariable=var, state='readonly'); cb.pack(fill='x', padx=10, pady=6)
            values = [f"{m[0]} - {m[1]} ({m[2]})" for m in managers] if managers else []
            cb['values'] = values
            if current_manager_id and managers:
                for m in managers:
                    if m[0] == current_manager_id:
                        cb.set(f"{m[0]} - {m[1]} ({m[2]})"); break
            elif values:
                cb.set(values[0])
            def save():
                if not var.get():
                    messagebox.showwarning("Assign Manager", "Please select a manager."); return
                try:
                    mid = int(var.get().split(' - ')[0])
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("UPDATE stores SET manager_id=? WHERE id=?", (mid, store_id))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Assign Manager", json.dumps({"store_id": store_id, "manager_id": mid}))
                    except Exception:
                        pass
                    messagebox.showinfo("Assigned", f"Manager assigned to '{store_name}'.")
                    dlg.destroy(); load_stores()
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to assign manager: {str(e)}")
            tk.Button(dlg, text="Save", bg="#27ae60", fg="white", command=save).pack(pady=(0,8))
            tk.Button(dlg, text="Cancel", command=dlg.destroy).pack()

        # Unassign manager from store
        def unassign_manager():
            sel = stores_tree.selection()
            if not sel:
                messagebox.showwarning("Unassign Manager", "Please select a store first."); return
            store_id = stores_tree.item(sel[0])['values'][0]
            store_name = stores_tree.item(sel[0])['values'][1]
            try:
                conn = self.db_manager.create_connection(); cur = conn.cursor()
                cur.execute("SELECT owner_id, manager_id FROM stores WHERE id=?", (store_id,))
                row = cur.fetchone()
                if not row:
                    conn.close(); messagebox.showerror("Unassign Manager", "Store not found"); return
                owner_id, manager_id = row
                if self.current_user.get('role') != 'administrator' and owner_id != self.current_user['id']:
                    conn.close(); messagebox.showerror("Unassign Manager", "You don't have permission to unassign the manager for this store"); return
                if not manager_id:
                    conn.close(); messagebox.showinfo("Unassign Manager", "No manager is currently assigned."); return
                conn.close()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to check permissions: {str(e)}"); return
            if not messagebox.askyesno("Confirm", f"Remove manager from '{store_name}'?"):
                return
            try:
                conn = self.db_manager.create_connection(); cur = conn.cursor()
                cur.execute("UPDATE stores SET manager_id=NULL WHERE id=?", (store_id,))
                conn.commit(); conn.close()
                try:
                    self.log_audit_action(self.current_user['id'], "Unassign Manager", json.dumps({"store_id": store_id}))
                except Exception:
                    pass
                messagebox.showinfo("Success", "Manager unassigned.")
                load_stores()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to unassign manager: {str(e)}")

        # Export stores function
        def export_stores():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".csv",
                    filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                    title="Export Stores Data"
                )

                if filename:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    # Build export query based on current filters
                    query = '''
                            SELECT s.id,
                                   s.name,
                                   owner.full_name,
                                   COALESCE(manager.full_name, 'Not Assigned'),
                                   s.location,
                                   s.contact_info,
                                   CASE WHEN s.is_active = 1 THEN 'Active' ELSE 'Inactive' END,
                                   s.created_date
                            FROM stores s
                                     JOIN users owner ON s.owner_id = owner.id
                                     LEFT JOIN users manager ON s.manager_id = manager.id
                            '''

                    # Apply same filters as current view
                    search_text = search_var.get().strip()
                    status_filter_text = status_filter_var.get()
                    region_filter_text = region_filter_var.get()

                    params = []
                    where_conditions = []

                    if self.current_user['role'] == 'retail_store':
                        where_conditions.append('s.owner_id = ?')
                        params.append(self.current_user['id'])
                    elif self.current_user['role'] == 'manager':
                        where_conditions.append('s.manager_id = ?')
                        params.append(self.current_user['id'])

                    if search_text:
                        where_conditions.append('(s.name LIKE ? OR s.location LIKE ? OR owner.full_name LIKE ?)')
                        search_pattern = f'%{search_text}%'
                        params.extend([search_pattern, search_pattern, search_pattern])

                    if status_filter_text == 'Active':
                        where_conditions.append('s.is_active = 1')
                    elif status_filter_text == 'Inactive':
                        where_conditions.append('s.is_active = 0')

                    if region_filter_text != 'All':
                        where_conditions.append('s.location LIKE ?')
                        params.append(f'%{region_filter_text}%')

                    if where_conditions:
                        query += ' WHERE ' + ' AND '.join(where_conditions)

                    query += ' ORDER BY s.created_date DESC'

                    cursor.execute(query, params)
                    stores_data = cursor.fetchall()

                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerow(['Store ID', 'Store Name', 'Owner', 'Manager', 'Location',
                                         'Category', 'Phone', 'Email', 'Status', 'Created Date'])

                        for row in stores_data:
                            # Parse contact info for export
                            contact_data = {}
                            try:
                                contact_data = json.loads(row[5]) if row[5] else {}
                            except:
                                pass

                            export_row = [
                                row[0], row[1], row[2], row[3], row[4],
                                contact_data.get('category', ''),
                                contact_data.get('phone', ''),
                                contact_data.get('email', ''),
                                row[6], row[7]
                            ]
                            writer.writerow(export_row)

                    conn.close()
                    messagebox.showinfo("Success", f"Stores data exported to {filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to export stores: {str(e)}")

        # Store analytics function
        def show_analytics():
            selected = stores_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a store to view analytics")
                return

            store_id = stores_tree.item(selected[0])['values'][0]
            try:
                # Open the advanced analytics view with the selected store pre-filtered
                self.show_store_analytics(preselected_store_id=store_id)
                try:
                    self.log_audit_action(self.current_user['id'], "Open Store Analytics", json.dumps({"store_id": store_id}))
                except Exception:
                    pass
            except Exception as e:
                try:
                    messagebox.showerror("Store Analytics", f"Failed to open analytics: {str(e)}")
                except Exception:
                    pass

        # Store report function
        def generate_store_report():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
                    title="Save Store Report"
                )

                if filename:
                    from datetime import datetime

                    # Get current statistics
                    total_stores = int(total_stores_label.cget('text').split(': ')[1])
                    active_stores = int(active_stores_label.cget('text').split(': ')[1])
                    inactive_stores = int(inactive_stores_label.cget('text').split(': ')[1])
                    my_stores = int(my_stores_label.cget('text').split(': ')[1])

                    report_content = f"""
    STORE MANAGEMENT REPORT

    Generated by: {self.current_user['full_name']}
    Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    User Role: {self.current_user['role'].replace('_', ' ').title()}

    SUMMARY STATISTICS:
    Total Stores: {total_stores}
    Active Stores: {active_stores}
    Inactive Stores: {inactive_stores}
    My Stores: {my_stores}

    STORE LISTINGS:
    Store ID | Name | Owner | Manager | Location | Status
    {'-' * 80}
    """

                    # Add store details
                    for item in stores_tree.get_children():
                        values = stores_tree.item(item)['values']
                        store_line = f"{values[0]} | {values[1]} | {values[2]} | {values[3]} | {values[4]} | {values[7]}\n"
                        report_content += store_line

                    report_content += f"""

    ANALYSIS:
    • Active Rate: {(active_stores / max(total_stores, 1)) * 100:.1f}%
    • Regional Distribution: Based on location data
    • Management Coverage: {((total_stores - sum(1 for item in stores_tree.get_children() if 'Not Assigned' in stores_tree.item(item)['values'][3])) / max(total_stores, 1)) * 100:.1f}% of stores have assigned managers

    RECOMMENDATIONS:
    • Ensure all active stores have assigned managers
    • Review inactive stores for reactivation potential
    • Monitor store performance regularly
    • Maintain updated contact information

    ---
    This report was generated by the Cameroon Building Project Management System.
                    """

                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(report_content)

                    messagebox.showinfo("Success", f"Store report saved to {filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to generate report: {str(e)}")

        # Manage inventory function
        def manage_inventory():
            selected = stores_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a store to manage inventory")
                return

            store_id = stores_tree.item(selected[0])['values'][0]
            store_name = stores_tree.item(selected[0])['values'][1]

            # Check permissions
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('SELECT owner_id, manager_id FROM stores WHERE id = ?', (store_id,))
                store_ownership = cursor.fetchone()
                owner_id, manager_id = store_ownership

                if (self.current_user['role'] not in ['administrator'] and
                        owner_id != self.current_user['id'] and
                        manager_id != self.current_user['id']):
                    messagebox.showwarning("Access Denied",
                                           "You don't have permission to manage this store's inventory")
                    conn.close()
                    return

                conn.close()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to check permissions: {str(e)}")
                return

            # Open the full Inventory Overview for this store (with safe fallbacks)
            try:
                # Prefer an advanced inventory view if available
                if hasattr(self, 'open_view_inventory'):
                    self.open_view_inventory(preselected_store_id=store_id)
                elif hasattr(self, 'show_view_inventory'):
                    self.show_view_inventory(preselected_store_id=store_id)
                else:
                    # Fallback to the basic inventory manager
                    self.show_inventory(preselected_store_id=store_id)
                try:
                    self.log_audit_action(self.current_user['id'], "Access Inventory", f"Opened inventory management interface for store {store_id}")
                except Exception:
                    pass
            except Exception as e:
                try:
                    messagebox.showerror("Inventory", f"Failed to open Inventory: {str(e)}")
                except Exception:
                    pass

        # View inventory (detailed) for selected store
        def view_inventory_for_selected_store():
            sel = stores_tree.selection()
            if not sel:
                messagebox.showwarning("View Inventory", "Please select a store first.")
                return
            try:
                store_id = stores_tree.item(sel[0])['values'][0]
                # Use safe wrapper to avoid AttributeError if method is not bound
                if hasattr(self, 'open_view_inventory'):
                    return self.open_view_inventory(preselected_store_id=store_id)
                elif hasattr(self, 'show_view_inventory'):
                    return self.show_view_inventory(preselected_store_id=store_id)
                else:
                    messagebox.showinfo("View Inventory", "Inventory overview is unavailable in this build.")
            except Exception as e:
                try:
                    messagebox.showerror("View Inventory", f"Failed to open: {str(e)}")
                except Exception:
                    pass

        # Helper to buy materials for selected store
        def buy_materials_for_selected_store():
            sel = stores_tree.selection()
            if not sel:
                messagebox.showwarning("Buy Materials", "Please select a store first.")
                return
            store_id = stores_tree.item(sel[0])['values'][0]
            # Ensure user is a Contract Owner of this store
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                cur.execute("SELECT owner_id, is_active FROM stores WHERE id=?", (store_id,))
                row = cur.fetchone()
                conn.close()
                if not row:
                    messagebox.showerror("Store", "Selected store not found")
                    return
                owner_id, is_active = row
                if self.current_user.get('role') != 'contract_owner' or owner_id != self.current_user['id'] or not is_active:
                    messagebox.showwarning("Access Denied", "You can only buy materials for your own active stores.")
                    return
                self.show_buy_materials(preselected_store_id=store_id)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to open Buy Materials: {str(e)}")

        # Bind button commands
        new_store_btn.config(command=new_store)
        view_btn.config(command=view_store)
        edit_btn.config(command=edit_store)
        assign_btn.config(command=assign_manager)
        unassign_btn.config(command=unassign_manager)
        inventory_btn.config(command=manage_inventory)
        view_inventory_btn.config(command=view_inventory_for_selected_store)
        if 'buy_btn' in locals() and buy_btn is not None:
            buy_btn.config(command=buy_materials_for_selected_store)
        analytics_btn.config(command=show_analytics)
        toggle_status_btn.config(command=toggle_status)
        # delete_btn removed; deletion disabled by policy
        export_btn.config(command=export_stores)
        report_btn.config(command=generate_store_report)
        refresh_btn.config(command=load_stores)

        # Bind search and filter events
        def on_filter_change(*args):
            load_stores()

        search_var.trace('w', on_filter_change)
        status_filter_var.trace('w', on_filter_change)
        region_filter_var.trace('w', on_filter_change)

        # Double-click to view details
        stores_tree.bind('<Double-1>', lambda e: view_store())

        # Right-click context menu
        def show_context_menu(event):
            selection = stores_tree.selection()
            if selection:
                context_menu = tk.Menu(manage_window, tearoff=0)
                context_menu.add_command(label="View Details", command=view_store)
                context_menu.add_command(label="Edit Store", command=edit_store)
                context_menu.add_command(label="Assign Manager", command=assign_manager)
                context_menu.add_command(label="Unassign Manager", command=unassign_manager)
                context_menu.add_separator()
                context_menu.add_command(label="View Inventory", command=view_inventory_for_selected_store)
                context_menu.add_command(label="Manage Inventory", command=manage_inventory)
                # Buy Materials appears only for Contract Owners
                if self.current_user.get('role') == 'contract_owner':
                    context_menu.add_command(label="Buy Materials", command=buy_materials_for_selected_store)
                context_menu.add_command(label="Store Analytics", command=show_analytics)
                context_menu.add_separator()
                context_menu.add_command(label="Toggle Status", command=toggle_status)
                # context_menu.add_command(label="Delete Store", command=delete_store)  # Disabled by policy

                try:
                    context_menu.tk_popup(event.x_root, event.y_root)
                finally:
                    context_menu.grab_release()

        stores_tree.bind("<Button-3>", show_context_menu)  # Right-click

        # Keyboard shortcuts
        manage_window.bind('<F5>', lambda e: load_stores())
        manage_window.bind('<Escape>', lambda e: manage_window.destroy())
        # manage_window.bind('<Delete>', lambda e: delete_store())  # Disabled by policy

        # Initial load
        load_stores()

        # Log the action
        self.log_audit_action(
            self.current_user['id'],
            "Access Store Management",
            "Opened store management interface"
        )


# ======================== show inventory details ======================== #
    def show_inventory(self, preselected_store_id=None):
        """Display the Inventory Management window.

        Args:
            preselected_store_id (Optional[int]): If provided, filters the inventory to a
                specific store owned/managed by the current user.

        Raises:
            tk.TclError: If the Tkinter root window is not available.
        """
        try:
            # Open a simple Inventory Management window with a list and basic CRUD
            inv_window = tk.Toplevel(self.root)
            inv_window.title("Inventory Management")
            inv_window.geometry("1000x600")
            inv_window.configure(bg='white')
            inv_window.grab_set()

            header = tk.Frame(inv_window, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Inventory Management", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Search
            search_frame = tk.Frame(inv_window, bg='white')
            search_frame.pack(fill='x', padx=10)
            tk.Label(search_frame, text="Search:", bg='white').pack(side='left')
            search_var = tk.StringVar()
            search_entry = tk.Entry(search_frame, textvariable=search_var, width=40)
            search_entry.pack(side='left', padx=5)
            def do_search(*args):
                load_inventory()
            search_var.trace('w', lambda *a: do_search())

            # Treeview
            tree_frame = tk.Frame(inv_window, bg='white')
            tree_frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Store","Material","Quantity","Unit Price","Reorder","Last Updated")
            inv_tree = ttk.Treeview(tree_frame, columns=cols, show='headings')
            for c in cols:
                inv_tree.heading(c, text=c)
                inv_tree.column(c, width=120)
            inv_tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(tree_frame, orient='vertical', command=inv_tree.yview)
            sx = ttk.Scrollbar(tree_frame, orient='horizontal', command=inv_tree.xview)
            inv_tree.configure(yscrollcommand=sy.set, xscrollcommand=sx.set)
            sy.pack(side='right', fill='y')
            sx.pack(side='bottom', fill='x')

            # Summary footer
            summary = tk.Frame(inv_window, bg='white')
            summary.pack(fill='x', padx=10, pady=(0,6))
            total_items_var = tk.StringVar(value='0')
            total_qty_var = tk.StringVar(value='0')
            total_value_var = tk.StringVar(value='0')
            tk.Label(summary, text="Items:", bg='white').pack(side='left')
            tk.Label(summary, textvariable=total_items_var, bg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=(3, 12))
            tk.Label(summary, text="Total Qty:", bg='white').pack(side='left')
            tk.Label(summary, textvariable=total_qty_var, bg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=(3, 12))
            tk.Label(summary, text="Total Value (FCFA):", bg='white').pack(side='left')
            tk.Label(summary, textvariable=total_value_var, bg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=4)

            # Buttons
            btns = tk.Frame(inv_window, bg='white')
            btns.pack(fill='x', padx=10, pady=(0,10))

            def load_inventory():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    query = '''
                        SELECT i.id, s.name AS store, bm.name AS material, i.quantity, i.unit_price, i.reorder_level, i.last_updated
                        FROM inventory i
                        JOIN stores s ON s.id = i.store_id
                        JOIN building_materials bm ON bm.id = i.material_id
                    '''
                    params = []
                    where_clauses = []
                    # Enforce single-store view if a store was preselected by caller
                    if preselected_store_id is not None:
                        where_clauses.append('i.store_id = ?')
                        params.append(preselected_store_id)
                    # Role-based store visibility for inventory listing
                    try:
                        role = self.current_user.get('role') if self.current_user else None
                        if role in ('retail_store','contract_owner'):
                            where_clauses.append('s.owner_id = ?')
                            params.append(self.current_user['id'])
                        elif role == 'manager':
                            where_clauses.append('s.manager_id = ?')
                            params.append(self.current_user['id'])
                    except Exception:
                        pass
                    if search_var.get().strip():
                        where_clauses.append('(bm.name LIKE ? OR s.name LIKE ?)')
                        like = f"%{search_var.get().strip()}%"
                        params.extend([like, like])
                    if where_clauses:
                        query += ' WHERE ' + ' AND '.join(where_clauses)
                    query += ' ORDER BY i.last_updated DESC'
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    # Populate table
                    for item in inv_tree.get_children():
                        inv_tree.delete(item)
                    total_qty_sum = 0.0
                    total_value_sum = 0.0
                    for r in rows:
                        inv_tree.insert('', 'end', values=r)
                        try:
                            q = float(r[3] or 0)
                        except Exception:
                            q = 0.0
                        try:
                            up = float(r[4] or 0)
                        except Exception:
                            up = 0.0
                        total_qty_sum += q
                        total_value_sum += (q * up)
                    # Update summary footer
                    try:
                        # Items count
                        total_items_var.set(str(len(rows)))
                        # Quantity formatting: show integer when applicable
                        if float(total_qty_sum).is_integer():
                            total_qty_var.set(str(int(total_qty_sum)))
                        else:
                            total_qty_var.set(str(total_qty_sum))
                        # Value formatting with thousands separators
                        total_value_var.set(f"{float(total_value_sum):,.0f}")
                    except Exception:
                        pass
                    conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to load inventory: {str(e)}")
                    except Exception:
                        pass

            def add_item():
                dlg = tk.Toplevel(inv_window)
                dlg.title("Add Inventory Item")
                dlg.geometry("400x350")
                dlg.configure(bg='white')
                dlg.grab_set()
                tk.Label(dlg, text="Store:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                store_var = tk.StringVar()
                store_cb = ttk.Combobox(dlg, textvariable=store_var, state='readonly')
                store_cb.pack(fill='x', padx=10)
                tk.Label(dlg, text="Material:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                mat_var = tk.StringVar()
                mat_cb = ttk.Combobox(dlg, textvariable=mat_var, state='readonly')
                mat_cb.pack(fill='x', padx=10)
                # Allow retail owners to create a custom material scoped to their stores
                def create_custom_material():
                    try:
                        if not self.current_user or self.current_user.get('role') != 'retail_store':
                            messagebox.showinfo("Custom Material", "Only retail store owners can create custom materials.")
                            return
                        cm = tk.Toplevel(dlg)
                        cm.title("Create Custom Material")
                        cm.geometry("420x360")
                        cm.configure(bg='white')
                        cm.grab_set()
                        frm = tk.Frame(cm, bg='white'); frm.pack(fill='both', expand=True, padx=12, pady=12)
                        def row(lbl):
                            f = tk.Frame(frm, bg='white'); f.pack(fill='x', pady=4)
                            tk.Label(f, text=lbl, bg='white').pack(side='left', padx=(0,6))
                            e = tk.Entry(f); e.pack(side='left', fill='x', expand=True)
                            return e
                        name_e = row("Name*")
                        cat_e = row("Category")
                        unit_e = row("Unit")
                        price_e = row("Std Price")
                        supp_e = row("Supplier")
                        desc_e = row("Description")
                        def save_custom():
                            name = name_e.get().strip()
                            if not name:
                                messagebox.showwarning("Validation", "Name is required.")
                                return
                            category = cat_e.get().strip() or 'Other'
                            unit = unit_e.get().strip() or 'Piece'
                            try:
                                sp = float((price_e.get() or '0').replace(',', ''))
                            except Exception:
                                sp = 0.0
                            supplier = supp_e.get().strip() or None
                            desc = desc_e.get().strip() or None
                            try:
                                conn2 = self.db_manager.create_connection(); cur2 = conn2.cursor()
                                cur2.execute(
                                    """
                                    INSERT INTO building_materials (name, category, unit, standard_price, supplier, description, local_name, availability, created_date, is_custom, owner_id)
                                    VALUES (?, ?, ?, ?, ?, ?, NULL, 'Available', ?, 1, ?)
                                    """,
                                    (name, category, unit, sp, supplier, desc, date.today().isoformat(), self.current_user['id'])
                                )
                                new_id = cur2.lastrowid
                                conn2.commit(); conn2.close()
                                # Refresh materials list and select new
                                try:
                                    conn3 = self.db_manager.create_connection(); c3 = conn3.cursor()
                                    c3.execute("SELECT id, name FROM building_materials WHERE owner_id IS NULL OR owner_id = ? ORDER BY name", (self.current_user['id'],))
                                    new_mats = c3.fetchall(); conn3.close()
                                    mat_cb['values'] = [f"{mid} - {nm}" for mid, nm in new_mats]
                                    # Select newly created
                                    for mid, nm in new_mats:
                                        if mid == new_id:
                                            mat_var.set(f"{mid} - {nm}"); break
                                except Exception:
                                    pass
                                try:
                                    self.log_audit_action(self.current_user['id'], "Create Custom Material", name)
                                except Exception:
                                    pass
                                messagebox.showinfo("Created", "Custom material added.")
                                cm.destroy()
                            except Exception as e:
                                try:
                                    messagebox.showerror("Error", f"Failed to create: {str(e)}")
                                except Exception:
                                    pass
                        btnf = tk.Frame(frm, bg='white'); btnf.pack(fill='x', pady=8)
                        tk.Button(btnf, text="Save", bg="#27ae60", fg="white", command=save_custom).pack(side='left')
                        tk.Button(btnf, text="Cancel", command=cm.destroy).pack(side='right')
                    except Exception:
                        pass
                if self.current_user and self.current_user.get('role') == 'retail_store':
                    tk.Button(dlg, text="Create Custom Material", bg="#8e44ad", fg="white", command=create_custom_material).pack(anchor='w', padx=10, pady=6)
                tk.Label(dlg, text="Quantity:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                qty_var = tk.StringVar()
                tk.Entry(dlg, textvariable=qty_var).pack(fill='x', padx=10)
                tk.Label(dlg, text="Unit Price:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                price_var = tk.StringVar()
                tk.Entry(dlg, textvariable=price_var).pack(fill='x', padx=10)
                tk.Label(dlg, text="Reorder Level:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                reorder_var = tk.StringVar(value='10')
                tk.Entry(dlg, textvariable=reorder_var).pack(fill='x', padx=10)

                # populate stores and materials
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    role = self.current_user.get('role') if self.current_user else None
                    params = []
                    query = "SELECT id, name FROM stores WHERE is_active=1"
                    if role in ('retail_store','contract_owner'):
                        query += " AND owner_id = ?"; params.append(self.current_user['id'])
                    elif role == 'manager':
                        query += " AND manager_id = ?"; params.append(self.current_user['id'])
                    # administrators see all active stores
                    query += " ORDER BY name"
                    cur.execute(query, params)
                    stores = cur.fetchall()
                    # Load materials with ownership rules
                    role = self.current_user.get('role') if self.current_user else None
                    if role == 'administrator':
                        cur.execute("SELECT id, name FROM building_materials ORDER BY name")
                        mats = cur.fetchall()
                    elif role == 'retail_store':
                        cur.execute("SELECT id, name FROM building_materials WHERE owner_id IS NULL OR owner_id = ? ORDER BY name", (self.current_user['id'],))
                        mats = cur.fetchall()
                    else:
                        # Managers and others: only global materials
                        cur.execute("SELECT id, name FROM building_materials WHERE owner_id IS NULL ORDER BY name")
                        mats = cur.fetchall()
                    conn.close()
                    store_cb['values'] = [f"{sid} - {nm}" for sid,nm in stores]
                    mat_cb['values'] = [f"{mid} - {nm}" for mid,nm in mats]
                except Exception:
                    pass

                # Auto-fill price when a material is selected (prefers existing store price; falls back to standard price)
                def _autofill_price(*_):
                    try:
                        sel_store = store_var.get().strip()
                        sel_mat = mat_var.get().strip()
                        if not sel_store or not sel_mat:
                            return
                        sid = int(sel_store.split(' - ')[0])
                        mid = int(sel_mat.split(' - ')[0])
                        conn4 = self.db_manager.create_connection(); cur4 = conn4.cursor()
                        # 1) Try current inventory price for this store-material
                        cur4.execute("SELECT unit_price FROM inventory WHERE store_id=? AND material_id=?", (sid, mid))
                        r = cur4.fetchone()
                        if r and r[0] is not None:
                            try:
                                price_var.set(str(int(float(r[0]))))
                            except Exception:
                                price_var.set(str(r[0]))
                            conn4.close(); return
                        # 2) Fallback to standard price from materials catalog
                        cur4.execute("SELECT standard_price FROM building_materials WHERE id=?", (mid,))
                        r2 = cur4.fetchone(); conn4.close()
                        if r2 and r2[0] is not None:
                            try:
                                price_var.set(str(int(float(r2[0]))))
                            except Exception:
                                price_var.set(str(r2[0]))
                    except Exception:
                        pass
                try:
                    mat_cb.bind('<<ComboboxSelected>>', _autofill_price)
                except Exception:
                    pass
                # Trigger once for initial defaults
                try:
                    if store_cb.get() and mat_cb.get():
                        _autofill_price()
                except Exception:
                    pass

                def save():
                    try:
                        def safe_float(s, default=0.0):
                            try:
                                if s is None:
                                    return default
                                s = str(s).strip()
                                if s == "":
                                    return default
                                # Remove common formatting: commas, currency symbols and spaces
                                s = s.replace(",", "").replace("$", "").replace("₦", "").replace("£", "").replace("€", "").strip()
                                return float(s)
                            except Exception:
                                return default
                        if not store_var.get() or not mat_var.get():
                            messagebox.showwarning("Validation", "Please select a store and a material.")
                            return
                        try:
                            sid = int(store_var.get().split(' - ')[0])
                            mid = int(mat_var.get().split(' - ')[0])
                        except Exception:
                            messagebox.showwarning("Validation", "Invalid store or material selection.")
                            return
                        qty = safe_float(qty_var.get(), 0.0)
                        price = safe_float(price_var.get(), 0.0)
                        reorder = safe_float(reorder_var.get(), 10.0)
                        conn = self.db_manager.create_connection()
                        cur = conn.cursor()
                        # Enforce permissions by role
                        role = self.current_user.get('role') if self.current_user else None
                        if role in ('retail_store','contract_owner'):
                            cur.execute('SELECT 1 FROM stores WHERE id=? AND owner_id=?', (sid, self.current_user['id']))
                            if not cur.fetchone():
                                conn.close()
                                messagebox.showerror("Permission", "You can only add materials to stores you own.")
                                return
                        elif role == 'manager':
                            cur.execute('SELECT 1 FROM stores WHERE id=? AND manager_id=?', (sid, self.current_user['id']))
                            if not cur.fetchone():
                                conn.close()
                                messagebox.showerror("Permission", "You can only add materials to stores you manage.")
                                return
                        # Check for duplicate inventory (same store and material)
                        cur.execute('SELECT 1 FROM inventory WHERE store_id=? AND material_id=?', (sid, mid))
                        if cur.fetchone():
                            # Item exists: offer to add to existing stock instead of blocking
                            cur.execute('SELECT id, quantity, unit_price, reorder_level FROM inventory WHERE store_id=? AND material_id=?', (sid, mid))
                            row = cur.fetchone()
                            inv_id, exist_qty, exist_price, exist_reorder = row[0], float(row[1] or 0), row[2], row[3]
                            if qty <= 0:
                                conn.close()
                                messagebox.showwarning("Duplicate Item", "This item is already in the store. Enter a positive quantity to add to existing stock.")
                                return
                            if messagebox.askyesno("Item Exists", f"This material already exists with quantity {exist_qty}.\n\nAdd {qty} to it?"):
                                # Determine updates
                                new_qty = exist_qty + qty
                                new_price = price if price and float(price) > 0 else exist_price
                                try:
                                    new_reorder = reorder if reorder is not None and float(reorder) >= 0 else exist_reorder
                                except Exception:
                                    new_reorder = exist_reorder
                                cur.execute('UPDATE inventory SET quantity=?, unit_price=?, reorder_level=?, last_updated=? WHERE id=?',
                                            (new_qty, new_price, new_reorder, datetime.now(), inv_id))
                                conn.commit()
                                conn.close()
                                try:
                                    self.log_audit_action(self.current_user['id'], "Increase Inventory", f"Store {sid}, Material {mid}, +{qty}")
                                except Exception:
                                    pass
                                dlg.destroy()
                                load_inventory()
                                return
                            else:
                                conn.close()
                                return
                        # Not a duplicate: insert new record
                        try:
                            cur.execute('''INSERT INTO inventory(store_id, material_id, quantity, unit_price, reorder_level, last_updated)
                                           VALUES(?,?,?,?,?,?)''', (sid, mid, qty, price, reorder, datetime.now()))
                            conn.commit()
                        except sqlite3.IntegrityError:
                            # In case a UNIQUE index enforces this at DB level
                            conn.close()
                            messagebox.showerror("Duplicate", "This material already exists in the selected store's inventory.")
                            return
                        conn.close()
                        try:
                            self.log_audit_action(self.current_user['id'], "Add Inventory", f"Store {sid}, Material {mid}, Qty {qty}")
                        except Exception:
                            pass
                        dlg.destroy()
                        load_inventory()
                    except Exception as e:
                        messagebox.showerror("Error", f"Failed to save item: {str(e)}")

                tk.Button(dlg, text="Save", bg="#27ae60", fg="white", command=save).pack(pady=10)
                tk.Button(dlg, text="Cancel", command=dlg.destroy).pack()

            def edit_item():
                sel = inv_tree.selection()
                if not sel:
                    messagebox.showwarning("Warning", "Select an item to edit")
                    return
                values = inv_tree.item(sel[0])['values']
                item_id = values[0]
                dlg = tk.Toplevel(inv_window)
                dlg.title("Edit Inventory Item")
                dlg.geometry("400x320")
                dlg.configure(bg='white')
                dlg.grab_set()
                tk.Label(dlg, text=f"Editing Item ID {item_id}", bg='white', font=('Arial', 11, 'bold')).pack(anchor='w', padx=10, pady=(10,0))
                tk.Label(dlg, text="Quantity:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                qty_var = tk.StringVar(value=str(values[3]))
                tk.Entry(dlg, textvariable=qty_var).pack(fill='x', padx=10)
                tk.Label(dlg, text="Unit Price:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                price_var = tk.StringVar(value=str(values[4]))
                tk.Entry(dlg, textvariable=price_var).pack(fill='x', padx=10)
                tk.Label(dlg, text="Reorder Level:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                reorder_var = tk.StringVar(value=str(values[5]))
                tk.Entry(dlg, textvariable=reorder_var).pack(fill='x', padx=10)
                def save():
                    try:
                        def safe_float(s, default=0.0):
                            try:
                                if s is None:
                                    return default
                                s = str(s).strip()
                                if s == "":
                                    return default
                                s = s.replace(",", "").replace("$", "").replace("₦", "").replace("£", "").replace("€", "").strip()
                                return float(s)
                            except Exception:
                                return default
                        qty = safe_float(qty_var.get(), 0.0)
                        price = safe_float(price_var.get(), 0.0)
                        reorder = safe_float(reorder_var.get(), 10.0)
                        conn = self.db_manager.create_connection()
                        cur = conn.cursor()
                        # Enforce permissions by role on the item's store
                        role = self.current_user.get('role') if self.current_user else None
                        if role in ('retail_store','contract_owner'):
                            cur.execute('''SELECT 1
                                           FROM inventory i JOIN stores s ON s.id=i.store_id
                                           WHERE i.id=? AND s.owner_id=?''', (item_id, self.current_user['id']))
                            if not cur.fetchone():
                                conn.close()
                                messagebox.showerror("Permission", "You can only edit items in stores you own.")
                                return
                        elif role == 'manager':
                            cur.execute('''SELECT 1
                                           FROM inventory i JOIN stores s ON s.id=i.store_id
                                           WHERE i.id=? AND s.manager_id=?''', (item_id, self.current_user['id']))
                            if not cur.fetchone():
                                conn.close()
                                messagebox.showerror("Permission", "You can only edit items in stores you manage.")
                                return
                        cur.execute('''UPDATE inventory SET quantity=?, unit_price=?, reorder_level=?, last_updated=? WHERE id=?''',
                                    (qty, price, reorder, datetime.now(), item_id))
                        conn.commit()
                        conn.close()
                        self.log_audit_action(self.current_user['id'], "Edit Inventory", f"Item {item_id} updated")
                        dlg.destroy()
                        load_inventory()
                    except Exception as e:
                        messagebox.showerror("Error", f"Failed to update item: {str(e)}")
                tk.Button(dlg, text="Save Changes", bg="#2980b9", fg="white", command=save).pack(pady=10)
                tk.Button(dlg, text="Cancel", command=dlg.destroy).pack()

            def delete_item():
                sel = inv_tree.selection()
                if not sel:
                    messagebox.showwarning("Warning", "Select an item to delete")
                    return
                item_id = inv_tree.item(sel[0])['values'][0]
                if not messagebox.askyesno("Confirm", "Are you sure you want to delete this item?"):
                    return
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    # Enforce permissions by role on the item's store
                    role = self.current_user.get('role') if self.current_user else None
                    if role in ('retail_store','contract_owner'):
                        cur.execute('''SELECT 1
                                       FROM inventory i JOIN stores s ON s.id=i.store_id
                                       WHERE i.id=? AND s.owner_id=?''', (item_id, self.current_user['id']))
                        if not cur.fetchone():
                            conn.close()
                            messagebox.showerror("Permission", "You can only delete items in stores you own.")
                            return
                    elif role == 'manager':
                        cur.execute('''SELECT 1
                                       FROM inventory i JOIN stores s ON s.id=i.store_id
                                       WHERE i.id=? AND s.manager_id=?''', (item_id, self.current_user['id']))
                        if not cur.fetchone():
                            conn.close()
                            messagebox.showerror("Permission", "You can only delete items in stores you manage.")
                            return
                    cur.execute("DELETE FROM inventory WHERE id=?", (item_id,))
                    conn.commit()
                    conn.close()
                    self.log_audit_action(self.current_user['id'], "Delete Inventory", f"Item {item_id} deleted")
                    load_inventory()
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to delete item: {str(e)}")

            # Role-based action buttons: hide Add/Edit/Delete for managers
            try:
                _role = self.current_user.get('role') if getattr(self, 'current_user', None) else None
            except Exception:
                _role = None
            if _role != 'manager':
                tk.Button(btns, text="Add Item", bg="#27ae60", fg="white", command=add_item).pack(side='left')
                tk.Button(btns, text="Edit Item", bg="#2980b9", fg="white", command=edit_item).pack(side='left', padx=5)
                tk.Button(btns, text="Delete Item", bg="#c0392b", fg="white", command=delete_item).pack(side='left')
            else:
                tk.Button(btns, text="Transfer to Contractor", bg="#8e44ad", fg="white", command=self.show_transfer_products).pack(side='left')
                tk.Button(btns, text="Consume", bg="#8e44ad", fg="white", command=lambda: consume_item()).pack(side='left', padx=5)
            # New: Consume material (Managers can reduce stock with a reason/note)
            def consume_item():
                sel = inv_tree.selection()
                if not sel:
                    messagebox.showwarning("Consume", "Select an item to consume")
                    return
                values = inv_tree.item(sel[0])['values']
                item_id = values[0]
                item_name = values[1]
                available_qty = 0.0
                try:
                    available_qty = float(values[3])
                except Exception:
                    available_qty = 0.0
                dlg = tk.Toplevel(inv_window)
                dlg.title(f"Consume Material - {item_name}")
                dlg.geometry("420x320")
                dlg.configure(bg='white')
                dlg.grab_set()
                tk.Label(dlg, text=f"Item: {item_name}", bg='white', font=('Arial', 11, 'bold')).pack(anchor='w', padx=10, pady=(10,0))
                tk.Label(dlg, text=f"Available: {available_qty}", bg='white').pack(anchor='w', padx=10)
                tk.Label(dlg, text="Quantity to Consume:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                qty_var = tk.StringVar()
                tk.Entry(dlg, textvariable=qty_var).pack(fill='x', padx=10)
                tk.Label(dlg, text="Where/Why consumed (required):", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                note_txt = tk.Text(dlg, height=4)
                note_txt.pack(fill='x', padx=10)
                def do_consume():
                    def safe_float(s, default=None):
                        try:
                            return float(str(s).replace(',', '').strip())
                        except Exception:
                            return default
                    qty = safe_float(qty_var.get(), None)
                    note = note_txt.get('1.0', 'end').strip()
                    if qty is None or qty <= 0:
                        messagebox.showwarning("Validation", "Quantity must be a positive number")
                        return
                    if qty > available_qty:
                        messagebox.showwarning("Validation", "Cannot consume more than available quantity")
                        return
                    if not note:
                        messagebox.showwarning("Validation", "Please provide a note explaining where it was consumed")
                        return
                    try:
                        conn = self.db_manager.create_connection()
                        cur = conn.cursor()
                        # Permission: managers can only consume items in stores they manage
                        role = self.current_user.get('role') if self.current_user else None
                        if role == 'manager':
                            cur.execute('''SELECT 1 FROM inventory i JOIN stores s ON s.id=i.store_id
                                           WHERE i.id=? AND s.manager_id=?''', (item_id, self.current_user['id']))
                            if not cur.fetchone():
                                conn.close()
                                messagebox.showerror("Permission", "You can only consume for stores you manage.")
                                return
                        # Reduce quantity
                        cur.execute('SELECT store_id, material_id, quantity FROM inventory WHERE id=?', (item_id,))
                        row = cur.fetchone()
                        if not row:
                            conn.close()
                            messagebox.showerror("Error", "Inventory item not found")
                            return
                        store_id, material_id, curr_qty = row
                        # Block consumption in retail stores (managers only consume in contract/non-retail stores)
                        try:
                            _owner_role_row = None
                            cur.execute("SELECT LOWER(COALESCE(u.role,'')) FROM stores s JOIN users u ON u.id = s.owner_id WHERE s.id = ?", (store_id,))
                            _owner_role_row = cur.fetchone()
                            if _owner_role_row and _owner_role_row[0] == 'retail_store':
                                conn.close()
                                messagebox.showwarning("Consume Not Allowed", "This is a retail store. Managers can only consume in contract stores (non-retail).")
                                return
                        except Exception:
                            pass
                        new_qty = max(0.0, float(curr_qty or 0) - qty)
                        cur.execute('UPDATE inventory SET quantity=?, last_updated=? WHERE id=?', (new_qty, datetime.now(), item_id))
                        conn.commit()
                        conn.close()
                        # Audit log with details
                        details = {
                            'store_id': store_id,
                            'inventory_id': item_id,
                            'material_id': material_id,
                            'consumed_qty': qty,
                            'note': note
                        }
                        self.log_audit_action(self.current_user['id'], 'Consume Material', json.dumps(details))
                        messagebox.showinfo("Consumed", "Material consumption recorded.")
                        dlg.destroy()
                        load_inventory()
                    except Exception as e:
                        try:
                            messagebox.showerror("Error", f"Failed to consume material: {str(e)}")
                        except Exception:
                            pass
                tk.Button(dlg, text="Consume", bg="#8e44ad", fg="white", command=do_consume).pack(pady=10)
                tk.Button(dlg, text="Cancel", command=dlg.destroy).pack()
            # Show Consume action for roles except retail_store and manager (managers can only transfer)
            try:
                __role = self.current_user.get('role') if getattr(self, 'current_user', None) else None
            except Exception:
                __role = None
            if __role not in ('retail_store', 'manager'):
                tk.Button(btns, text="Consume", bg="#8e44ad", fg="white", command=consume_item).pack(side='left', padx=5)
            # View single store inventory for the selected row
            def view_selected_store_inventory():
                sel = inv_tree.selection()
                if not sel:
                    try:
                        messagebox.showwarning("View Store", "Please select an inventory row first")
                    except Exception:
                        pass
                    return
                try:
                    values = inv_tree.item(sel[0])['values']
                    inv_id = int(values[0]) if values and values[0] is not None else None
                except Exception:
                    inv_id = None
                if not inv_id:
                    try:
                        messagebox.showwarning("View Store", "Could not resolve the selected inventory record.")
                    except Exception:
                        pass
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT store_id FROM inventory WHERE id=?", (inv_id,))
                    r = cur.fetchone(); conn.close()
                    if not r:
                        messagebox.showerror("View Store", "Inventory record not found in database.")
                        return
                    store_id = int(r[0])
                    # Prefer advanced overview when available
                    if hasattr(self, 'open_view_inventory'):
                        self.open_view_inventory(preselected_store_id=store_id)
                    elif hasattr(self, 'show_view_inventory'):
                        self.show_view_inventory(preselected_store_id=store_id)
                    else:
                        # Fallback to basic inventory filtered to the store
                        self.show_inventory(preselected_store_id=store_id)
                except Exception as e:
                    try:
                        messagebox.showerror("View Store", f"Failed to open store inventory: {str(e)}")
                    except Exception:
                        pass

            # Buttons on the left/right
            tk.Button(btns, text="View Store", bg="#34495e", fg="white", command=view_selected_store_inventory).pack(side='left', padx=5)
            tk.Button(btns, text="Refresh", command=load_inventory).pack(side='right')

            # load initial
            load_inventory()

            # Log access
            self.log_audit_action(self.current_user['id'], "Access Inventory", "Opened inventory management interface")
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Inventory Management: {str(e)}")
            except Exception:
                pass


    def show_buy_materials(self, preselected_store_id=None):
        try:
            # Access control: any logged-in user except retail stores can place an order
            if not getattr(self, 'current_user', None):
                messagebox.showwarning("Access Denied", "You must be logged in to place an order.")
                return
            try:
                role = self.current_user.get('role')
                if role == 'retail_store':
                    messagebox.showinfo("Orders", "Retail stores approve orders rather than placing them. Use 'View & Approve Orders'.")
                    return
            except Exception:
                pass

            win = tk.Toplevel(self.root)
            win.title("Buy Materials")
            win.geometry("700x520")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Buy Materials for Store", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            form = tk.Frame(win, bg='white')
            form.pack(fill='x', padx=15)

            # Store selection (retail source store)
            tk.Label(form, text="Retail Store:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            store_var = tk.StringVar()
            store_cb = ttk.Combobox(form, textvariable=store_var, state='readonly', width=35)
            store_cb.grid(row=0, column=1, sticky='w', padx=5, pady=6)

            # Destination (buyer store)
            tk.Label(form, text="Deliver To (My Store):", bg='white').grid(row=0, column=2, sticky='e', padx=5, pady=6)
            buyer_store_var = tk.StringVar()
            buyer_store_cb = ttk.Combobox(form, textvariable=buyer_store_var, state='readonly', width=35)
            buyer_store_cb.grid(row=0, column=3, sticky='w', padx=5, pady=6)

            # Material selection
            tk.Label(form, text="Material:", bg='white').grid(row=1, column=0, sticky='e', padx=5, pady=6)
            material_var = tk.StringVar()
            material_cb = ttk.Combobox(form, textvariable=material_var, state='readonly', width=35)
            material_cb.grid(row=1, column=1, sticky='w', padx=5, pady=6)

            # Quantity
            tk.Label(form, text="Quantity:", bg='white').grid(row=2, column=0, sticky='e', padx=5, pady=6)
            qty_var = tk.StringVar(value='1')
            qty_entry = tk.Entry(form, textvariable=qty_var, width=20)
            qty_entry.grid(row=2, column=1, sticky='w', padx=5, pady=6)

            # Unit price
            tk.Label(form, text="Unit Price (FCFA):", bg='white').grid(row=3, column=0, sticky='e', padx=5, pady=6)
            price_var = tk.StringVar(value='0')
            price_entry = tk.Entry(form, textvariable=price_var, width=20, state='readonly')
            price_entry.grid(row=3, column=1, sticky='w', padx=5, pady=6)

            # Total cost (live)
            tk.Label(form, text="Total Cost (FCFA):", bg='white').grid(row=4, column=0, sticky='e', padx=5, pady=6)
            total_var = tk.StringVar(value='0')
            total_lbl = tk.Label(form, textvariable=total_var, bg='white', fg='#27ae60')
            total_lbl.grid(row=4, column=1, sticky='w', padx=5, pady=6)

            # Optional note
            tk.Label(form, text="Notes:", bg='white').grid(row=5, column=0, sticky='ne', padx=5, pady=6)
            notes_txt = tk.Text(form, width=45, height=4)
            notes_txt.grid(row=5, column=1, sticky='w', padx=5, pady=6)

            # Helper maps
            store_map = {}          # retail store (source)
            buyer_store_map = {}    # buyer's destination store
            mat_map = {}            # display -> (id, standard_price)

            def load_my_stores():
                try:
                    # Load only existing retail stores (owned by users with role 'retail_store') that are active
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("""
                        SELECT s.id, s.name
                        FROM stores s
                        JOIN users u ON u.id = s.owner_id
                        WHERE s.is_active = 1 AND u.role = 'retail_store'
                        ORDER BY s.name
                    """)
                    rows = cur.fetchall()
                    conn.close()
                    values = []
                    for sid, name in rows:
                        disp = f"{name} (ID:{sid})"
                        store_map[disp] = sid
                        values.append(disp)
                    store_cb['values'] = values
                    # Preselect
                    if preselected_store_id:
                        for d, sid in store_map.items():
                            if sid == preselected_store_id:
                                store_cb.set(d)
                                break
                    if not store_cb.get() and values:
                        store_cb.set(values[0])
                except Exception:
                    store_cb['values'] = []

            def load_buyer_stores():
                try:
                    # Load active stores owned by current user (destination stores)
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT id, name FROM stores WHERE is_active = 1 AND owner_id = ? ORDER BY name", (self.current_user['id'],))
                    rows = cur.fetchall(); conn.close()
                    values = []
                    for sid, name in rows:
                        disp = f"{name} (ID:{sid})"; buyer_store_map[disp] = sid; values.append(disp)
                    buyer_store_cb['values'] = values
                    if values and not buyer_store_cb.get():
                        buyer_store_cb.set(values[0])
                except Exception:
                    buyer_store_cb['values'] = []

            def load_materials():
                try:
                    material_cb.set('')
                    mat_map.clear()
                    sid = store_map.get(store_var.get()) or store_map.get(store_cb.get())
                    if not sid:
                        material_cb['values'] = []
                        price_var.set('0')
                        try:
                            _update_total()
                        except Exception:
                            pass
                        return
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("""
                        SELECT bm.id, bm.name, i.unit_price
                        FROM building_materials bm
                        LEFT JOIN inventory i ON i.material_id = bm.id AND i.store_id = ?
                        ORDER BY bm.name
                    """, (sid,))
                    rows = cur.fetchall()
                    conn.close()
                    values = []
                    for mid, name, uprice in rows:
                        disp = f"{name} (ID:{mid})"
                        mat_map[disp] = (mid, uprice if uprice is not None else 0)
                        values.append(disp)
                    material_cb['values'] = values
                    if values:
                        material_cb.set(values[0])
                        _, p = mat_map[material_cb.get()]
                        try:
                            price_var.set(str(int(float(p))))
                        except Exception:
                            price_var.set(str(p))
                        try:
                            _update_total()
                        except Exception:
                            pass
                except Exception:
                    material_cb['values'] = []

            def on_material_change(*_):
                sel = material_cb.get()
                if sel in mat_map:
                    _, p = mat_map[sel]
                    try:
                        price_var.set(str(int(float(p))))
                    except Exception:
                        price_var.set(str(p))
                try:
                    _update_total()
                except Exception:
                    pass

            material_cb.bind('<<ComboboxSelected>>', on_material_change)
            try:
                store_cb.bind('<<ComboboxSelected>>', lambda e: (load_materials(), on_material_change()))
            except Exception:
                pass

            # Buttons
            btns = tk.Frame(win, bg='white')
            btns.pack(fill='x', padx=15, pady=10)

            def safe_float(s, default=None):
                try:
                    val = float(str(s).replace(',', '').strip())
                    return val
                except Exception:
                    return default

            def _update_total(*_):
                q = safe_float(qty_var.get(), 0) or 0
                p = safe_float(price_var.get(), 0) or 0
                total = q * p
                try:
                    total_var.set(f"{total:,.0f}")
                except Exception:
                    total_var.set(str(total))

            # Live updates when quantity or price changes
            try:
                qty_var.trace('w', lambda *a: _update_total())
                price_var.trace('w', lambda *a: _update_total())
            except Exception:
                pass

            def do_buy():
                try:
                    if not store_cb.get():
                        messagebox.showwarning("Input", "Please select a retail store")
                        return
                    if not buyer_store_cb.get():
                        messagebox.showwarning("Input", "Please select your destination store")
                        return
                    if not material_cb.get():
                        messagebox.showwarning("Input", "Please select a material")
                        return
                    qty = safe_float(qty_var.get(), None)
                    price = safe_float(price_var.get(), None)
                    if qty is None or qty <= 0:
                        messagebox.showwarning("Input", "Quantity must be a positive number")
                        return
                    if price is None or price <= 0:
                        messagebox.showwarning("Input", "Unit price must be a positive number")
                        return

                    store_id = store_map[store_cb.get()]
                    buyer_store_id = buyer_store_map.get(buyer_store_cb.get())
                    if not buyer_store_id:
                        messagebox.showwarning("Input", "Invalid destination store selected")
                        return
                    material_id, _ = mat_map[material_cb.get()]

                    # Verify the selected store is an active retail store
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("""
                        SELECT s.id
                        FROM stores s
                        JOIN users u ON u.id = s.owner_id
                        WHERE s.id = ? AND s.is_active = 1 AND u.role = 'retail_store'
                    """, (store_id,))
                    row = cur.fetchone()
                    if not row:
                        conn.close()
                        messagebox.showerror("Access Denied", "You can only request purchases from active retail stores.")
                        return

                    # Enforce unit price from selected retail store's inventory
                    cur.execute("SELECT unit_price FROM inventory WHERE store_id = ? AND material_id = ?", (store_id, material_id))
                    p_row = cur.fetchone()
                    if not p_row or p_row[0] is None or float(p_row[0]) <= 0:
                        conn.close()
                        messagebox.showwarning("Pricing", "Selected retail store has no valid unit price set for this material.")
                        return
                    try:
                        price = float(p_row[0])
                    except Exception:
                        price = p_row[0]
                    try:
                        price_var.set(str(int(float(price))))
                    except Exception:
                        price_var.set(str(price))

                    # Record a purchase request instead of altering inventory; approval required by the retail store owner
                    try:
                        cur.execute("""
                            CREATE TABLE IF NOT EXISTS purchase_requests (
                                id INTEGER PRIMARY KEY AUTOINCREMENT,
                                created_at TEXT NOT NULL,
                                buyer_id INTEGER NOT NULL,
                                store_id INTEGER NOT NULL,
                                buyer_store_id INTEGER,
                                material_id INTEGER NOT NULL,
                                quantity REAL NOT NULL,
                                unit_price REAL NOT NULL,
                                notes TEXT,
                                status TEXT NOT NULL DEFAULT 'Pending',
                                approved_by INTEGER,
                                approved_at TEXT
                            )
                        """)
                    except Exception:
                        pass

                    now = datetime.now()
                    cur.execute(
                        """
                        INSERT INTO purchase_requests
                        (created_at, buyer_id, store_id, buyer_store_id, material_id, quantity, unit_price, notes, status)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'Pending')
                        """,
                        (now, self.current_user['id'], store_id, buyer_store_id, material_id, qty, price, notes_txt.get('1.0', 'end').strip())
                    )
                    conn.commit()
                    conn.close()

                    # Audit
                    details = {
                        'store_id': store_id,
                        'buyer_store_id': buyer_store_id,
                        'material_id': material_id,
                        'quantity': qty,
                        'unit_price': price,
                        'notes': notes_txt.get('1.0', 'end').strip(),
                        'status': 'Pending'
                    }
                    self.log_audit_action(self.current_user['id'], "Purchase Request", json.dumps(details))

                    messagebox.showinfo("Submitted", "Your purchase request has been sent to the retail store owner for approval.")
                    win.destroy()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to buy materials: {str(e)}")
                    except Exception:
                        pass

            tk.Button(btns, text="Buy", bg="#27ae60", fg="white", width=12, command=do_buy).pack(side='left')
            tk.Button(btns, text="Cancel", bg="#6c757d", fg="white", width=12, command=win.destroy).pack(side='left', padx=8)

            # Load data
            load_my_stores()
            load_buyer_stores()
            load_materials()
            on_material_change()

            # Focus
            qty_entry.focus_set()

        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Buy Materials: {str(e)}")
            except Exception:
                pass

        
    def show_view_approve_orders(self):
        try:
            # Access control: retail owners/managers and administrators
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Orders", "You must be logged in to view orders.")
                return
            role = self.current_user.get('role')
            if role not in ("retail_store", "manager", "administrator"):
                messagebox.showwarning("Access Denied", "Only Retail Store owners, Managers, or Administrators can approve orders.")
                return

            win = tk.Toplevel(self.root)
            win.title("View & Approve Orders")
            win.geometry("1000x600")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Purchase Requests - View & Approve", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Ensure table exists (idempotent)
            try:
                conn0 = self.db_manager.create_connection(); cur0 = conn0.cursor()
                cur0.execute("""
                    CREATE TABLE IF NOT EXISTS purchase_requests (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        created_at TEXT NOT NULL,
                        buyer_id INTEGER NOT NULL,
                        store_id INTEGER NOT NULL,
                        material_id INTEGER NOT NULL,
                        quantity REAL NOT NULL,
                        unit_price REAL NOT NULL,
                        notes TEXT,
                        status TEXT NOT NULL DEFAULT 'Pending',
                        approved_by INTEGER,
                        approved_at TEXT
                    )
                """)
                # Helpful indexes
                try:
                    cur0.execute("CREATE INDEX IF NOT EXISTS idx_pr_store_status ON purchase_requests(store_id, status)")
                    cur0.execute("CREATE INDEX IF NOT EXISTS idx_pr_buyer ON purchase_requests(buyer_id)")
                    cur0.execute("CREATE INDEX IF NOT EXISTS idx_pr_material ON purchase_requests(material_id)")
                except Exception:
                    pass
                conn0.commit(); conn0.close()
            except Exception:
                pass

            # Filters
            filt = tk.Frame(win, bg='white')
            filt.pack(fill='x', padx=10)
            tk.Label(filt, text="Store:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            store_var = tk.StringVar(); store_cb = ttk.Combobox(filt, textvariable=store_var, state='readonly', width=40)
            store_cb.grid(row=0, column=1, sticky='w')
            tk.Label(filt, text="Status:", bg='white').grid(row=0, column=2, sticky='e', padx=5)
            status_var = tk.StringVar(value='Pending'); status_cb = ttk.Combobox(filt, textvariable=status_var, state='readonly', width=18)
            status_cb['values'] = ['All','Pending','Approved','Rejected']; status_cb.grid(row=0, column=3, sticky='w')
            tk.Label(filt, text="Search:", bg='white').grid(row=0, column=4, sticky='e', padx=5)
            q_var = tk.StringVar(); tk.Entry(filt, textvariable=q_var, width=24).grid(row=0, column=5, sticky='w')
            refresh_btn = tk.Button(filt, text="Refresh", bg="#3498db", fg="white"); refresh_btn.grid(row=0, column=6, padx=6)

            # Table
            frame = tk.Frame(win, bg='white'); frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Created","Store","Buyer Store","Material","Qty","Unit Price","Total","Buyer","Status","Approved By","Approved At")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=120 if c not in ("Store","Material","Buyer") else 180)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview); tree.configure(yscrollcommand=sy.set); sy.pack(side='right', fill='y')

            # Actions
            actions = tk.Frame(win, bg='white'); actions.pack(fill='x', padx=10, pady=(0,10))
            view_btn = tk.Button(actions, text="View Details")
            approve_btn = tk.Button(actions, text="Approve", bg="#27ae60", fg="white")
            reject_btn = tk.Button(actions, text="Reject", bg="#c0392b", fg="white")
            close_btn = tk.Button(actions, text="Close", command=win.destroy)
            view_btn.pack(side='left'); approve_btn.pack(side='left', padx=6); reject_btn.pack(side='left'); close_btn.pack(side='right')

            store_map = {"All My Stores": None}
            def load_stores():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    if role == 'administrator':
                        cur.execute("SELECT id, name FROM stores WHERE is_active = 1 ORDER BY name")
                    else:
                        cur.execute("SELECT id, name FROM stores WHERE is_active = 1 AND (owner_id = ? OR manager_id = ?) ORDER BY name", (self.current_user['id'], self.current_user['id']))
                    rows = cur.fetchall(); conn.close()
                    values = ["All My Stores"]
                    for sid, name in rows:
                        disp = f"{name} (ID:{sid})"; store_map[disp] = sid; values.append(disp)
                    store_cb['values'] = values; store_cb.set(values[0] if values else "All My Stores")
                except Exception:
                    store_cb['values'] = ["All My Stores"]; store_cb.set("All My Stores")

            def refresh():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    q = (
                        "SELECT pr.id, pr.created_at, s.name, COALESCE(bs.name,'') AS buyer_store, bm.name, pr.quantity, pr.unit_price, (pr.quantity*pr.unit_price) AS total, "
                        "COALESCE(b.full_name,b.username) AS buyer, pr.status, COALESCE(a.full_name,a.username) AS approver, pr.approved_at, pr.store_id, pr.buyer_store_id, pr.material_id "
                        "FROM purchase_requests pr "
                        "JOIN stores s ON s.id = pr.store_id "
                        "LEFT JOIN stores bs ON bs.id = pr.buyer_store_id "
                        "JOIN building_materials bm ON bm.id = pr.material_id "
                        "JOIN users b ON b.id = pr.buyer_id "
                        "LEFT JOIN users a ON a.id = pr.approved_by WHERE 1=1 "
                    )
                    params = []
                    sid = store_map.get(store_var.get())
                    if role != 'administrator':
                        q += "AND (s.owner_id = ? OR s.manager_id = ?) "; params.extend([self.current_user['id'], self.current_user['id']])
                    if sid:
                        q += "AND pr.store_id = ? "; params.append(sid)
                    st = status_var.get()
                    if st and st != 'All':
                        q += "AND pr.status = ? "; params.append(st)
                    qq = q_var.get().strip()
                    if qq:
                        like = f"%{qq}%"; q += "AND (bm.name LIKE ? OR COALESCE(b.full_name,b.username) LIKE ? OR COALESCE(pr.notes,'') LIKE ?) "; params.extend([like, like, like])
                    q += "ORDER BY pr.created_at DESC"
                    cur.execute(q, params); rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try: messagebox.showerror("Orders", f"Failed to load orders: {str(e)}")
                    except Exception: pass
                    rows = []
                for it in tree.get_children(): tree.delete(it)
                for r in rows:
                    rid, created, store, buyer_store, material, qty, unit_price, total, buyer, status, approver, approved_at, _store_id, _buyer_store_id, _material_id = r
                    try:
                        upf = f"{float(unit_price):,.0f}" if unit_price is not None else ''
                    except Exception:
                        upf = unit_price
                    try:
                        totf = f"{float(total):,.0f}" if total is not None else ''
                    except Exception:
                        totf = total
                    tree.insert('', 'end', values=(rid, created, store, buyer_store, material, qty, upf, totf, buyer, status, approver or '', approved_at or ''))

            def get_selected_id():
                sel = tree.selection()
                if not sel:
                    messagebox.showinfo("Orders", "Select a request first."); return None
                try:
                    return int(tree.item(sel[0])['values'][0])
                except Exception:
                    return None

            def _has_perm(store_id: int) -> bool:
                try:
                    if role == 'administrator':
                        return True
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT owner_id, manager_id FROM stores WHERE id=?", (store_id,)); row = cur.fetchone(); conn.close()
                    if not row: return False
                    owner_id, manager_id = row
                    uid = self.current_user.get('id')
                    return uid in (owner_id, manager_id)
                except Exception:
                    return False

            def view_details():
                rid = get_selected_id()
                if not rid: return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute(
                        "SELECT pr.id, pr.created_at, pr.buyer_id, COALESCE(b.full_name,b.username), pr.store_id, s.name, pr.buyer_store_id, COALESCE(bs.name,''), pr.material_id, bm.name, pr.quantity, pr.unit_price, pr.notes, pr.status, pr.approved_by, COALESCE(a.full_name,a.username), pr.approved_at "
                        "FROM purchase_requests pr JOIN users b ON b.id = pr.buyer_id JOIN stores s ON s.id = pr.store_id LEFT JOIN stores bs ON bs.id = pr.buyer_store_id JOIN building_materials bm ON bm.id = pr.material_id LEFT JOIN users a ON a.id = pr.approved_by WHERE pr.id=?",
                        (rid,)
                    )
                    row = cur.fetchone(); conn.close()
                except Exception as e:
                    try: messagebox.showerror("Orders", f"Failed to load details: {str(e)}")
                    except Exception: pass
                    return
                if not row:
                    messagebox.showerror("Orders", "Request not found."); return
                d = tk.Toplevel(win); d.title(f"Request #{row[0]}"); d.geometry("560x420"); d.configure(bg='white'); d.grab_set(); d.transient(win)
                txt = tk.Text(d, wrap='word'); txt.pack(fill='both', expand=True, padx=10, pady=10)
                try:
                    total = float(row[10] or 0) * float(row[11] or 0)
                    totalf = f"{total:,.0f}"
                except Exception:
                    totalf = str(row[10])
                details = [
                    f"ID: {row[0]}", f"Created: {row[1]}", f"Buyer: {row[3]} (ID:{row[2]})",
                    f"Retail Store: {row[5]} (ID:{row[4]})", f"Buyer Store: {row[7]} (ID:{row[6]})",
                    f"Material: {row[9]} (ID:{row[8]})",
                    f"Quantity: {row[10]}", f"Unit Price: {row[11]}", f"Total: {totalf} FCFA",
                    f"Status: {row[13]}", f"Approved By: {row[15] or ''}", f"Approved At: {row[16] or ''}",
                    "", "Notes:", row[12] or "(None)"
                ]
                txt.insert('1.0', "\n".join(details)); txt.config(state='disabled')
                tk.Button(d, text="Close", command=d.destroy).pack(pady=6)

            def approve_request():
                rid = get_selected_id()
                if not rid: return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Fetch full context including buyer destination store
                    cur.execute("SELECT store_id, buyer_store_id, material_id, quantity, unit_price, status FROM purchase_requests WHERE id=?", (rid,))
                    row = cur.fetchone()
                    if not row:
                        conn.close(); messagebox.showerror("Approve", "Request not found."); return
                    store_id, buyer_store_id, material_id, qty, price, st = row
                    if not _has_perm(store_id):
                        conn.close(); messagebox.showwarning("Access", "You don't have permission for this store."); return
                    if st != 'Pending':
                        conn.close(); messagebox.showinfo("Approve", "Only pending requests can be approved."); return
                    if not buyer_store_id:
                        conn.close(); messagebox.showerror("Approve", "Destination store is missing on this request."); return
                    now = datetime.now().isoformat(sep=' ')
                    total_amount = float(qty or 0) * float(price or 0)
                    # Validate sufficient stock at retail source (store_id)
                    cur.execute("SELECT id, COALESCE(quantity,0) FROM inventory WHERE store_id=? AND material_id=?", (store_id, material_id))
                    src = cur.fetchone()
                    if not src or float(src[1]) < float(qty or 0):
                        conn.close(); messagebox.showerror("Approve", "Insufficient stock at retail store to fulfill this request."); return
                    src_inv_id, src_qty = src
                    # Start atomic operation
                    try:
                        cur.execute("BEGIN IMMEDIATE")
                    except Exception:
                        pass
                    # Decrease inventory at retail (source)
                    new_src_qty = float(src_qty or 0) - float(qty or 0)
                    cur.execute("UPDATE inventory SET quantity=?, last_updated=? WHERE id=?", (new_src_qty, now, src_inv_id))
                    # Increase inventory at buyer (destination)
                    cur.execute("SELECT id, COALESCE(quantity,0) FROM inventory WHERE store_id=? AND material_id=?", (buyer_store_id, material_id))
                    dst = cur.fetchone()
                    if dst:
                        dst_inv_id, dst_qty = dst
                        new_dst_qty = float(dst_qty or 0) + float(qty or 0)
                        cur.execute("UPDATE inventory SET quantity=?, unit_price=?, last_updated=? WHERE id=?", (new_dst_qty, float(price or 0), now, dst_inv_id))
                    else:
                        cur.execute("INSERT INTO inventory(store_id, material_id, quantity, unit_price, reorder_level, last_updated) VALUES (?,?,?,?,?,?)",
                                    (buyer_store_id, material_id, float(qty or 0), float(price or 0), 10, now))
                    # Resolve names for transaction notes
                    try:
                        cur.execute("SELECT name FROM stores WHERE id=?", (buyer_store_id,)); buyer_store_name = (cur.fetchone() or ("Buyer Store",))[0]
                        cur.execute("SELECT name FROM stores WHERE id=?", (store_id,)); retail_store_name = (cur.fetchone() or ("Retail Store",))[0]
                    except Exception:
                        buyer_store_name = ""; retail_store_name = ""
                    # Transactions: Sale at retail (source)
                    cur.execute(
                        "INSERT INTO transactions(store_id, customer_name, material_id, quantity, unit_price, total_amount, transaction_type, payment_status, transaction_date, user_id) "
                        "VALUES (?,?,?,?,?,?,?,?,?,?)",
                        (store_id, f"{buyer_store_name} (ID:{buyer_store_id})", material_id, float(qty or 0), float(price or 0), total_amount, 'Sale', 'Completed', now, self.current_user['id'])
                    )
                    # Transactions: Purchase at buyer (destination)
                    cur.execute(
                        "INSERT INTO transactions(store_id, customer_name, material_id, quantity, unit_price, total_amount, transaction_type, payment_status, transaction_date, user_id) "
                        "VALUES (?,?,?,?,?,?,?,?,?,?)",
                        (buyer_store_id, f"{retail_store_name} (ID:{store_id})", material_id, float(qty or 0), float(price or 0), total_amount, 'Purchase', 'Completed', now, self.current_user['id'])
                    )
                    # Approve request
                    cur.execute("UPDATE purchase_requests SET status='Approved', approved_by=?, approved_at=? WHERE id=?", (self.current_user['id'], now, rid))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Approve Purchase Request & Transfer", json.dumps({"request_id": rid, "from_store": store_id, "to_store": buyer_store_id, "material_id": material_id, "qty": qty, "price": price}))
                    except Exception:
                        pass
                    messagebox.showinfo("Approved", "Request approved and inventory transferred to the buyer's store.")
                    refresh()
                except Exception as e:
                    try: messagebox.showerror("Approve", f"Failed to approve: {str(e)}")
                    except Exception: pass

            def reject_request():
                rid = get_selected_id()
                if not rid: return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT store_id, status FROM purchase_requests WHERE id=?", (rid,)); row = cur.fetchone()
                    if not row:
                        conn.close(); messagebox.showerror("Reject", "Request not found."); return
                    store_id, st = row
                    if not _has_perm(store_id):
                        conn.close(); messagebox.showwarning("Access", "You don't have permission for this store."); return
                    if st != 'Pending':
                        conn.close(); messagebox.showinfo("Reject", "Only pending requests can be rejected."); return
                    now = datetime.now().isoformat(sep=' ')
                    cur.execute("UPDATE purchase_requests SET status='Rejected', approved_by=?, approved_at=? WHERE id=?", (self.current_user['id'], now, rid))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Reject Purchase Request", json.dumps({"request_id": rid}))
                    except Exception:
                        pass
                    messagebox.showinfo("Rejected", "Request rejected.")
                    refresh()
                except Exception as e:
                    try: messagebox.showerror("Reject", f"Failed to reject: {str(e)}")
                    except Exception: pass

            # Wire
            refresh_btn.config(command=refresh)
            view_btn.config(command=view_details)
            approve_btn.config(command=approve_request)
            reject_btn.config(command=reject_request)
            store_var.trace('w', lambda *a: refresh())
            status_var.trace('w', lambda *a: refresh())
            q_var.trace('w', lambda *a: refresh())

            load_stores(); refresh()

            try:
                self.log_audit_action(self.current_user['id'], "Open Orders (View & Approve)", "")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Orders", f"Failed to open View & Approve Orders: {str(e)}")
            except Exception:
                pass


#   ================= show sales detail =================
    def show_new_sale(self):
        try:
            win = tk.Toplevel(self.root)
            win.title("New Sale")
            win.geometry("700x500")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Record New Sale", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            form = tk.Frame(win, bg='white')
            form.pack(fill='x', padx=15)

            # Store selection
            tk.Label(form, text="Store:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            store_var = tk.StringVar()
            store_cb = ttk.Combobox(form, textvariable=store_var, state='readonly', width=35)
            store_cb.grid(row=0, column=1, sticky='w', padx=5, pady=6)

            # Customer name (optional)
            tk.Label(form, text="Customer:", bg='white').grid(row=1, column=0, sticky='e', padx=5, pady=6)
            customer_var = tk.StringVar()
            customer_entry = tk.Entry(form, textvariable=customer_var, width=38)
            customer_entry.grid(row=1, column=1, sticky='w', padx=5, pady=6)

            # Optional: Sell to another store
            def choose_store_customer():
                try:
                    sid = store_map.get(store_var.get())
                    dlg = tk.Toplevel(win); dlg.title("Sell to Store"); dlg.geometry("420x160"); dlg.configure(bg='white'); dlg.grab_set(); dlg.transient(win)
                    tk.Label(dlg, text="Select Destination Store:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                    dest_var = tk.StringVar(); dest_cb = ttk.Combobox(dlg, textvariable=dest_var, state='readonly')
                    dest_cb.pack(fill='x', padx=10, pady=6)
                    # Load eligible stores (exclude other retail-owned, include own/managed; exclude source)
                    try:
                        conn = self.db_manager.create_connection(); cur = conn.cursor()
                        cur.execute("""
                            SELECT s.id, s.name
                            FROM stores s
                            JOIN users u ON u.id = s.owner_id
                            WHERE s.is_active = 1
                              AND (u.role <> 'retail_store' OR s.owner_id = ? OR s.manager_id = ?)
                              AND (? IS NULL OR s.id <> ?)
                            ORDER BY s.name
                        """, (self.current_user['id'], self.current_user['id'], sid, sid))
                        rows = cur.fetchall(); conn.close()
                        values = [f"{name} (ID:{_id})" for _id, name in rows]
                        dest_cb['values'] = values
                        if values: dest_cb.set(values[0])
                    except Exception:
                        dest_cb['values'] = []
                    def set_customer():
                        if dest_var.get():
                            customer_var.set(f"{dest_var.get()} (Store)")
                        dlg.destroy()
                    tk.Button(dlg, text="Use This Store", bg="#27ae60", fg="white", command=set_customer).pack(pady=6)
                    tk.Button(dlg, text="Cancel", command=dlg.destroy).pack()
                except Exception:
                    pass
            tk.Button(form, text="Sell to Store...", command=choose_store_customer).grid(row=1, column=2, sticky='w', padx=5, pady=6)

            # Material selection
            tk.Label(form, text="Material:", bg='white').grid(row=2, column=0, sticky='e', padx=5, pady=6)
            material_var = tk.StringVar()
            material_cb = ttk.Combobox(form, textvariable=material_var, state='readonly', width=35)
            material_cb.grid(row=2, column=1, sticky='w', padx=5, pady=6)

            # Quantity
            tk.Label(form, text="Quantity:", bg='white').grid(row=3, column=0, sticky='e', padx=5, pady=6)
            qty_var = tk.StringVar(value='1')
            qty_entry = tk.Entry(form, textvariable=qty_var, width=20)
            qty_entry.grid(row=3, column=1, sticky='w', padx=5, pady=6)

            # Unit price
            tk.Label(form, text="Unit Price (FCFA):", bg='white').grid(row=4, column=0, sticky='e', padx=5, pady=6)
            price_var = tk.StringVar(value='0')
            price_entry = tk.Entry(form, textvariable=price_var, width=20)
            price_entry.grid(row=4, column=1, sticky='w', padx=5, pady=6)

            # Total label
            total_frame = tk.Frame(win, bg='white')
            total_frame.pack(fill='x', padx=15, pady=(10, 0))
            total_var = tk.StringVar(value='0')
            tk.Label(total_frame, text="Total (FCFA):", bg='white', font=('Arial', 12, 'bold')).pack(side='left')
            total_value_lbl = tk.Label(total_frame, textvariable=total_var, bg='white', font=('Arial', 12, 'bold'), fg='#2c3e50')
            total_value_lbl.pack(side='left', padx=8)

            # Helper: load stores and materials
            store_map = {}  # display -> id
            mat_map = {}    # display -> (id, default_price, stock_qty)

            def load_stores():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    # Role-based filtering of active stores
                    role = self.current_user.get('role') if getattr(self, 'current_user', None) else None
                    params = []
                    query = "SELECT id, name FROM stores WHERE is_active = 1"
                    if role in ('retail_store', 'contract_owner'):
                        query += " AND owner_id = ?"; params.append(self.current_user['id'])
                    elif role == 'manager':
                        query += " AND manager_id = ?"; params.append(self.current_user['id'])
                    # administrators see all
                    query += " ORDER BY name"
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                    values = []
                    store_map.clear()
                    for sid, name in rows:
                        display = f"{name} (ID:{sid})"
                        store_map[display] = sid
                        values.append(display)
                    store_cb['values'] = values
                    if values:
                        store_cb.set(values[0])
                        # Trigger loading of materials for the default selection
                        load_materials_for_store()
                    else:
                        store_cb.set('')
                except Exception:
                    store_cb['values'] = []
                    store_cb.set('')

            def load_materials_for_store():
                try:
                    material_cb.set('')
                    mat_map.clear()
                    sid = store_map.get(store_var.get())
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    # Load materials: global plus store owner's custom materials
                    cur.execute(
                        """
                        SELECT bm.id, bm.name, i.unit_price, i.quantity
                        FROM building_materials bm
                        LEFT JOIN inventory i ON i.material_id = bm.id AND i.store_id = ?
                        LEFT JOIN stores s ON s.id = ?
                        WHERE (bm.owner_id IS NULL OR bm.owner_id = s.owner_id)
                        ORDER BY bm.name
                        """,
                        (sid, sid)
                    )
                    rows = cur.fetchall()
                    conn.close()
                    values = []
                    for mid, name, uprice, qty in rows:
                        display = f"{name} (ID:{mid})"
                        mat_map[display] = (mid, uprice if uprice is not None else 0, qty if qty is not None else 0)
                        values.append(display)
                    material_cb['values'] = values
                    if values:
                        material_cb.set(values[0])
                        on_material_change()
                except Exception:
                    material_cb['values'] = []

            def on_material_change(*_):
                # Prefill unit price and show stock
                disp = material_var.get()
                data = mat_map.get(disp)
                if data:
                    _, uprice, qty = data
                    try:
                        price_var.set(str(int(float(uprice))))
                    except Exception:
                        price_var.set(str(uprice))
                    stock_lbl_var.set(f"In stock: {qty}")
                update_total()

            def update_total(*_):
                try:
                    def safe_float(s, default=0.0):
                        try:
                            if s is None:
                                return default
                            s = str(s).strip()
                            if s == "":
                                return default
                            s = s.replace(",", "").replace("$", "").replace("₦", "").replace("£", "").replace("€", "").strip()
                            return float(s)
                        except Exception:
                            return default
                    q = safe_float(qty_var.get(), 0.0)
                    p = safe_float(price_var.get(), 0.0)
                    total = max(0, q * p)
                    total_var.set(f"{total:,.0f}")
                except Exception:
                    total_var.set("0")

            # Stock indicator
            stock_frame = tk.Frame(win, bg='white')
            stock_frame.pack(fill='x', padx=15, pady=5)
            stock_lbl_var = tk.StringVar(value='In stock: -')
            tk.Label(stock_frame, textvariable=stock_lbl_var, bg='white', fg='#7f8c8d').pack(anchor='w')

            # Buttons
            btns = tk.Frame(win, bg='white')
            btns.pack(fill='x', padx=15, pady=15)
            save_btn = tk.Button(btns, text="Add Sale", bg="#27ae60", fg="white", width=14)
            save_btn.pack(side='left')
            tk.Button(btns, text="Cancel", bg="#e74c3c", fg="white", width=12, command=win.destroy).pack(side='right')

            # Bindings
            store_var.trace('w', lambda *a: load_materials_for_store())
            material_var.trace('w', on_material_change)
            qty_var.trace('w', update_total)
            price_var.trace('w', update_total)

            # Save logic
            def add_sale():
                try:
                    sid = store_map.get(store_var.get())
                    disp = material_var.get()
                    mid, uprice, stock_qty = mat_map.get(disp, (None, 0, 0))
                    if not sid or not mid:
                        messagebox.showwarning("Validation", "Please select a store and a material.")
                        return
                    def safe_float(s, default=None):
                        try:
                            if s is None:
                                return default
                            s = str(s).strip()
                            if s == "":
                                return default
                            if "," in s and "." not in s:
                                s = s.replace(" ", "").replace("$", "").replace("₦", "").replace("£", "").replace("€", "").strip()
                                s = s.replace(",", ".")
                            else:
                                s = s.replace(",", "")
                                s = s.replace("$", "").replace("₦", "").replace("£", "").replace("€", "").strip()
                            return float(s)
                        except Exception:
                            return default
                    qty = safe_float(qty_var.get(), None)
                    if qty is None or qty <= 0:
                        messagebox.showwarning("Validation", "Quantity must be a positive number.")
                        return
                    price = safe_float(price_var.get(), None)
                    if price is None or price < 0:
                        messagebox.showwarning("Validation", "Unit price must be a non-negative number.")
                        return

                    # Check stock
                    if stock_qty is not None and stock_qty < qty:
                        if not messagebox.askyesno("Low Stock", f"Only {stock_qty} in stock. Proceed anyway?"):
                            return

                    total_amount = qty * price

                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()

                    # Re-check current stock and price from DB to be safe
                    cur.execute("SELECT quantity, unit_price FROM inventory WHERE store_id=? AND material_id=?", (sid, mid))
                    inv = cur.fetchone()
                    current_qty = inv[0] if inv else 0
                    # Insert transaction
                    cur.execute(
                        """
                        INSERT INTO transactions (store_id, material_id, quantity, unit_price, total_amount, transaction_type, transaction_date, user_id, customer_name)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                        """,
                        (sid, mid, qty, price, total_amount, 'sale', datetime.now().isoformat(sep=' '), self.current_user['id'], customer_var.get().strip())
                    )

                    # Update inventory (if record exists)
                    if inv:
                        new_qty = max(0, current_qty - qty)
                        cur.execute(
                            "UPDATE inventory SET quantity=?, last_updated=? WHERE store_id=? AND material_id=?",
                            (new_qty, datetime.now().isoformat(sep=' '), sid, mid)
                        )
                    conn.commit()
                    conn.close()

                    try:
                        self.log_audit_action(self.current_user['id'], "New Sale", f"Store {sid}, Material {mid}, Qty {qty}, Total {total_amount}")
                    except Exception:
                        pass

                    messagebox.showinfo("Success", "Sale recorded successfully.")
                    win.destroy()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to record sale: {str(e)}")
                    except Exception:
                        pass

            save_btn.config(command=add_sale)

            # Load initial data
            load_stores()
            load_materials_for_store()

            # Focus
            customer_entry.focus()

            # Shortcuts
            win.bind('<Return>', lambda e: add_sale())
            win.bind('<Escape>', lambda e: win.destroy())

        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open New Sale: {str(e)}")
            except Exception:
                pass

            
# ============ show sales history ===============
    def show_sales_history(self):
        try:
            win = tk.Toplevel(self.root)
            win.title("Sales History")
            win.geometry("1000x650")
            win.configure(bg='white')
            win.grab_set()

            # Header
            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Sales History", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filter_frame = tk.LabelFrame(win, text="Filters", bg='white')
            filter_frame.pack(fill='x', padx=10, pady=(0, 10))

            tk.Label(filter_frame, text="Start Date (YYYY-MM-DD):", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            start_var = tk.StringVar(value=(date.today()).isoformat())
            start_entry = tk.Entry(filter_frame, textvariable=start_var, width=15)
            start_entry.grid(row=0, column=1, sticky='w', padx=5, pady=6)

            tk.Label(filter_frame, text="End Date (YYYY-MM-DD):", bg='white').grid(row=0, column=2, sticky='e', padx=5, pady=6)
            end_var = tk.StringVar(value=(date.today()).isoformat())
            end_entry = tk.Entry(filter_frame, textvariable=end_var, width=15)
            end_entry.grid(row=0, column=3, sticky='w', padx=5, pady=6)

            tk.Label(filter_frame, text="Store:", bg='white').grid(row=0, column=4, sticky='e', padx=5, pady=6)
            store_var = tk.StringVar()
            store_cb = ttk.Combobox(filter_frame, textvariable=store_var, state='readonly', width=28)
            store_cb.grid(row=0, column=5, sticky='w', padx=5, pady=6)

            tk.Label(filter_frame, text="Material:", bg='white').grid(row=1, column=0, sticky='e', padx=5, pady=6)
            material_var = tk.StringVar()
            material_cb = ttk.Combobox(filter_frame, textvariable=material_var, state='readonly', width=28)
            material_cb.grid(row=1, column=1, sticky='w', padx=5, pady=6)

            tk.Label(filter_frame, text="Customer contains:", bg='white').grid(row=1, column=2, sticky='e', padx=5, pady=6)
            cust_var = tk.StringVar()
            cust_entry = tk.Entry(filter_frame, textvariable=cust_var, width=25)
            cust_entry.grid(row=1, column=3, sticky='w', padx=5, pady=6)

            btn_frame = tk.Frame(filter_frame, bg='white')
            btn_frame.grid(row=0, column=6, rowspan=2, padx=5, pady=6, sticky='w')
            search_btn = tk.Button(btn_frame, text="Search", bg="#3498db", fg="white")
            search_btn.pack(side='left')
            reset_btn = tk.Button(btn_frame, text="Reset")
            reset_btn.pack(side='left', padx=6)
            export_btn = tk.Button(btn_frame, text="Export CSV")
            export_btn.pack(side='left')

            # Results
            tree_frame = tk.Frame(win, bg='white')
            tree_frame.pack(fill='both', expand=True, padx=10, pady=(0, 10))
            cols = ("Time","Store","Customer","Material","Qty","Unit Price","Total")
            tree = ttk.Treeview(tree_frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=130)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(tree_frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Summary footer
            footer = tk.Frame(win, bg='white')
            footer.pack(fill='x', padx=10, pady=(0, 10))
            count_var = tk.StringVar(value='0')
            total_var = tk.StringVar(value='0')
            tk.Label(footer, text="Records:", bg='white').pack(side='left')
            tk.Label(footer, textvariable=count_var, bg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=(4, 12))
            tk.Label(footer, text="Sum (FCFA):", bg='white').pack(side='left')
            tk.Label(footer, textvariable=total_var, bg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=4)

            # Load stores and materials
            store_map = {"All Stores": None}
            material_map = {"All Materials": None}

            def load_stores():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT id, name FROM stores ORDER BY name")
                    rows = cur.fetchall()
                    conn.close()
                    values = ["All Stores"]
                    for sid, name in rows:
                        display = f"{name} (ID:{sid})"
                        store_map[display] = sid
                        values.append(display)
                    store_cb['values'] = values
                    store_cb.set(values[0])
                except Exception:
                    store_cb['values'] = ["All Stores"]
                    store_cb.set("All Stores")

            def load_materials():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT id, name FROM building_materials ORDER BY name")
                    rows = cur.fetchall()
                    conn.close()
                    values = ["All Materials"]
                    for mid, name in rows:
                        display = f"{name} (ID:{mid})"
                        material_map[display] = mid
                        values.append(display)
                    material_cb['values'] = values
                    material_cb.set(values[0])
                except Exception:
                    material_cb['values'] = ["All Materials"]
                    material_cb.set("All Materials")

            def validate_date_str(s):
                if not s:
                    return False
                try:
                    datetime.strptime(s, '%Y-%m-%d')
                    return True
                except Exception:
                    return False

            def refresh():
                # Validate dates
                s = start_var.get().strip()
                e = end_var.get().strip()
                if s and not validate_date_str(s):
                    messagebox.showerror("Validation", "Start date must be in YYYY-MM-DD format")
                    return
                if e and not validate_date_str(e):
                    messagebox.showerror("Validation", "End date must be in YYYY-MM-DD format")
                    return
                # Build query
                query = (
                    "SELECT t.transaction_date, s.name, COALESCE(t.customer_name,''), bm.name, t.quantity, t.unit_price, t.total_amount "
                    "FROM transactions t "
                    "JOIN stores s ON s.id = t.store_id "
                    "JOIN building_materials bm ON bm.id = t.material_id "
                    "WHERE 1=1 "
                )
                params = []
                if s:
                    query += "AND date(t.transaction_date) >= ? "
                    params.append(s)
                if e:
                    query += "AND date(t.transaction_date) <= ? "
                    params.append(e)
                sid = store_map.get(store_var.get())
                if sid:
                    query += "AND t.store_id = ? "
                    params.append(sid)
                mid = material_map.get(material_var.get())
                if mid:
                    query += "AND t.material_id = ? "
                    params.append(mid)
                cust = cust_var.get().strip()
                if cust:
                    query += "AND t.customer_name LIKE ? "
                    params.append(f"%{cust}%")
                query += "ORDER BY t.transaction_date DESC"

                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to load sales: {str(e)}")
                    except Exception:
                        pass
                    rows = []

                # Update table
                for item in tree.get_children():
                    tree.delete(item)
                total_sum = 0.0
                for r in rows:
                    values = list(r)
                    try:
                        values[4] = int(values[4]) if values[4] is not None else ''
                    except Exception:
                        pass
                    try:
                        values[5] = f"{float(values[5]):,.0f}" if values[5] is not None else ''
                    except Exception:
                        pass
                    try:
                        total_sum += float(r[6] or 0)
                        values[6] = f"{float(values[6]):,.0f}" if values[6] is not None else ''
                    except Exception:
                        pass
                    tree.insert('', 'end', values=values)
                count_var.set(str(len(rows)))
                total_var.set(f"{total_sum:,.0f}")

                # Log audit (non-blocking)
                try:
                    details = {
                        'start': s, 'end': e,
                        'store': store_var.get(), 'material': material_var.get(),
                        'customer_like': cust
                    }
                    self.log_audit_action(self.current_user['id'], "View Sales History", json.dumps(details))
                except Exception:
                    pass

            def do_reset():
                start_var.set(date.today().isoformat())
                end_var.set(date.today().isoformat())
                store_cb.set("All Stores")
                material_cb.set("All Materials")
                cust_var.set("")
                refresh()

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"sales_history_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Sales History", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"), ("All files","*.*")])
                    if not filename:
                        return
                    # Build data same as current filters
                    query = (
                        "SELECT t.transaction_date, s.name AS store, COALESCE(t.customer_name,''), bm.name AS material, t.quantity, t.unit_price, t.total_amount "
                        "FROM transactions t "
                        "JOIN stores s ON s.id = t.store_id "
                        "JOIN building_materials bm ON bm.id = t.material_id WHERE 1=1 "
                    )
                    params = []
                    s = start_var.get().strip()
                    e = end_var.get().strip()
                    if s:
                        query += "AND date(t.transaction_date) >= ? "
                        params.append(s)
                    if e:
                        query += "AND date(t.transaction_date) <= ? "
                        params.append(e)
                    sid = store_map.get(store_var.get())
                    if sid:
                        query += "AND t.store_id = ? "
                        params.append(sid)
                    mid = material_map.get(material_var.get())
                    if mid:
                        query += "AND t.material_id = ? "
                        params.append(mid)
                    cust = cust_var.get().strip()
                    if cust:
                        query += "AND t.customer_name LIKE ? "
                        params.append(f"%{cust}%")
                    query += "ORDER BY t.transaction_date DESC"
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(["Timestamp","Store","Customer","Material","Quantity","Unit Price","Total Amount"])
                        for r in rows:
                            writer.writerow(r)
                    messagebox.showinfo("Export", "Sales history exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            # Wire buttons
            search_btn.config(command=refresh)
            reset_btn.config(command=do_reset)
            export_btn.config(command=export_csv)

            # Initial load
            load_stores()
            load_materials()
            refresh()

            # Shortcuts
            win.bind('<F5>', lambda e: refresh())
            win.bind('<Escape>', lambda e: win.destroy())
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Sales History: {str(e)}")
            except Exception:
                pass

 # ================= manage customers =========================

    def show_customer_management(self):
        try:
            win = tk.Toplevel(self.root)
            win.title("Customer Management")
            win.geometry("900x600")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Customer Management", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Search and actions
            top = tk.Frame(win, bg='white')
            top.pack(fill='x', padx=10)
            tk.Label(top, text="Search:", bg='white').pack(side='left')
            search_var = tk.StringVar()
            tk.Entry(top, textvariable=search_var, width=40).pack(side='left', padx=6)
            tk.Button(top, text="Add Customer", bg="#27ae60", fg="white", command=lambda: add_edit_customer()).pack(side='right')

            # Table
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Name","Phone","Email","Address","Notes","Created")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=130)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Buttons
            btns = tk.Frame(win, bg='white')
            btns.pack(fill='x', padx=10, pady=(0,10))
            tk.Button(btns, text="Edit", bg="#2980b9", fg="white", command=lambda: add_edit_customer(edit=True)).pack(side='left')
            tk.Button(btns, text="Delete", bg="#c0392b", fg="white", command=lambda: delete_customer()).pack(side='left', padx=6)
            tk.Button(btns, text="Export CSV", command=lambda: export_csv()).pack(side='left')
            tk.Button(btns, text="Refresh", command=lambda: load_customers()).pack(side='right')

            def load_customers():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    q = search_var.get().strip()
                    if q:
                        like = f"%{q}%"
                        cur.execute(
                            """
                            SELECT id, name, phone, email, address, notes, created_date
                            FROM customers
                            WHERE name LIKE ? OR phone LIKE ? OR email LIKE ? OR address LIKE ?
                            ORDER BY name
                            """,
                            (like, like, like, like)
                        )
                    else:
                        cur.execute(
                            "SELECT id, name, phone, email, address, notes, created_date FROM customers ORDER BY name"
                        )
                    rows = cur.fetchall()
                    conn.close()
                    for item in tree.get_children():
                        tree.delete(item)
                    for r in rows:
                        tree.insert('', 'end', values=r)
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to load customers: {str(e)}")
                    except Exception:
                        pass

            def add_edit_customer(edit=False):
                try:
                    cust = None
                    if edit:
                        sel = tree.selection()
                        if not sel:
                            messagebox.showwarning("Edit", "Select a customer to edit.")
                            return
                        cust = tree.item(sel[0], 'values')
                    dlg = tk.Toplevel(win)
                    dlg.title("Edit Customer" if edit else "Add Customer")
                    dlg.geometry("450x420")
                    dlg.configure(bg='white')
                    dlg.grab_set()

                    form = tk.Frame(dlg, bg='white')
                    form.pack(fill='both', expand=True, padx=12, pady=12)
                    tk.Label(form, text="Name*:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
                    name_var = tk.StringVar(value=cust[1] if cust else '')
                    tk.Entry(form, textvariable=name_var, width=32).grid(row=0, column=1, sticky='w')
                    tk.Label(form, text="Phone:", bg='white').grid(row=1, column=0, sticky='e', padx=5, pady=6)
                    phone_var = tk.StringVar(value=cust[2] if cust else '')
                    tk.Entry(form, textvariable=phone_var, width=32).grid(row=1, column=1, sticky='w')
                    tk.Label(form, text="Email:", bg='white').grid(row=2, column=0, sticky='e', padx=5, pady=6)
                    email_var = tk.StringVar(value=cust[3] if cust else '')
                    tk.Entry(form, textvariable=email_var, width=32).grid(row=2, column=1, sticky='w')
                    tk.Label(form, text="Address:", bg='white').grid(row=3, column=0, sticky='e', padx=5, pady=6)
                    address_text = tk.Text(form, width=30, height=3)
                    if cust:
                        address_text.insert('1.0', cust[4])
                    address_text.grid(row=3, column=1, sticky='w')
                    tk.Label(form, text="Notes:", bg='white').grid(row=4, column=0, sticky='e', padx=5, pady=6)
                    notes_text = tk.Text(form, width=30, height=3)
                    if cust:
                        notes_text.insert('1.0', cust[5])
                    notes_text.grid(row=4, column=1, sticky='w')

                    def save():
                        try:
                            name = name_var.get().strip()
                            if not name:
                                messagebox.showwarning("Validation", "Name is required.")
                                return
                            phone = phone_var.get().strip()
                            email = email_var.get().strip()
                            address = address_text.get('1.0', 'end').strip()
                            notes = notes_text.get('1.0', 'end').strip()
                            conn = self.db_manager.create_connection()
                            cur = conn.cursor()
                            if edit:
                                cid = int(cust[0])
                                cur.execute(
                                    """
                                    UPDATE customers
                                    SET name=?, phone=?, email=?, address=?, notes=?
                                    WHERE id=?
                                    """,
                                    (name, phone, email, address, notes, cid)
                                )
                            else:
                                cur.execute(
                                    """
                                    INSERT INTO customers (name, phone, email, address, notes, created_date)
                                    VALUES (?, ?, ?, ?, ?, ?)
                                    """,
                                    (name, phone, email, address, notes, date.today().isoformat())
                                )
                            conn.commit()
                            conn.close()
                            try:
                                self.log_audit_action(self.current_user['id'], "Save Customer", f"{name}")
                            except Exception:
                                pass
                            messagebox.showinfo("Success", "Customer saved.")
                            dlg.destroy()
                            load_customers()
                        except sqlite3.IntegrityError:
                            messagebox.showerror("Duplicate", "A customer with this name already exists.")
                        except Exception as e:
                            try:
                                messagebox.showerror("Error", f"Failed to save: {str(e)}")
                            except Exception:
                                pass

                    btn_row = tk.Frame(dlg, bg='white')
                    btn_row.pack(fill='x', padx=12, pady=(0, 12))
                    tk.Button(btn_row, text="Save", bg="#27ae60", fg="white", command=save).pack(side='left')
                    tk.Button(btn_row, text="Cancel", bg="#e74c3c", fg="white", command=dlg.destroy).pack(side='right')
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to open form: {str(e)}")
                    except Exception:
                        pass

            def delete_customer():
                try:
                    sel = tree.selection()
                    if not sel:
                        messagebox.showwarning("Delete", "Select a customer to delete.")
                        return
                    item = tree.item(sel[0], 'values')
                    cid, name = item[0], item[1]
                    if not messagebox.askyesno("Confirm", f"Delete customer '{name}'?"):
                        return
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("DELETE FROM customers WHERE id=?", (cid,))
                    conn.commit()
                    conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Delete Customer", f"{name}")
                    except Exception:
                        pass
                    load_customers()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to delete: {str(e)}")
                    except Exception:
                        pass

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"customers_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Customers", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"),("All files","*.*")])
                    if not filename:
                        return
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT id, name, phone, email, address, notes, created_date FROM customers ORDER BY name")
                    rows = cur.fetchall()
                    conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(["ID","Name","Phone","Email","Address","Notes","Created Date"])
                        for r in rows:
                            writer.writerow(r)
                    messagebox.showinfo("Export", "Customers exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            def on_search(*_):
                load_customers()
            search_var.trace('w', lambda *a: on_search())

            # Context menu
            def context_menu(event):
                selection = tree.selection()
                menu = tk.Menu(win, tearoff=0)
                menu.add_command(label="Add Customer", command=lambda: add_edit_customer())
                if selection:
                    menu.add_command(label="Edit", command=lambda: add_edit_customer(edit=True))
                    menu.add_command(label="Delete", command=lambda: delete_customer())
                try:
                    menu.tk_popup(event.x_root, event.y_root)
                finally:
                    menu.grab_release()
            tree.bind("<Button-3>", context_menu)

            # Double click edit
            tree.bind('<Double-1>', lambda e: add_edit_customer(edit=True))

            # Shortcuts
            win.bind('<F5>', lambda e: load_customers())
            win.bind('<Escape>', lambda e: win.destroy())

            # Initial load
            load_customers()

            # Audit
            try:
                self.log_audit_action(self.current_user['id'], "Access Customers", "Opened customer management")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Customer Management: {str(e)}")
            except Exception:
                pass


# ============================= show atore analytics================

    def show_store_analytics(self, preselected_store_id=None):
        try:
            win = tk.Toplevel(self.root)
            win.title("Store Analytics")
            win.geometry("1000x700")
            win.configure(bg='white')
            win.grab_set()

            # Header
            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Store Analytics", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filter_frame = tk.LabelFrame(win, text="Filters", bg='white')
            filter_frame.pack(fill='x', padx=10, pady=(0, 10))

            tk.Label(filter_frame, text="Start (YYYY-MM-DD):", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            start_var = tk.StringVar(value=(date.today()).isoformat())
            tk.Entry(filter_frame, textvariable=start_var, width=15).grid(row=0, column=1, sticky='w', padx=5, pady=6)

            tk.Label(filter_frame, text="End (YYYY-MM-DD):", bg='white').grid(row=0, column=2, sticky='e', padx=5, pady=6)
            end_var = tk.StringVar(value=(date.today()).isoformat())
            tk.Entry(filter_frame, textvariable=end_var, width=15).grid(row=0, column=3, sticky='w', padx=5, pady=6)

            tk.Label(filter_frame, text="Store:", bg='white').grid(row=0, column=4, sticky='e', padx=5, pady=6)
            store_var = tk.StringVar()
            store_cb = ttk.Combobox(filter_frame, textvariable=store_var, state='readonly', width=28)
            store_cb.grid(row=0, column=5, sticky='w', padx=5, pady=6)

            # Quick ranges
            quick = tk.Frame(filter_frame, bg='white')
            quick.grid(row=0, column=6, padx=5, pady=6, sticky='w')
            tk.Button(quick, text="Today", command=lambda: set_range(days=0)).pack(side='left')
            tk.Button(quick, text="7 Days", command=lambda: set_range(days=7)).pack(side='left', padx=4)
            tk.Button(quick, text="30 Days", command=lambda: set_range(days=30)).pack(side='left')

            # Actions
            act = tk.Frame(filter_frame, bg='white')
            act.grid(row=0, column=7, padx=5, pady=6, sticky='w')
            refresh_btn = tk.Button(act, text="Refresh", bg="#3498db", fg="white")
            refresh_btn.pack(side='left')
            export_btn = tk.Button(act, text="Export CSV")
            export_btn.pack(side='left', padx=6)

            # Summary cards
            cards = tk.Frame(win, bg='white')
            cards.pack(fill='x', padx=10, pady=(0, 5))
            totals_var = tk.StringVar(value='0')
            tx_var = tk.StringVar(value='0')
            avg_var = tk.StringVar(value='0')
            top_mat_var = tk.StringVar(value='-')
            low_stock_var = tk.StringVar(value='0')

            def make_card(parent, title, var, color):
                f = tk.Frame(parent, bg=color, width=200, height=80)
                f.pack(side='left', padx=8, pady=5)
                f.pack_propagate(False)
                tk.Label(f, textvariable=var, font=('Arial', 22, 'bold'), bg=color, fg='white').pack(expand=True)
                tk.Label(f, text=title, font=('Arial', 11), bg=color, fg='white').pack()
                return f

            make_card(cards, "Total Sales (FCFA)", totals_var, "#2ecc71")
            make_card(cards, "Transactions", tx_var, "#3498db")
            make_card(cards, "Avg Ticket", avg_var, "#9b59b6")
            make_card(cards, "Top Material", top_mat_var, "#f39c12")
            make_card(cards, "Low Stock Items", low_stock_var, "#e67e22")

            # Tabs
            body = tk.Frame(win, bg='white')
            body.pack(fill='both', expand=True, padx=10, pady=10)
            notebook = ttk.Notebook(body)
            notebook.pack(fill='both', expand=True)

            tab_store = tk.Frame(notebook, bg='white')
            tab_material = tk.Frame(notebook, bg='white')
            tab_tx = tk.Frame(notebook, bg='white')
            notebook.add(tab_store, text='Sales by Store')
            notebook.add(tab_material, text='Sales by Material')
            notebook.add(tab_tx, text='Transactions')
            tab_charts = None
            canvas_store = None
            canvas_mat = None
            if HAS_MATPLOTLIB:
                tab_charts = tk.Frame(notebook, bg='white')
                notebook.add(tab_charts, text='Charts')

            # Trees
            store_cols = ("Store","Transactions","Total Sales")
            store_tree = ttk.Treeview(tab_store, columns=store_cols, show='headings')
            for c in store_cols:
                store_tree.heading(c, text=c)
                store_tree.column(c, width=200 if c=="Store" else 140)
            store_tree.pack(fill='both', expand=True, side='left', padx=5, pady=5)
            ttk.Scrollbar(tab_store, orient='vertical', command=store_tree.yview).pack(side='right', fill='y')
            store_tree.configure(yscrollcommand=lambda *a: None)

            mat_cols = ("Material","Qty Sold","Sales Total")
            mat_tree = ttk.Treeview(tab_material, columns=mat_cols, show='headings')
            for c in mat_cols:
                mat_tree.heading(c, text=c)
                mat_tree.column(c, width=220 if c=="Material" else 140)
            mat_tree.pack(fill='both', expand=True, side='left', padx=5, pady=5)
            ttk.Scrollbar(tab_material, orient='vertical', command=mat_tree.yview).pack(side='right', fill='y')
            mat_tree.configure(yscrollcommand=lambda *a: None)

            tx_cols = ("Time","Store","Customer","Material","Qty","Unit Price","Total")
            tx_tree = ttk.Treeview(tab_tx, columns=tx_cols, show='headings')
            for c in tx_cols:
                tx_tree.heading(c, text=c)
                tx_tree.column(c, width=130)
            tx_tree.pack(fill='both', expand=True, side='left', padx=5, pady=5)
            ttk.Scrollbar(tab_tx, orient='vertical', command=tx_tree.yview).pack(side='right', fill='y')
            tx_tree.configure(yscrollcommand=lambda *a: None)

            # Load stores
            store_map = {"All Stores": None}
            def load_stores():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT id, name FROM stores ORDER BY name")
                    rows = cur.fetchall()
                    conn.close()
                    values = ["All Stores"]
                    pre_disp = None
                    for sid, name in rows:
                        disp = f"{name} (ID:{sid})"
                        store_map[disp] = sid
                        values.append(disp)
                        try:
                            if preselected_store_id is not None and sid == preselected_store_id:
                                pre_disp = disp
                        except Exception:
                            pre_disp = None
                    store_cb['values'] = values
                    if pre_disp:
                        store_cb.set(pre_disp)
                    else:
                        store_cb.set(values[0])
                except Exception:
                    store_cb['values'] = ["All Stores"]
                    store_cb.set("All Stores")

            def set_range(days=0):
                try:
                    end = date.today()
                    start = end if days == 0 else (end if days == 0 else end)
                    if days > 0:
                        from datetime import timedelta
                        start = end - timedelta(days=days-1)
                    start_var.set(start.isoformat())
                    end_var.set(end.isoformat())
                    refresh()
                except Exception:
                    pass

            def validate_date(s):
                try:
                    datetime.strptime(s, '%Y-%m-%d')
                    return True
                except Exception:
                    return False

            def refresh():
                # Validate dates
                s = start_var.get().strip()
                e = end_var.get().strip()
                if not (validate_date(s) and validate_date(e)):
                    try:
                        messagebox.showerror("Validation", "Dates must be in YYYY-MM-DD format")
                    except Exception:
                        pass
                    return
                sid = store_map.get(store_var.get())

                # Build where clause
                where = "WHERE date(t.transaction_date) BETWEEN ? AND ?"
                params = [s, e]
                if sid:
                    where += " AND t.store_id = ?"
                    params.append(sid)

                # Summary metrics
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    # Total sales and transactions
                    cur.execute(
                        f"SELECT COALESCE(SUM(t.total_amount),0), COUNT(*) FROM transactions t {where}",
                        params
                    )
                    total_sales, tx_count = cur.fetchone()
                    totals_var.set(f"{float(total_sales):,.0f}")
                    tx_var.set(str(tx_count))
                    avg_var.set(f"{(float(total_sales)/tx_count):,.0f}" if tx_count else "0")

                    # Top material by sales amount
                    cur.execute(
                        f"""
                        SELECT bm.name, COALESCE(SUM(t.total_amount),0) AS total
                        FROM transactions t
                        JOIN building_materials bm ON bm.id = t.material_id
                        {where}
                        GROUP BY bm.id
                        ORDER BY total DESC
                        LIMIT 1
                        """,
                        params
                    )
                    r = cur.fetchone()
                    top_mat_var.set(r[0] if r else '-')

                    # Low stock count (ignores date range, inventory is current)
                    cur.execute("SELECT COUNT(*) FROM inventory WHERE quantity <= reorder_level")
                    low_stock_var.set(str(cur.fetchone()[0]))

                    # Aggregation by store
                    cur.execute(
                        f"""
                        SELECT s.name, COUNT(*) AS tx, COALESCE(SUM(t.total_amount),0) AS total
                        FROM transactions t
                        JOIN stores s ON s.id = t.store_id
                        {where}
                        GROUP BY s.id
                        ORDER BY total DESC
                        """,
                        params
                    )
                    rows_store = cur.fetchall()

                    # Aggregation by material
                    cur.execute(
                        f"""
                        SELECT bm.name, COALESCE(SUM(t.quantity),0) AS qty, COALESCE(SUM(t.total_amount),0) AS total
                        FROM transactions t
                        JOIN building_materials bm ON bm.id = t.material_id
                        {where}
                        GROUP BY bm.id
                        ORDER BY total DESC
                        """,
                        params
                    )
                    rows_mat = cur.fetchall()

                    # Transaction details
                    cur.execute(
                        f"""
                        SELECT t.transaction_date, s.name, COALESCE(t.customer_name,''), bm.name, t.quantity, t.unit_price, t.total_amount
                        FROM transactions t
                        JOIN stores s ON s.id = t.store_id
                        JOIN building_materials bm ON bm.id = t.material_id
                        {where}
                        ORDER BY t.transaction_date DESC
                        """,
                        params
                    )
                    rows_tx = cur.fetchall()

                    conn.close()
                except Exception as e2:
                    rows_store, rows_mat, rows_tx = [], [], []
                    try:
                        messagebox.showerror("Error", f"Failed to load analytics: {str(e2)}")
                    except Exception:
                        pass

                # Update trees
                for t in store_tree.get_children():
                    store_tree.delete(t)
                for name, txc, total in rows_store:
                    try:
                        total_fmt = f"{float(total):,.0f}"
                    except Exception:
                        total_fmt = str(total)
                    store_tree.insert('', 'end', values=(name, txc, total_fmt))

                for t in mat_tree.get_children():
                    mat_tree.delete(t)
                for name, qty, total in rows_mat:
                    try:
                        total_fmt = f"{float(total):,.0f}"
                    except Exception:
                        total_fmt = str(total)
                    try:
                        qty_fmt = int(qty)
                    except Exception:
                        qty_fmt = qty
                    mat_tree.insert('', 'end', values=(name, qty_fmt, total_fmt))

                for t in tx_tree.get_children():
                    tx_tree.delete(t)
                for r in rows_tx:
                    vals = list(r)
                    try:
                        vals[4] = int(vals[4]) if vals[4] is not None else ''
                    except Exception:
                        pass
                    try:
                        vals[5] = f"{float(vals[5]):,.0f}" if vals[5] is not None else ''
                    except Exception:
                        pass
                    try:
                        vals[6] = f"{float(vals[6]):,.0f}" if vals[6] is not None else ''
                    except Exception:
                        pass
                    tx_tree.insert('', 'end', values=vals)

                # Charts
                if HAS_MATPLOTLIB and tab_charts is not None:
                    for w in tab_charts.winfo_children():
                        w.destroy()
                    # Sales by store chart
                    try:
                        fig1 = plt.Figure(figsize=(5,3), dpi=100)
                        ax1 = fig1.add_subplot(111)
                        names = [r[0] for r in rows_store][:10]
                        totals = [r[2] for r in rows_store][:10]
                        ax1.bar(names, totals, color="#3498db")
                        ax1.set_title('Top Stores by Sales')
                        ax1.tick_params(axis='x', rotation=45)
                        canvas_store = FigureCanvasTkAgg(fig1, master=tab_charts)
                        canvas_store.get_tk_widget().pack(side='top', fill='both', expand=False, padx=10, pady=10)
                    except Exception:
                        pass
                    # Sales by material chart
                    try:
                        fig2 = plt.Figure(figsize=(5,3), dpi=100)
                        ax2 = fig2.add_subplot(111)
                        names2 = [r[0] for r in rows_mat][:10]
                        totals2 = [r[2] for r in rows_mat][:10]
                        ax2.bar(names2, totals2, color="#2ecc71")
                        ax2.set_title('Top Materials by Sales')
                        ax2.tick_params(axis='x', rotation=45)
                        canvas_mat = FigureCanvasTkAgg(fig2, master=tab_charts)
                        canvas_mat.get_tk_widget().pack(side='top', fill='both', expand=False, padx=10, pady=10)
                    except Exception:
                        pass

                # Audit
                try:
                    details = { 'start': s, 'end': e, 'store': store_var.get() }
                    self.log_audit_action(self.current_user['id'], "View Store Analytics", json.dumps(details))
                except Exception:
                    pass

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"store_analytics_tx_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Transactions", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"), ("All files","*.*")])
                    if not filename:
                        return
                    s = start_var.get().strip()
                    e = end_var.get().strip()
                    sid = store_map.get(store_var.get())
                    where = "WHERE date(t.timestamp) BETWEEN ? AND ?"
                    params = [s, e]
                    if sid:
                        where += " AND t.store_id = ?"
                        params.append(sid)
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(
                        f"""
                        SELECT t.timestamp, s.name AS store, COALESCE(t.customer_name,''), bm.name AS material, t.quantity, t.unit_price, t.total_amount
                        FROM transactions t
                        JOIN stores s ON s.id = t.store_id
                        JOIN building_materials bm ON bm.id = t.material_id
                        {where}
                        ORDER BY t.timestamp DESC
                        """,
                        params
                    )
                    rows = cur.fetchall()
                    conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(["Timestamp","Store","Customer","Material","Quantity","Unit Price","Total Amount"])
                        for r in rows:
                            writer.writerow(r)
                    messagebox.showinfo("Export", "Transactions exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            # Wire up
            refresh_btn.config(command=refresh)
            export_btn.config(command=export_csv)

            # Load initial data
            load_stores()
            refresh()

            # Shortcuts
            win.bind('<F5>', lambda e: refresh())
            win.bind('<Escape>', lambda e: win.destroy())
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Store Analytics: {str(e)}")
            except Exception:
                pass

# ================ financial report =========================

    def show_financial_reports(self):
        try:
            win = tk.Toplevel(self.root)
            win.title("Financial Reports")
            win.geometry("1000x680")
            win.configure(bg='white')
            win.grab_set()

            # Header
            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Financial Reports", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filt = tk.LabelFrame(win, text="Filters", bg='white')
            filt.pack(fill='x', padx=10, pady=(0,10))
            tk.Label(filt, text="Start (YYYY-MM-DD):", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            start_var = tk.StringVar(value=date.today().isoformat())
            tk.Entry(filt, textvariable=start_var, width=15).grid(row=0, column=1, sticky='w', padx=5)
            tk.Label(filt, text="End (YYYY-MM-DD):", bg='white').grid(row=0, column=2, sticky='e', padx=5, pady=6)
            end_var = tk.StringVar(value=date.today().isoformat())
            tk.Entry(filt, textvariable=end_var, width=15).grid(row=0, column=3, sticky='w', padx=5)
            tk.Label(filt, text="Store:", bg='white').grid(row=0, column=4, sticky='e', padx=5)
            store_var = tk.StringVar()
            store_cb = ttk.Combobox(filt, textvariable=store_var, state='readonly', width=28)
            store_cb.grid(row=0, column=5, sticky='w', padx=5)

            act = tk.Frame(filt, bg='white')
            act.grid(row=0, column=6, padx=5, sticky='w')
            refresh_btn = tk.Button(act, text="Refresh", bg="#3498db", fg="white")
            refresh_btn.pack(side='left')
            export_btn = tk.Button(act, text="Export CSV")
            export_btn.pack(side='left', padx=6)

            # Summary cards
            cards = tk.Frame(win, bg='white')
            cards.pack(fill='x', padx=10, pady=(0,5))
            revenue_var = tk.StringVar(value='0')
            tx_var = tk.StringVar(value='0')
            avg_ticket_var = tk.StringVar(value='0')
            top_store_var = tk.StringVar(value='-')
            top_material_var = tk.StringVar(value='-')

            def make_card(parent, title, var, color):
                f = tk.Frame(parent, bg=color, width=200, height=80)
                f.pack(side='left', padx=8, pady=5)
                f.pack_propagate(False)
                tk.Label(f, textvariable=var, font=('Arial', 22, 'bold'), bg=color, fg='white').pack(expand=True)
                tk.Label(f, text=title, font=('Arial', 11), bg=color, fg='white').pack()
                return f

            make_card(cards, "Revenue (FCFA)", revenue_var, "#2ecc71")
            make_card(cards, "Transactions", tx_var, "#3498db")
            make_card(cards, "Avg Ticket", avg_ticket_var, "#9b59b6")
            make_card(cards, "Top Store", top_store_var, "#f39c12")
            make_card(cards, "Top Material", top_material_var, "#e67e22")

            # Notebook
            body = tk.Frame(win, bg='white')
            body.pack(fill='both', expand=True, padx=10, pady=10)
            nb = ttk.Notebook(body)
            nb.pack(fill='both', expand=True)

            tab_profit = tk.Frame(nb, bg='white')
            tab_store = tk.Frame(nb, bg='white')
            tab_material = tk.Frame(nb, bg='white')
            tab_tx = tk.Frame(nb, bg='white')
            nb.add(tab_profit, text='Profit & Loss')
            nb.add(tab_store, text='Revenue by Store')
            nb.add(tab_material, text='Revenue by Material')
            nb.add(tab_tx, text='Transactions')

            # Profit & Loss (simplified: revenue = sales total; COGS approximated from inventory unit_price if available is already used as sale price, so margin unknown; show revenue only)
            pnl_text = tk.Text(tab_profit, height=8)
            pnl_text.pack(fill='x', padx=8, pady=8)

            # Trees
            store_cols = ("Store","Transactions","Revenue")
            store_tree = ttk.Treeview(tab_store, columns=store_cols, show='headings')
            for c in store_cols:
                store_tree.heading(c, text=c)
                store_tree.column(c, width=200 if c=="Store" else 140)
            store_tree.pack(fill='both', expand=True, side='left', padx=5, pady=5)
            ttk.Scrollbar(tab_store, orient='vertical', command=store_tree.yview).pack(side='right', fill='y')

            mat_cols = ("Material","Qty","Revenue")
            mat_tree = ttk.Treeview(tab_material, columns=mat_cols, show='headings')
            for c in mat_cols:
                mat_tree.heading(c, text=c)
                mat_tree.column(c, width=220 if c=="Material" else 140)
            mat_tree.pack(fill='both', expand=True, side='left', padx=5, pady=5)
            ttk.Scrollbar(tab_material, orient='vertical', command=mat_tree.yview).pack(side='right', fill='y')

            tx_cols = ("Time","Store","Customer","Material","Qty","Unit Price","Total")
            tx_tree = ttk.Treeview(tab_tx, columns=tx_cols, show='headings')
            for c in tx_cols:
                tx_tree.heading(c, text=c)
                tx_tree.column(c, width=130)
            tx_tree.pack(fill='both', expand=True, side='left', padx=5, pady=5)
            ttk.Scrollbar(tab_tx, orient='vertical', command=tx_tree.yview).pack(side='right', fill='y')

            # Stores list
            store_map = {"All Stores": None}
            def load_stores():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT id, name FROM stores ORDER BY name")
                    rows = cur.fetchall()
                    conn.close()
                    values = ["All Stores"]
                    for sid, name in rows:
                        disp = f"{name} (ID:{sid})"
                        store_map[disp] = sid
                        values.append(disp)
                    store_cb['values'] = values
                    store_cb.set(values[0])
                except Exception:
                    store_cb['values'] = ["All Stores"]
                    store_cb.set("All Stores")

            def validate_date(s):
                try:
                    datetime.strptime(s, '%Y-%m-%d')
                    return True
                except Exception:
                    return False

            def refresh():
                s = start_var.get().strip()
                e = end_var.get().strip()
                if not (validate_date(s) and validate_date(e)):
                    try:
                        messagebox.showerror("Validation", "Dates must be in YYYY-MM-DD format")
                    except Exception:
                        pass
                    return
                sid = store_map.get(store_var.get())

                where = "WHERE date(t.timestamp) BETWEEN ? AND ?"
                params = [s, e]
                if sid:
                    where += " AND t.store_id = ?"
                    params.append(sid)

                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    # Revenue & tx count
                    cur.execute(f"SELECT COALESCE(SUM(t.total_amount),0), COUNT(*) FROM transactions t {where}", params)
                    total_rev, txc = cur.fetchone()
                    revenue_var.set(f"{float(total_rev):,.0f}")
                    tx_var.set(str(txc))
                    avg_ticket_var.set(f"{(float(total_rev)/txc):,.0f}" if txc else "0")

                    # Top store
                    cur.execute(
                        f"""
                        SELECT s.name, COALESCE(SUM(t.total_amount),0) AS total
                        FROM transactions t
                        JOIN stores s ON s.id = t.store_id
                        {where}
                        GROUP BY s.id
                        ORDER BY total DESC
                        LIMIT 1
                        """, params
                    )
                    r = cur.fetchone()
                    top_store_var.set(r[0] if r else '-')

                    # Top material
                    cur.execute(
                        f"""
                        SELECT bm.name, COALESCE(SUM(t.total_amount),0) AS total
                        FROM transactions t
                        JOIN building_materials bm ON bm.id = t.material_id
                        {where}
                        GROUP BY bm.id
                        ORDER BY total DESC
                        LIMIT 1
                        """, params
                    )
                    r2 = cur.fetchone()
                    top_material_var.set(r2[0] if r2 else '-')

                    # P&L text (simplified)
                    pnl_text.delete('1.0', 'end')
                    pnl_text.insert('end', f"Period: {s} to {e}\n")
                    pnl_text.insert('end', f"Revenue: {float(total_rev):,.0f} FCFA\n")
                    pnl_text.insert('end', f"Transactions: {txc}\n")
                    if txc:
                        pnl_text.insert('end', f"Average Ticket: {(float(total_rev)/txc):,.0f} FCFA\n")
                    pnl_text.insert('end', "Note: COGS and Expenses tracking not available; showing revenue only.\n")

                    # Store aggregation
                    cur.execute(
                        f"""
                        SELECT s.name, COUNT(*) AS tx, COALESCE(SUM(t.total_amount),0) AS total
                        FROM transactions t
                        JOIN stores s ON s.id = t.store_id
                        {where}
                        GROUP BY s.id
                        ORDER BY total DESC
                        """, params
                    )
                    rows_store = cur.fetchall()

                    # Material aggregation
                    cur.execute(
                        f"""
                        SELECT bm.name, COALESCE(SUM(t.quantity),0) AS qty, COALESCE(SUM(t.total_amount),0) AS total
                        FROM transactions t
                        JOIN building_materials bm ON bm.id = t.material_id
                        {where}
                        GROUP BY bm.id
                        ORDER BY total DESC
                        """, params
                    )
                    rows_mat = cur.fetchall()

                    # Transactions
                    cur.execute(
                        f"""
                        SELECT t.timestamp, s.name, COALESCE(t.customer_name,''), bm.name, t.quantity, t.unit_price, t.total_amount
                        FROM transactions t
                        JOIN stores s ON s.id = t.store_id
                        JOIN building_materials bm ON bm.id = t.material_id
                        {where}
                        ORDER BY t.timestamp DESC
                        """, params
                    )
                    rows_tx = cur.fetchall()
                    conn.close()
                except Exception as e2:
                    rows_store, rows_mat, rows_tx = [], [], []
                    try:
                        messagebox.showerror("Error", f"Failed to load financials: {str(e2)}")
                    except Exception:
                        pass

                # Update trees
                for titem in store_tree.get_children():
                    store_tree.delete(titem)
                for name, txc2, total in rows_store:
                    try:
                        total_fmt = f"{float(total):,.0f}"
                    except Exception:
                        total_fmt = str(total)
                    store_tree.insert('', 'end', values=(name, txc2, total_fmt))

                for titem in mat_tree.get_children():
                    mat_tree.delete(titem)
                for name, qty, total in rows_mat:
                    try:
                        total_fmt = f"{float(total):,.0f}"
                    except Exception:
                        total_fmt = str(total)
                    try:
                        qty_fmt = int(qty)
                    except Exception:
                        qty_fmt = qty
                    mat_tree.insert('', 'end', values=(name, qty_fmt, total_fmt))

                for titem in tx_tree.get_children():
                    tx_tree.delete(titem)
                for r in rows_tx:
                    vals = list(r)
                    try:
                        vals[4] = int(vals[4]) if vals[4] is not None else ''
                    except Exception:
                        pass
                    try:
                        vals[5] = f"{float(vals[5]):,.0f}" if vals[5] is not None else ''
                    except Exception:
                        pass
                    try:
                        vals[6] = f"{float(vals[6]):,.0f}" if vals[6] is not None else ''
                    except Exception:
                        pass
                    tx_tree.insert('', 'end', values=vals)

                # Audit
                try:
                    details = { 'start': s, 'end': e, 'store': store_var.get() }
                    self.log_audit_action(self.current_user['id'], "View Financial Reports", json.dumps(details))
                except Exception:
                    pass

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"financial_transactions_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Transactions", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"), ("All files","*.*")])
                    if not filename:
                        return
                    s = start_var.get().strip()
                    e = end_var.get().strip()
                    sid = store_map.get(store_var.get())
                    where = "WHERE date(t.timestamp) BETWEEN ? AND ?"
                    params = [s, e]
                    if sid:
                        where += " AND t.store_id = ?"
                        params.append(sid)
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(
                        f"""
                        SELECT t.timestamp, s.name AS store, COALESCE(t.customer_name,''), bm.name AS material, t.quantity, t.unit_price, t.total_amount
                        FROM transactions t
                        JOIN stores s ON s.id = t.store_id
                        JOIN building_materials bm ON bm.id = t.material_id
                        {where}
                        ORDER BY t.timestamp DESC
                        """,
                        params
                    )
                    rows = cur.fetchall()
                    conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(["Timestamp","Store","Customer","Material","Quantity","Unit Price","Total Amount"])
                        for r in rows:
                            writer.writerow(r)
                    messagebox.showinfo("Export", "Transactions exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            # Wire
            refresh_btn.config(command=refresh)
            export_btn.config(command=export_csv)

            # Load initial
            load_stores()
            refresh()

            # Shortcuts
            win.bind('<F5>', lambda e: refresh())
            win.bind('<Escape>', lambda e: win.destroy())
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Financial Reports: {str(e)}")
            except Exception:
                pass

    # Wrapper methods to bridge class menu commands to module-level implementations
    # This avoids AttributeError by delegating to the globally defined functions below.
    def show_create_contract(self):
        # Call module-level implementation if available; otherwise show a safe placeholder
        func = globals().get('show_create_contract')
        if callable(func):
            return func(self)
        try:
            messagebox.showinfo("Feature", "Create Contract will be implemented here")
        except Exception:
            pass
        return None

    def show_manage_contracts(self):
        # Prefer class method implementation if available; otherwise call module-level function
        if hasattr(self, '_impl_show_manage_contracts'):
            return self._impl_show_manage_contracts()
        if 'show_manage_contracts' in globals() and callable(globals()['show_manage_contracts']):
            return globals()['show_manage_contracts'](self)
        # Fallback placeholder to avoid KeyError
        try:
            messagebox.showinfo("Feature", "Manage Contracts will be implemented here")
        except Exception:
            pass
        return None

    # Ensure show_edit_profile is available on the instance.
    # The real implementation currently exists as a module-level function `show_edit_profile(self)`.
    # Delegate to it if present so menu callbacks like `self.show_edit_profile()` work.

    # Concrete implementation: open Manage Contracts window for contract owners
    def _impl_show_manage_contracts(self):
        try:
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Contracts", "You must be logged in to manage contracts.")
                return
            role = self.current_user.get('role')
            if role not in ("contract_owner", "administrator"):
                messagebox.showwarning("Access Denied", "Only Contract Owners or Administrators can manage contracts.")
                return

            win = tk.Toplevel(self.root)
            win.title("Manage Contracts")
            win.geometry("1200x700")
            win.configure(bg='white')
            win.grab_set()

            # Header with filters
            header = tk.Frame(win, bg='white'); header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Contract Management", font=('Arial', 18, 'bold'), bg='white').pack(side='left')
            right = tk.Frame(header, bg='white'); right.pack(side='right')
            tk.Label(right, text="Status:", bg='white').pack(side='left', padx=(0,5))
            status_var = tk.StringVar(value='All')
            status_cb = ttk.Combobox(right, textvariable=status_var, state='readonly', width=16)
            status_cb['values'] = ['All','Draft','Pending Review','Active','Completed','On Hold','Cancelled']
            status_cb.pack(side='left')
            tk.Label(right, text="Search:", bg='white').pack(side='left', padx=(10,5))
            q_var = tk.StringVar()
            tk.Entry(right, textvariable=q_var, width=22).pack(side='left')
            refresh_btn = tk.Button(right, text='Refresh', bg='#3498db', fg='white')
            refresh_btn.pack(side='left', padx=6)

            # Table
            frame = tk.Frame(win, bg='white'); frame.pack(fill='both', expand=True, padx=10, pady=10)
            sy = ttk.Scrollbar(frame); sy.pack(side='right', fill='y')
            sx = ttk.Scrollbar(frame, orient='horizontal'); sx.pack(side='bottom', fill='x')
            cols = ("ID","Title","Contractor","Kind","Materials","Budget","Start Date","End Date","Status")
            tree = ttk.Treeview(frame, columns=cols, show='headings', yscrollcommand=sy.set, xscrollcommand=sx.set)
            tree.pack(fill='both', expand=True)
            sy.config(command=tree.yview); sx.config(command=tree.xview)
            config = [
                ("ID",60,'center'), ("Title",240,'w'), ("Contractor",160,'w'),
                ("Kind",150,'center'), ("Materials",100,'center'),
                ("Budget",110,'e'), ("Start Date",110,'center'), ("End Date",110,'center'), ("Status",110,'center')
            ]
            for c,w,a in config:
                tree.heading(c, text=c); tree.column(c, width=w, anchor=a)

            # Actions
            btns = tk.Frame(win, bg='white'); btns.pack(fill='x', padx=10, pady=(0,10))
            # Left-side action buttons
            view_btn = tk.Button(btns, text='View', bg='#2980b9', fg='white', width=10)
            view_btn.pack(side='left')
            edit_btn = tk.Button(btns, text='Edit', bg='#f39c12', fg='white', width=10)
            edit_btn.pack(side='left', padx=(8,0))
            assign_btn = tk.Button(btns, text='Assign', bg='#27ae60', fg='white', width=10)
            assign_btn.pack(side='left', padx=(8,0))
            pdf_btn = tk.Button(btns, text='Print PDF', bg='#8e44ad', fg='white', width=12)
            pdf_btn.pack(side='left', padx=(8,0))
            # Payments management for contracts
            payments_btn = tk.Button(btns, text='Payments', bg='#16a085', fg='white', width=12)
            payments_btn.pack(side='left', padx=(8,0))
            refresh_btn2 = tk.Button(btns, text='Refresh', bg='#3498db', fg='white', width=10)
            refresh_btn2.pack(side='left', padx=(8,0))
            delete_btn = tk.Button(btns, text='Delete', bg='#e74c3c', fg='white', width=10)
            delete_btn.pack(side='left', padx=(8,0))
            # Right-side close
            close_btn = tk.Button(btns, text='Close', bg='#dc3545', fg='white', width=10, command=win.destroy)
            close_btn.pack(side='right')

            def get_selected_contract_id():
                sel = tree.selection()
                if not sel:
                    messagebox.showwarning('Select', 'Please select a contract first.')
                    return None
                try:
                    return int(tree.item(sel[0])['values'][0])
                except Exception:
                    return None

            def view_contract():
                cid = get_selected_contract_id()
                if not cid:
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute('''
                        SELECT c.id, c.title, c.description, COALESCE(u.full_name,'Not Assigned') AS contractor,
                               COALESCE(c.contract_kind,'Labour Only') AS contract_kind, COALESCE(c.includes_materials,0) AS includes_materials,
                               c.budget, c.start_date, c.end_date, c.status, c.created_date
                        FROM contracts c LEFT JOIN users u ON c.contractor_id = u.id
                        WHERE c.id = ? AND c.contract_owner_id = ?
                    ''', (cid, self.current_user['id']))
                    row = cur.fetchone(); conn.close()
                    if not row:
                        messagebox.showerror('Error', 'Contract not found or access denied.')
                        return
                    dlg = tk.Toplevel(win); dlg.title(f"Contract #{row[0]} - {row[1]}"); dlg.geometry('800x620'); dlg.configure(bg='white'); dlg.grab_set(); dlg.transient(win)
                    frm = tk.Frame(dlg, bg='white', padx=16, pady=16); frm.pack(fill='both', expand=True)
                    # Unpack with new fields included
                    (cid_v, title_v, desc_v, contractor_v, kind_v, inc_v, budget_v, sd_v, ed_v, status_v, created_v) = row
                    fields = [
                        ('ID', cid_v),
                        ('Title', title_v),
                        ('Contractor', contractor_v),
                        ('Contract Kind', kind_v or 'Labour Only'),
                        ('Includes Materials', 'Yes' if (inc_v==1 or inc_v==True) else 'No'),
                        ('Budget', f"{(budget_v or 0):,.0f}"),
                        ('Start Date', sd_v or ''),
                        ('End Date', ed_v or ''),
                        ('Status', status_v or ''),
                        ('Created', created_v or '')
                    ]
                    rindex = 0
                    for label, value in fields:
                        tk.Label(frm, text=f"{label}:", bg='white', fg='#2c3e50', font=('Arial', 10, 'bold')).grid(row=rindex, column=0, sticky='ne', padx=(0,10), pady=4)
                        tk.Label(frm, text=str(value if value is not None else ''), bg='white').grid(row=rindex, column=1, sticky='w')
                        rindex += 1
                    # Description block
                    tk.Label(frm, text='Description:', bg='white', fg='#2c3e50', font=('Arial', 10, 'bold')).grid(row=rindex, column=0, sticky='ne', padx=(0,10), pady=4)
                    txt = tk.Text(frm, height=10, width=60); txt.grid(row=rindex, column=1, sticky='w'); txt.insert('1.0', str(desc_v or '')); txt.config(state='disabled')
                    rindex += 1
                    tk.Button(frm, text='Close', bg='#6c757d', fg='white', width=10, command=dlg.destroy).grid(row=rindex, column=1, sticky='e', pady=(12,0))
                except Exception as e:
                    messagebox.showerror('Error', f'Failed to load details: {e}')

            def edit_contract():
                cid = get_selected_contract_id()
                if not cid:
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Disallow edits if both parties have signed
                    cur.execute('SELECT digital_signature_owner IS NOT NULL, digital_signature_contractor IS NOT NULL FROM contracts WHERE id = ? AND contract_owner_id = ?', (cid, self.current_user['id']))
                    sigs = cur.fetchone()
                    if sigs and all(sigs):
                        conn.close(); messagebox.showwarning('Locked', 'This contract is fully signed by both parties and can no longer be edited.'); return
                    cur.execute('SELECT title, description, budget, start_date, end_date, status FROM contracts WHERE id = ? AND contract_owner_id = ?', (cid, self.current_user['id']))
                    row = cur.fetchone()
                    if not row:
                        conn.close(); messagebox.showerror('Error','Contract not found or access denied.'); return
                    title, desc, budget, sd, ed, status = row
                    dlg = tk.Toplevel(win); dlg.title(f'Edit Contract #{cid}'); dlg.geometry('700x520'); dlg.configure(bg='white'); dlg.grab_set(); dlg.transient(win)
                    frm = tk.Frame(dlg, bg='white', padx=16, pady=16); frm.pack(fill='both', expand=True)
                    # Fields
                    tk.Label(frm, text='Title*', bg='white').grid(row=0, column=0, sticky='w'); title_e = tk.Entry(frm, width=50); title_e.grid(row=0, column=1, sticky='w'); title_e.insert(0, title or '')
                    tk.Label(frm, text='Budget', bg='white').grid(row=1, column=0, sticky='w'); budget_e = tk.Entry(frm, width=20); budget_e.grid(row=1, column=1, sticky='w'); budget_e.insert(0, '' if budget is None else str(budget))
                    tk.Label(frm, text='Start Date (YYYY-MM-DD)', bg='white').grid(row=2, column=0, sticky='w'); sd_e = tk.Entry(frm, width=20); sd_e.grid(row=2, column=1, sticky='w'); sd_e.insert(0, sd or '')
                    tk.Label(frm, text='End Date (YYYY-MM-DD)', bg='white').grid(row=3, column=0, sticky='w'); ed_e = tk.Entry(frm, width=20); ed_e.grid(row=3, column=1, sticky='w'); ed_e.insert(0, ed or '')
                    tk.Label(frm, text='Status', bg='white').grid(row=4, column=0, sticky='w'); status_var2 = tk.StringVar(value=status or 'Draft'); status_cb2 = ttk.Combobox(frm, textvariable=status_var2, state='readonly', values=['Draft','Pending Review','Active','Completed','On Hold','Cancelled']); status_cb2.grid(row=4, column=1, sticky='w')
                    tk.Label(frm, text='Description', bg='white').grid(row=5, column=0, sticky='nw'); desc_t = tk.Text(frm, width=60, height=10); desc_t.grid(row=5, column=1, sticky='w'); desc_t.insert('1.0', desc or '')
                    def save():
                        t = title_e.get().strip()
                        if not t:
                            messagebox.showerror('Error','Title is required.'); return
                        try:
                            b = float(budget_e.get().replace(',','')) if budget_e.get().strip() else None
                        except Exception:
                            messagebox.showerror('Error','Budget must be a number.'); return
                        sdv = sd_e.get().strip() or None
                        edv = ed_e.get().strip() or None
                        stv = status_var2.get()
                        dsc = desc_t.get('1.0','end').strip()
                        try:
                            cur2 = conn.cursor()
                            cur2.execute('UPDATE contracts SET title=?, description=?, budget=?, start_date=?, end_date=?, status=? WHERE id=? AND contract_owner_id=?', (t, dsc, b, sdv, edv, stv, cid, self.current_user['id']))
                            conn.commit()
                            try:
                                self.log_audit_action(self.current_user['id'], 'Edit Contract', f'Contract {cid} updated')
                            except Exception:
                                pass
                            messagebox.showinfo('Saved','Contract updated successfully.')
                            dlg.destroy(); conn.close(); load_contracts()
                        except Exception as e:
                            messagebox.showerror('Error', f'Failed to save: {e}')
                    btnrow = tk.Frame(frm, bg='white'); btnrow.grid(row=6, column=1, sticky='e', pady=(10,0))
                    tk.Button(btnrow, text='Save', bg='#27ae60', fg='white', width=10, command=save).pack(side='left')
                    tk.Button(btnrow, text='Cancel', bg='#e74c3c', fg='white', width=10, command=dlg.destroy).pack(side='left', padx=(8,0))
                except Exception as e:
                    messagebox.showerror('Error', f'Failed to open editor: {e}')

            def assign_contractor():
                cid = get_selected_contract_id()
                if not cid:
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT contractor_id FROM contracts WHERE id=? AND contract_owner_id=?", (cid, self.current_user['id']))
                    r = cur.fetchone()
                    if not r:
                        conn.close(); messagebox.showerror('Error','Contract not found or access denied.'); return
                    current_contractor = r[0]
                    # Load contractors scoped to creator unless admin
                    q = "SELECT id, full_name FROM users WHERE role='contractor' AND is_active = 1 "
                    params = []
                    try:
                        if self.current_user.get('role') != 'administrator':
                            q += "AND created_by = ? "
                            params.append(self.current_user['id'])
                    except Exception:
                        pass
                    q += "ORDER BY full_name"
                    cur.execute(q, params)
                    users = cur.fetchall()
                    dlg = tk.Toplevel(win); dlg.title(f'Assign Contractor - Contract #{cid}'); dlg.geometry('500x260'); dlg.configure(bg='white'); dlg.grab_set(); dlg.transient(win)
                    frm = tk.Frame(dlg, bg='white', padx=16, pady=16); frm.pack(fill='both', expand=True)
                    tk.Label(frm, text='Select Contractor:', bg='white').pack(anchor='w')
                    var = tk.StringVar()
                    combo = ttk.Combobox(frm, textvariable=var, state='readonly', width=45)
                    options = [f"{u[0]} - {u[1]}" for u in users]
                    combo['values'] = options
                    # preselect
                    if current_contractor:
                        try:
                            name_map = {str(uid): name for uid, name in users}
                            combo.set(f"{current_contractor} - {name_map.get(str(current_contractor), name_map.get(int(current_contractor), ''))}")
                        except Exception:
                            pass
                    combo.pack(fill='x', pady=(6,12))
                    def save_assign():
                        sel = var.get()
                        if not sel:
                            messagebox.showerror('Error','Please select a contractor.'); return
                        try:
                            new_id = int(sel.split(' - ')[0])
                        except Exception:
                            messagebox.showerror('Error','Invalid selection.'); return
                        try:
                            # Disallow reassignment if both parties have signed
                            cur2 = conn.cursor();
                            cur2.execute('SELECT digital_signature_owner IS NOT NULL, digital_signature_contractor IS NOT NULL FROM contracts WHERE id=? AND contract_owner_id=?', (cid, self.current_user['id']))
                            sigs = cur2.fetchone()
                            if sigs and all(sigs):
                                messagebox.showwarning('Locked', 'This contract is fully signed and cannot be reassigned.'); return
                            cur2.execute('UPDATE contracts SET contractor_id=? WHERE id=? AND contract_owner_id=?', (new_id, cid, self.current_user['id']))
                            conn.commit()
                            try:
                                self.log_audit_action(self.current_user['id'], 'Assign Contractor', f'Contract {cid} -> contractor {new_id}')
                            except Exception:
                                pass
                            messagebox.showinfo('Assigned','Contractor assigned successfully.')
                            dlg.destroy(); conn.close(); load_contracts()
                        except Exception as e:
                            messagebox.showerror('Error', f'Failed to assign: {e}')
                    rowb = tk.Frame(frm, bg='white'); rowb.pack(fill='x')
                    tk.Button(rowb, text='Assign', bg='#27ae60', fg='white', width=10, command=save_assign).pack(side='left')
                    tk.Button(rowb, text='Cancel', bg='#e74c3c', fg='white', width=10, command=dlg.destroy).pack(side='right')
                except Exception as e:
                    messagebox.showerror('Error', f'Failed to open assign dialog: {e}')

            def print_contract_pdf():
                try:
                    cid = get_selected_contract_id()
                    if not cid:
                        return
                    # Load contract details with access check
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute(
                        '''
                        SELECT c.id, c.title, c.description,
                               COALESCE(c.contract_kind,'Labour Only') AS contract_kind,
                               COALESCE(c.includes_materials,0) AS includes_materials,
                               c.budget, c.start_date, c.end_date, c.status, c.created_date,
                               owner.full_name AS owner_name,
                               COALESCE(con.full_name, 'Not Assigned') AS contractor_name
                        FROM contracts c
                        JOIN users owner ON c.contract_owner_id = owner.id
                        LEFT JOIN users con ON c.contractor_id = con.id
                        WHERE c.id = ? AND c.contract_owner_id = ?
                        ''', (cid, self.current_user['id'])
                    )
                    row = cur.fetchone(); conn.close()
                    if not row:
                        messagebox.showerror('Error', 'Contract not found or access denied.')
                        return
                    # Ask for destination file
                    filename = filedialog.asksaveasfilename(
                        defaultextension='.pdf',
                        filetypes=[('PDF files','*.pdf'), ('All files','*.*')],
                        title='Save Contract as PDF',
                        initialfile=f'contract_{cid}.pdf'
                    )
                    if not filename:
                        return
                    # Validate path
                    try:
                        self._validate_file_path(filename)
                    except Exception as vex:
                        messagebox.showerror('Security', f'Invalid file path: {vex}')
                        return
                    # Lazy import ReportLab
                    try:
                        from reportlab.lib.pagesizes import A4
                        from reportlab.pdfgen import canvas
                        from reportlab.lib.units import cm
                        from reportlab.lib.utils import simpleSplit
                    except Exception:
                        messagebox.showerror('Missing Library', 'ReportLab is required to print PDF. Please install it with:\n\npip install reportlab')
                        return
                    # Unpack
                    (cid2, title, description, kind, inc, budget, sd, ed, status, created, owner_name, contractor_name) = row
                    c = canvas.Canvas(filename, pagesize=A4)
                    width, height = A4
                    left = 2.0*cm
                    top = height - 2.0*cm
                    # Header
                    c.setFont('Helvetica-Bold', 16)
                    c.drawString(left, top, 'Building Project Contract')
                    c.setFont('Helvetica', 10)
                    c.drawString(left, top-14, f'Contract ID: {cid2}')
                    c.drawString(left, top-28, f'Title: {title}')
                    c.drawString(left, top-42, f'Status: {status}')
                    c.drawString(left, top-56, f'Created: {str(created)}')
                    c.line(left, top-64, width-2.0*cm, top-64)
                    # Parties and info
                    y = top-80
                    c.setFont('Helvetica-Bold', 12); c.drawString(left, y, 'Parties'); y -= 14
                    c.setFont('Helvetica', 10)
                    c.drawString(left, y, f'Owner: {owner_name}'); y -= 14
                    c.drawString(left, y, f'Contractor: {contractor_name}'); y -= 20
                    c.setFont('Helvetica-Bold', 12); c.drawString(left, y, 'Project'); y -= 14
                    c.setFont('Helvetica', 10)
                    c.drawString(left, y, f'Contract Kind: {kind or "Labour Only"}'); y -= 14
                    c.drawString(left, y, f'Includes Materials: {"Yes" if (inc==1 or inc==True) else "No"}'); y -= 14
                    c.drawString(left, y, f'Budget: {"{:,.0f}".format(budget) if budget is not None else "N/A"} FCFA'); y -= 14
                    c.drawString(left, y, f'Start Date: {sd or "N/A"}'); y -= 14
                    c.drawString(left, y, f'End Date: {ed or "N/A"}'); y -= 20
                    # Description (wrapped)
                    c.setFont('Helvetica-Bold', 12); c.drawString(left, y, 'Description'); y -= 14
                    c.setFont('Helvetica', 10)
                    maxw = width - 4.0*cm
                    text = description or ''
                    lines = simpleSplit(text, 'Helvetica', 10, maxw)
                    for line in lines:
                        if y < 2.5*cm:
                            c.showPage()
                            y = height - 2.0*cm
                            c.setFont('Helvetica', 10)
                        c.drawString(left, y, line); y -= 12
                    # Signatures footer
                    # Fetch and show digital signatures (names and dates) at the bottom
                    try:
                        conn2 = self.db_manager.create_connection(); cur2 = conn2.cursor()
                        cur2.execute('SELECT digital_signature_owner, digital_signature_contractor FROM contracts WHERE id=?', (cid2,))
                        sigrow = cur2.fetchone(); conn2.close()
                    except Exception:
                        sigrow = None
                    owner_sig_line = 'Owner: Not signed'
                    cont_sig_line = 'Contractor: Not signed'
                    if sigrow:
                        try:
                            own_enc, con_enc = sigrow
                            if own_enc:
                                try:
                                    info = json.loads(self.security_manager.decrypt_data(own_enc))
                                    owner_sig_line = f"Owner: {info.get('signer_name','')} on {info.get('timestamp','')}"
                                except Exception:
                                    owner_sig_line = 'Owner: Signed'
                            if con_enc:
                                try:
                                    info2 = json.loads(self.security_manager.decrypt_data(con_enc))
                                    cont_sig_line = f"Contractor: {info2.get('signer_name','')} on {info2.get('timestamp','')}"
                                except Exception:
                                    cont_sig_line = 'Contractor: Signed'
                        except Exception:
                            pass
                    # Ensure space
                    if y < 3.0*cm:
                        c.showPage(); y = height - 2.0*cm
                    c.setFont('Helvetica-Bold', 12)
                    c.drawString(left, 3.2*cm, 'Digital Signatures')
                    c.setFont('Helvetica', 10)
                    c.drawString(left, 2.6*cm, owner_sig_line)
                    c.drawString(left, 2.2*cm, cont_sig_line)
                    # Footer note
                    c.setFont('Helvetica-Oblique', 9)
                    c.drawString(left, 1.6*cm, 'Generated by Cameroon Building Project Management System')
                    c.save()
                    try:
                        self.log_audit_action(self.current_user['id'], 'Print Contract PDF', f'Contract {cid2} -> {filename}')
                    except Exception:
                        pass
                    messagebox.showinfo('Success', f'Contract PDF saved to:\n{filename}')
                except Exception as e:
                    try:
                        messagebox.showerror('Error', f'Failed to print contract: {e}')
                    except Exception:
                        pass

            def manage_payments():
                cid = get_selected_contract_id()
                if not cid:
                    return
                try:
                    # Verify ownership and get budget
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT budget FROM contracts WHERE id = ? AND contract_owner_id = ?", (cid, self.current_user['id']))
                    row = cur.fetchone()
                    if not row:
                        conn.close()
                        messagebox.showerror('Access Denied', 'You can only manage payments for your own contracts.')
                        return
                    budget = float(row[0] or 0.0)
                    conn.close()

                    pay_win = tk.Toplevel(win)
                    pay_win.title(f"Contract Payments - #{cid}")
                    pay_win.geometry('900x600')
                    pay_win.configure(bg='white')
                    pay_win.grab_set(); pay_win.transient(win)

                    # Header with totals
                    header = tk.Frame(pay_win, bg='white'); header.pack(fill='x', padx=10, pady=10)
                    tk.Label(header, text=f"Contract #{cid} Payments", font=('Arial', 16, 'bold'), bg='white').pack(side='left')
                    totals = tk.Frame(pay_win, bg='#ecf0f1', bd=1, relief='solid'); totals.pack(fill='x', padx=10, pady=(0,10))
                    inner = tk.Frame(totals, bg='#ecf0f1'); inner.pack(pady=6)
                    lbl_budget = tk.Label(inner, text=f"Budget: {budget:,.0f}", bg='#ecf0f1', font=('Arial', 10, 'bold'))
                    lbl_budget.pack(side='left', padx=12)
                    lbl_paid = tk.Label(inner, text=f"Paid: 0", bg='#ecf0f1', font=('Arial', 10, 'bold'), fg='#27ae60')
                    lbl_paid.pack(side='left', padx=12)
                    lbl_balance = tk.Label(inner, text=f"Balance: 0", bg='#ecf0f1', font=('Arial', 10, 'bold'), fg='#c0392b')
                    lbl_balance.pack(side='left', padx=12)

                    # Table
                    frame = tk.Frame(pay_win, bg='white'); frame.pack(fill='both', expand=True, padx=10, pady=10)
                    sy = ttk.Scrollbar(frame); sy.pack(side='right', fill='y')
                    sx = ttk.Scrollbar(frame, orient='horizontal'); sx.pack(side='bottom', fill='x')
                    cols = ('ID','Amount','Method','Reference','Status','Requested By','Requested At','Confirmed By','Confirmed At','Notes')
                    p_tree = ttk.Treeview(frame, columns=cols, show='headings', yscrollcommand=sy.set, xscrollcommand=sx.set)
                    p_tree.pack(fill='both', expand=True)
                    sy.config(command=p_tree.yview); sx.config(command=p_tree.xview)
                    for col, w, a in [
                        ('ID',60,'center'),('Amount',100,'e'),('Method',100,'w'),('Reference',150,'w'),('Status',90,'center'),
                        ('Requested By',140,'w'),('Requested At',140,'center'),('Confirmed By',140,'w'),('Confirmed At',140,'center'),('Notes',220,'w')
                    ]:
                        p_tree.heading(col, text=col); p_tree.column(col, width=w, anchor=a)

                    # Buttons
                    btns = tk.Frame(pay_win, bg='white'); btns.pack(fill='x', padx=10, pady=(0,10))
                    add_btn = tk.Button(btns, text='Add Payment', bg='#2980b9', fg='white', width=14)
                    add_btn.pack(side='left')
                    edit_btn = tk.Button(btns, text='Edit Payment', bg='#f39c12', fg='white', width=14)
                    edit_btn.pack(side='left', padx=(8,0))
                    confirm_btn = tk.Button(btns, text='Confirm Payment', bg='#27ae60', fg='white', width=16)
                    confirm_btn.pack(side='left', padx=(8,0))
                    close_btn = tk.Button(btns, text='Close', bg='#6c757d', fg='white', width=10, command=pay_win.destroy)
                    close_btn.pack(side='right')

                    def refresh_totals_and_list():
                        # Load payments and totals
                        try:
                            conn = self.db_manager.create_connection(); cur = conn.cursor()
                            cur.execute(
                                '''
                                SELECT cp.id, cp.amount, cp.method, cp.reference, cp.status,
                                       COALESCE(u1.full_name,'') AS requested_by, cp.requested_at,
                                       COALESCE(u2.full_name,'') AS confirmed_by, cp.confirmed_at, COALESCE(cp.notes,'')
                                FROM contract_payments cp
                                LEFT JOIN users u1 ON u1.id = cp.requested_by
                                LEFT JOIN users u2 ON u2.id = cp.confirmed_by
                                WHERE cp.contract_id = ?
                                ORDER BY cp.requested_at DESC
                                ''', (cid,)
                            )
                            rows = cur.fetchall()
                            for i in p_tree.get_children(): p_tree.delete(i)
                            for r in rows:
                                amt = float(r[1] or 0.0)
                                p_tree.insert('', 'end', values=(r[0], f"{amt:,.0f}", r[2] or '', r[3] or '', r[4] or '', r[5] or '', r[6] or '', r[7] or '', r[8] or '', r[9] or ''))
                            cur.execute("SELECT COALESCE(SUM(amount),0) FROM contract_payments WHERE contract_id=? AND status='Confirmed'", (cid,))
                            paid = float(cur.fetchone()[0] or 0.0)
                            lbl_paid.config(text=f"Paid: {paid:,.0f}")
                            bal = (budget or 0.0) - paid
                            lbl_balance.config(text=f"Balance: {bal:,.0f}")
                            conn.close()
                        except Exception as e:
                            try:
                                messagebox.showerror('Error', f'Failed to load payments: {e}')
                            except Exception:
                                pass

                    def add_payment():
                        dlg = tk.Toplevel(pay_win); dlg.title('Add Payment'); dlg.geometry('520x360'); dlg.configure(bg='white'); dlg.grab_set(); dlg.transient(pay_win)
                        frm = tk.Frame(dlg, bg='white', padx=12, pady=12); frm.pack(fill='both', expand=True)
                        tk.Label(frm, text='Amount:', bg='white').grid(row=0, column=0, sticky='e', pady=6)
                        amt_var = tk.StringVar()
                        tk.Entry(frm, textvariable=amt_var, width=24).grid(row=0, column=1, sticky='w')
                        tk.Label(frm, text='Method:', bg='white').grid(row=1, column=0, sticky='e', pady=6)
                        method_var = tk.StringVar()
                        method_cb = ttk.Combobox(frm, textvariable=method_var, values=['Bank Transfer','Cash','Cheque','Mobile Money'], state='readonly', width=22); method_cb.grid(row=1, column=1, sticky='w')
                        tk.Label(frm, text='Reference:', bg='white').grid(row=2, column=0, sticky='e', pady=6)
                        ref_var = tk.StringVar()
                        tk.Entry(frm, textvariable=ref_var, width=24).grid(row=2, column=1, sticky='w')
                        # Account fields
                        tk.Label(frm, text='Payer Account Number:', bg='white').grid(row=0, column=2, sticky='e', padx=(12,6))
                        payer_account_var = tk.StringVar(); tk.Entry(frm, textvariable=payer_account_var, width=28).grid(row=0, column=3, sticky='w')
                        method_account_label = tk.Label(frm, text='Method Account:', bg='white'); method_account_label.grid(row=1, column=2, sticky='e', padx=(12,6))
                        method_account_var = tk.StringVar(); method_account_entry = tk.Entry(frm, textvariable=method_account_var, width=28); method_account_entry.grid(row=1, column=3, sticky='w')
                        # Notes
                        tk.Label(frm, text='Notes:', bg='white').grid(row=3, column=0, sticky='ne', pady=6)
                        notes_txt = tk.Text(frm, width=28, height=5); notes_txt.grid(row=3, column=1, sticky='w')

                        def _update_method_fields(*_a):
                            m = (method_var.get() or '').strip()
                            if m in ('Mobile Money','Bank Transfer'):
                                method_account_entry.config(state='normal')
                                method_account_label.config(text='Mobile Money Number:' if m=='Mobile Money' else 'Bank Account Number:')
                            else:
                                method_account_entry.config(state='disabled')
                                method_account_label.config(text='Method Account:')
                                method_account_var.set('')
                        method_var.trace('w', _update_method_fields); _update_method_fields()

                        def save_payment():
                            try:
                                try:
                                    amount = float(amt_var.get().replace(',', '').strip())
                                except Exception:
                                    amount = float(amt_var.get().strip())
                            except Exception:
                                messagebox.showwarning('Invalid', 'Enter a valid amount.'); return
                            if amount <= 0:
                                messagebox.showwarning('Invalid', 'Amount must be greater than zero.'); return
                            # Reference required
                            ref_val = (ref_var.get() or '').strip()
                            if not ref_val:
                                messagebox.showerror('Validation', 'Reference is required.'); return
                            # Validate accounts
                            if not payer_account_var.get().strip():
                                messagebox.showerror('Validation', 'Payer Account Number is required.'); return
                            m = (method_var.get() or '').strip()
                            if m in ('Mobile Money','Bank Transfer') and not method_account_var.get().strip():
                                need = 'Mobile Money Number' if m=='Mobile Money' else 'Bank Account Number'
                                messagebox.showerror('Validation', f'{need} is required for method {m}.'); return
                            # Encrypt sensitive values
                            payer_acct = payer_account_var.get().strip()
                            method_acct = method_account_var.get().strip() if m in ('Mobile Money','Bank Transfer') else ''
                            try:
                                if hasattr(self, 'security_manager') and self.security_manager:
                                    payer_acct = self.security_manager.encrypt_data(payer_acct)
                                    if method_acct:
                                        method_acct = self.security_manager.encrypt_data(method_acct)
                            except Exception:
                                pass
                            try:
                                conn = self.db_manager.create_connection(); cur = conn.cursor()
                                cur.execute(
                                    'INSERT INTO contract_payments(contract_id, amount, method, reference, status, requested_by, notes, payer_account, method_account) VALUES (?,?,?,?,"Pending",?,?,?,?)',
                                    (cid, amount, m or None, ref_val, self.current_user['id'], notes_txt.get('1.0','end').strip() or None, payer_acct or None, method_acct or None)
                                )
                                conn.commit(); conn.close()
                                try:
                                    self.log_audit_action(self.current_user['id'], 'Add Contract Payment', f'Contract {cid}, amount {amount}')
                                except Exception:
                                    pass
                                dlg.destroy(); refresh_totals_and_list()
                            except Exception as e:
                                try:
                                    messagebox.showerror('Error', f'Failed to add payment: {e}')
                                except Exception:
                                    pass

                        tk.Button(frm, text='Save', bg='#27ae60', fg='white', width=10, command=save_payment).grid(row=4, column=3, sticky='e', pady=(10,0))

                    def get_selected_payment_id():
                        sel = p_tree.selection()
                        if not sel:
                            messagebox.showwarning('Select', 'Please select a payment first.')
                            return None
                        try:
                            return int(p_tree.item(sel[0])['values'][0])
                        except Exception:
                            return None

                    def confirm_payment():
                        # Ensure role
                        role = self.current_user.get('role')
                        if role not in ('contract_owner','administrator'):
                            messagebox.showwarning('Access Denied', 'Only Contract Owners or Administrators can confirm payments.')
                            return
                        pid = get_selected_payment_id()
                        if not pid:
                            return
                        # Check status first
                        try:
                            conn = self.db_manager.create_connection(); cur = conn.cursor()
                            cur.execute("SELECT amount, status FROM contract_payments WHERE id=? AND contract_id=?", (pid, cid))
                            r = cur.fetchone()
                            if not r:
                                conn.close(); messagebox.showerror('Error', 'Payment not found.'); return
                            amount, status = float(r[0] or 0.0), r[1]
                            if status == 'Confirmed':
                                conn.close(); messagebox.showinfo('Info', 'Payment already confirmed.'); return
                            # Begin confirmation and ledger entry
                            try:
                                cur.execute("UPDATE contract_payments SET status='Confirmed', confirmed_by=?, confirmed_at=CURRENT_TIMESTAMP WHERE id=? AND status='Pending'", (self.current_user['id'], pid))
                                if cur.rowcount == 0:
                                    conn.rollback(); conn.close(); messagebox.showinfo('Info', 'Payment already processed.'); return
                                cur.execute(
                                    'INSERT INTO contract_ledger(contract_id, entry_type, amount, ref_payment_id, description) VALUES (?,?,?,?,?)',
                                    (cid, 'PaymentConfirmed', amount, pid, f'Payment confirmed (ref {pid})')
                                )
                                conn.commit(); conn.close()
                                try:
                                    self.log_audit_action(self.current_user['id'], 'Confirm Contract Payment', f'Contract {cid}, payment {pid}, amount {amount}')
                                except Exception:
                                    pass
                                refresh_totals_and_list()
                            except Exception as e2:
                                try:
                                    conn.rollback()
                                except Exception:
                                    pass
                                try:
                                    conn.close()
                                except Exception:
                                    pass
                                messagebox.showerror('Error', f'Failed to confirm payment: {e2}')
                                return
                        except Exception as e:
                            try:
                                messagebox.showerror('Error', f'Failed to confirm: {e}')
                            except Exception:
                                pass

                    def edit_payment():
                        pid = get_selected_payment_id()
                        if not pid:
                            return
                        try:
                            conn = self.db_manager.create_connection(); cur = conn.cursor()
                            cur.execute("SELECT amount, method, COALESCE(reference,''), COALESCE(notes,''), COALESCE(payer_account,''), COALESCE(method_account,''), status FROM contract_payments WHERE id=? AND contract_id=?", (pid, cid))
                            row = cur.fetchone(); conn.close()
                            if not row:
                                messagebox.showerror('Error', 'Payment not found.'); return
                            amount0, method0, ref0, notes0, payer_enc, method_enc, status0 = row
                            if status0 != 'Pending':
                                messagebox.showinfo('Edit', 'Only Pending payments can be edited.'); return
                            # Decrypt accounts if possible
                            try:
                                payer_plain = self.security_manager.decrypt_data(payer_enc) if payer_enc else ''
                            except Exception:
                                payer_plain = payer_enc
                            try:
                                method_plain = self.security_manager.decrypt_data(method_enc) if method_enc else ''
                            except Exception:
                                method_plain = method_enc
                        except Exception as e:
                            messagebox.showerror('Error', f'Failed to load payment: {e}'); return
                        # Dialog
                        dlg = tk.Toplevel(pay_win); dlg.title(f'Edit Payment #{pid}'); dlg.geometry('520x380'); dlg.configure(bg='white'); dlg.grab_set(); dlg.transient(pay_win)
                        frm = tk.Frame(dlg, bg='white', padx=12, pady=12); frm.pack(fill='both', expand=True)
                        tk.Label(frm, text='Amount:', bg='white').grid(row=0, column=0, sticky='e', pady=6)
                        amt_var = tk.StringVar(value=str(amount0 or ''))
                        tk.Entry(frm, textvariable=amt_var, width=24).grid(row=0, column=1, sticky='w')
                        tk.Label(frm, text='Method:', bg='white').grid(row=1, column=0, sticky='e', pady=6)
                        method_var = tk.StringVar(value=method0 or '')
                        method_cb = ttk.Combobox(frm, textvariable=method_var, values=['Bank Transfer','Cash','Cheque','Mobile Money'], state='readonly', width=22); method_cb.grid(row=1, column=1, sticky='w')
                        tk.Label(frm, text='Reference:', bg='white').grid(row=2, column=0, sticky='e', pady=6)
                        ref_var = tk.StringVar(value=ref0 or '')
                        tk.Entry(frm, textvariable=ref_var, width=24).grid(row=2, column=1, sticky='w')
                        # Accounts
                        tk.Label(frm, text='Payer Account Number:', bg='white').grid(row=0, column=2, sticky='e', padx=(12,6))
                        payer_account_var = tk.StringVar(value=payer_plain or '')
                        tk.Entry(frm, textvariable=payer_account_var, width=28).grid(row=0, column=3, sticky='w')
                        method_account_label = tk.Label(frm, text='Method Account:', bg='white'); method_account_label.grid(row=1, column=2, sticky='e', padx=(12,6))
                        method_account_var = tk.StringVar(value=method_plain or '')
                        method_account_entry = tk.Entry(frm, textvariable=method_account_var, width=28); method_account_entry.grid(row=1, column=3, sticky='w')
                        tk.Label(frm, text='Notes:', bg='white').grid(row=3, column=0, sticky='ne', pady=6)
                        notes_txt = tk.Text(frm, width=28, height=5); notes_txt.grid(row=3, column=1, sticky='w')
                        notes_txt.insert('1.0', notes0 or '')
                        def _update_method_fields(*_a):
                            m = (method_var.get() or '').strip()
                            if m in ('Mobile Money','Bank Transfer'):
                                method_account_entry.config(state='normal')
                                method_account_label.config(text='Mobile Money Number:' if m=='Mobile Money' else 'Bank Account Number:')
                            else:
                                method_account_entry.config(state='disabled')
                                method_account_label.config(text='Method Account:')
                        method_var.trace('w', _update_method_fields); _update_method_fields()
                        def save_edit():
                            # Validate
                            try:
                                try:
                                    amount = float(amt_var.get().replace(',', '').strip())
                                except Exception:
                                    amount = float(amt_var.get().strip())
                            except Exception:
                                messagebox.showwarning('Invalid', 'Enter a valid amount.'); return
                            if amount <= 0:
                                messagebox.showwarning('Invalid', 'Amount must be greater than zero.'); return
                            ref_val = (ref_var.get() or '').strip()
                            if not ref_val:
                                messagebox.showerror('Validation', 'Reference is required.'); return
                            if not payer_account_var.get().strip():
                                messagebox.showerror('Validation', 'Payer Account Number is required.'); return
                            m = (method_var.get() or '').strip()
                            if m in ('Mobile Money','Bank Transfer') and not method_account_var.get().strip():
                                need = 'Mobile Money Number' if m=='Mobile Money' else 'Bank Account Number'
                                messagebox.showerror('Validation', f'{need} is required for method {m}.'); return
                            # Encrypt accounts
                            payer_acct = payer_account_var.get().strip()
                            method_acct = method_account_var.get().strip() if m in ('Mobile Money','Bank Transfer') else ''
                            try:
                                if hasattr(self, 'security_manager') and self.security_manager:
                                    payer_acct = self.security_manager.encrypt_data(payer_acct)
                                    if method_acct:
                                        method_acct = self.security_manager.encrypt_data(method_acct)
                            except Exception:
                                pass
                            try:
                                conn = self.db_manager.create_connection(); cur = conn.cursor()
                                cur.execute(
                                    'UPDATE contract_payments SET amount=?, method=?, reference=?, notes=?, payer_account=?, method_account=? WHERE id=? AND status="Pending" AND contract_id=?',
                                    (amount, m or None, ref_val, notes_txt.get('1.0','end').strip() or None, payer_acct or None, method_acct or None, pid, cid)
                                )
                                if cur.rowcount == 0:
                                    conn.rollback(); conn.close(); messagebox.showinfo('Edit', 'Payment is no longer editable.'); return
                                conn.commit(); conn.close()
                                try:
                                    self.log_audit_action(self.current_user['id'], 'Edit Contract Payment', f'Payment {pid} of contract {cid} edited')
                                except Exception:
                                    pass
                                dlg.destroy(); refresh_totals_and_list()
                            except Exception as ex:
                                try:
                                    messagebox.showerror('Error', f'Failed to save edit: {ex}')
                                except Exception:
                                    pass
                        tk.Button(frm, text='Save Changes', bg='#27ae60', fg='white', width=14, command=save_edit).grid(row=4, column=3, sticky='e', pady=(10,0))

                    add_btn.config(command=add_payment)
                    edit_btn.config(command=edit_payment)
                    confirm_btn.config(command=confirm_payment)
                    refresh_totals_and_list()
                except Exception as e:
                    try:
                        messagebox.showerror('Error', f'Failed to open Payments: {e}')
                    except Exception:
                        pass

            def load_contracts():
                try:
                    for i in tree.get_children(): tree.delete(i)
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    base_sql = (
                        "SELECT c.id, c.title, COALESCE(u.full_name,'Not Assigned') AS contractor, "
                        "COALESCE(c.contract_kind,'Labour Only') AS ckind, COALESCE(c.includes_materials,0) AS im, "
                        "c.budget, c.start_date, c.end_date, c.status "
                        "FROM contracts c LEFT JOIN users u ON c.contractor_id = u.id "
                        "WHERE c.contract_owner_id = ?"
                    )
                    params = [self.current_user['id']]
                    st = status_var.get()
                    if st and st != 'All':
                        base_sql += " AND c.status = ?"; params.append(st)
                    if q_var.get().strip():
                        base_sql += " AND (c.title LIKE ? OR c.description LIKE ?)";
                        like = f"%{q_var.get().strip()}%"; params.extend([like, like])
                    base_sql += " ORDER BY c.created_date DESC"
                    cur.execute(base_sql, params)
                    rows = cur.fetchall(); conn.close()
                    for r in rows:
                        bid = r[0]; title = r[1]; contractor = r[2]
                        kind = r[3] or 'Labour Only'
                        materials = 'Yes' if (r[4]==1 or r[4]==True) else 'No'
                        budget = r[5] or 0
                        sd = r[6] or ''; ed = r[7] or ''; status = r[8] or ''
                        tree.insert('', 'end', values=(bid, title, contractor, kind, materials, f"{budget:,.0f}", sd, ed, status))
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to load contracts: {e}")
                    except Exception:
                        pass

            # Delete contract (allowed only when not Active)
            def delete_contract():
                cid = get_selected_contract_id()
                if not cid:
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT title, COALESCE(status,''), contract_owner_id FROM contracts WHERE id=?", (cid,))
                    row = cur.fetchone()
                    if not row:
                        conn.close(); messagebox.showerror('Delete', 'Contract not found.'); return
                    title, status_v, owner_id = row
                    # Permission check
                    role = self.current_user.get('role') if getattr(self, 'current_user', None) else ''
                    if role != 'administrator' and owner_id != self.current_user['id']:
                        conn.close(); messagebox.showerror('Delete', 'You do not have permission to delete this contract.'); return
                    if (status_v or '').lower() == 'active':
                        conn.close(); messagebox.showwarning('Delete', 'Active contracts cannot be deleted.'); return
                    if not messagebox.askyesno('Confirm Delete', f"Delete contract '{title}' (ID:{cid})?\nThis cannot be undone."):
                        conn.close(); return
                    # Delete dependents then contract
                    try:
                        cur.execute("DELETE FROM contract_ledger WHERE contract_id=?", (cid,))
                    except Exception:
                        pass
                    try:
                        cur.execute("DELETE FROM contract_payments WHERE contract_id=?", (cid,))
                    except Exception:
                        pass
                    if role == 'administrator':
                        cur.execute("DELETE FROM contracts WHERE id=?", (cid,))
                    else:
                        cur.execute("DELETE FROM contracts WHERE id=? AND contract_owner_id=?", (cid, self.current_user['id']))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], 'Delete Contract', f'Contract {cid} deleted')
                    except Exception:
                        pass
                    messagebox.showinfo('Deleted', 'Contract deleted successfully.')
                    load_contracts()
                except Exception as e:
                    try:
                        conn.close()
                    except Exception:
                        pass
                    messagebox.showerror('Delete', f'Failed to delete: {e}')

            # wiring
            # Wire buttons
            refresh_btn.config(command=load_contracts)
            refresh_btn2.config(command=load_contracts)
            view_btn.config(command=view_contract)
            edit_btn.config(command=edit_contract)
            assign_btn.config(command=assign_contractor)
            pdf_btn.config(command=print_contract_pdf)
            payments_btn.config(command=manage_payments)
            delete_btn.config(command=delete_contract)
            status_var.trace('w', lambda *a: load_contracts())
            q_var.trace('w', lambda *a: load_contracts())

            # Double-click to view
            tree.bind('<Double-1>', lambda e: view_contract())

            load_contracts()

            try:
                self.log_audit_action(self.current_user['id'], "Access Contract Management", "Opened manage contracts")
            except Exception:
                pass

            # shortcuts
            win.bind('<F5>', lambda e: load_contracts())
            win.bind('<Escape>', lambda e: win.destroy())
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Manage Contracts: {e}")
            except Exception:
                pass
        return None

    def show_digital_signatures(self):
        # Digital Signatures Management for Contract Owner (standalone implementation)
        try:
            win = tk.Toplevel(self.root)
            win.title("Digital Signatures - Contract Owner")
            win.geometry("1100x650")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Digital Signatures - Owner", font=('Arial', 18, 'bold'), bg='white').pack(side='left')

            right = tk.Frame(header, bg='white')
            right.pack(side='right')
            tk.Label(right, text="Filter:", bg='white').pack(side='left', padx=(0,5))
            filt_var = tk.StringVar(value='All')
            filt = ttk.Combobox(right, textvariable=filt_var, state='readonly', width=16)
            filt['values'] = ['All','Unsigned','Partially Signed','Fully Signed','Pending']
            filt.pack(side='left')
            refresh_btn = tk.Button(right, text='Refresh', bg='#3498db', fg='white')
            refresh_btn.pack(side='left', padx=6)

            stats = tk.Frame(win, bg='#ecf0f1', relief='raised', bd=1)
            stats.pack(fill='x', padx=10, pady=(0,10))
            inner = tk.Frame(stats, bg='#ecf0f1'); inner.pack(pady=8)
            total_lbl = tk.Label(inner, text='Total: 0', bg='#ecf0f1', font=('Arial',10,'bold'))
            total_lbl.pack(side='left', padx=15)
            uns_lbl = tk.Label(inner, text='Unsigned: 0', bg='#ecf0f1', fg='#e74c3c', font=('Arial',10,'bold'))
            uns_lbl.pack(side='left', padx=15)
            part_lbl = tk.Label(inner, text='Partially Signed: 0', bg='#ecf0f1', fg='#f39c12', font=('Arial',10,'bold'))
            part_lbl.pack(side='left', padx=15)
            full_lbl = tk.Label(inner, text='Fully Signed: 0', bg='#ecf0f1', fg='#27ae60', font=('Arial',10,'bold'))
            full_lbl.pack(side='left', padx=15)

            frame = tk.Frame(win, bg='white'); frame.pack(fill='both', expand=True, padx=10, pady=10)
            sy = ttk.Scrollbar(frame); sy.pack(side='right', fill='y')
            sx = ttk.Scrollbar(frame, orient='horizontal'); sx.pack(side='bottom', fill='x')
            tree = ttk.Treeview(frame, columns=(
                'ID','Title','Contractor','Owner Sig','Contractor Sig','Status','Created'),
                show='headings', yscrollcommand=sy.set, xscrollcommand=sx.set)
            tree.pack(fill='both', expand=True)
            sy.config(command=tree.yview); sx.config(command=tree.xview)
            for col, w, a in [
                ('ID',60,'center'),('Title',260,'w'),('Contractor',160,'w'),
                ('Owner Sig',110,'center'),('Contractor Sig',120,'center'),
                ('Status',120,'center'),('Created',120,'center')]:
                tree.heading(col, text=col); tree.column(col, width=w, anchor=a)
            tree.tag_configure('unsigned', background='#ffebee')
            tree.tag_configure('partial', background='#fff3e0')
            tree.tag_configure('full', background='#e8f5e9')

            btns = tk.Frame(win, bg='white'); btns.pack(fill='x', padx=10, pady=(0,10))
            sign_btn = tk.Button(btns, text='Sign as Owner', bg='#27ae60', fg='white', width=16)
            sign_btn.pack(side='left')
            view_btn = tk.Button(btns, text='View Signatures', bg='#6f42c1', fg='white', width=16)
            view_btn.pack(side='left', padx=6)
            close_btn = tk.Button(btns, text='Close', bg='#dc3545', fg='white', width=10, command=win.destroy)
            close_btn.pack(side='right')

            def load_data():
                for i in tree.get_children(): tree.delete(i)
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute('''
                        SELECT c.id, c.title, COALESCE(u.full_name,'Not Assigned'),
                               c.digital_signature_owner, c.digital_signature_contractor,
                               c.status, c.created_date
                        FROM contracts c LEFT JOIN users u ON c.contractor_id=u.id
                        WHERE c.contract_owner_id=?
                        ORDER BY c.created_date DESC
                    ''', (self.current_user['id'],))
                    rows = cur.fetchall(); conn.close()
                    total = len(rows); unsigned = partial = full = 0
                    for r in rows:
                        owner_s = '✓ Signed' if r[3] else '✗ Unsigned'
                        cont_s = '✓ Signed' if r[4] else '✗ Unsigned'
                        if r[3] and r[4]: tag = 'full'; full += 1; sig_stat = 'Fully Signed'
                        elif (not r[3]) and (not r[4]): tag = 'unsigned'; unsigned += 1; sig_stat = 'Unsigned'
                        else: tag = 'partial'; partial += 1; sig_stat = 'Partially Signed'
                        tree.insert('', 'end', values=(r[0], r[1], r[2], owner_s, cont_s, sig_stat, r[6] or ''), tags=(tag,))
                    total_lbl.config(text=f'Total: {total}')
                    uns_lbl.config(text=f'Unsigned: {unsigned}')
                    part_lbl.config(text=f'Partially Signed: {partial}')
                    full_lbl.config(text=f'Fully Signed: {full}')
                except Exception as e:
                    messagebox.showerror('Error', f'Failed to load: {e}')

            def get_selected_id():
                sel = tree.selection();
                if not sel: return None
                vals = tree.item(sel[0],'values');
                return int(vals[0]) if vals else None

            def sign_owner():
                cid = get_selected_id()
                if not cid:
                    messagebox.showwarning('Select', 'Please select a contract to sign.'); return
                # Check if already signed
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute('SELECT digital_signature_owner, title FROM contracts WHERE id=? AND contract_owner_id=?', (cid, self.current_user['id']))
                    row = cur.fetchone()
                    if not row:
                        conn.close(); messagebox.showerror('Error','Contract not found.'); return
                    if row[0]:
                        conn.close(); messagebox.showinfo('Info','You have already signed this contract.'); return
                    title = row[1]
                except Exception as e:
                    try: conn.close()
                    except Exception: pass
                    messagebox.showerror('Error', f'Failed to verify: {e}'); return

                d = tk.Toplevel(win); d.title('Owner Signature'); d.geometry('460x320'); d.configure(bg='white'); d.grab_set()
                tk.Label(d, text=f'Sign Contract #{cid} - {title}', font=('Arial', 14, 'bold'), bg='white').pack(pady=10)
                tk.Label(d, text='Confirm with your password:', bg='white').pack()
                pwd = tk.Entry(d, show='*', width=40); pwd.pack(pady=6)
                tk.Label(d, text='Comment (optional):', bg='white').pack(pady=(8,2))
                cmt = tk.Text(d, width=46, height=3); cmt.pack()

                def do_sign():
                    pw = pwd.get().strip()
                    if not pw:
                        messagebox.showerror('Error','Password is required.'); return
                    try:
                        # Verify password
                        conn2 = self.db_manager.create_connection(); cur2 = conn2.cursor()
                        cur2.execute('SELECT password_hash FROM users WHERE id=?', (self.current_user['id'],))
                        stored = cur2.fetchone()[0]
                        if not self.security_manager.verify_password(pw, stored):
                            conn2.close(); messagebox.showerror('Error','Invalid password.'); return
                        # Create encrypted signature payload
                        from datetime import datetime as dt
                        payload = json.dumps({
                            'signer_id': self.current_user['id'],
                            'signer_name': self.current_user.get('full_name') or self.current_user.get('username'),
                            'timestamp': dt.now().isoformat(),
                            'comment': cmt.get('1.0','end-1c').strip(),
                            'method': 'password',
                            'contract_id': cid
                        })
                        enc = self.security_manager.encrypt_data(payload)
                        cur2.execute('UPDATE contracts SET digital_signature_owner=? WHERE id=?', (enc, cid))
                        conn2.commit(); conn2.close()
                        try:
                            self.ensure_contract_active_if_fully_signed(cid)
                        except Exception:
                            pass
                        try:
                            self.log_audit_action(self.current_user['id'], 'Digital Signature', f'Signed contract {cid} as owner')
                        except Exception:
                            pass
                        messagebox.showinfo('Success', 'Contract signed successfully.')
                        d.destroy(); load_data()
                    except Exception as ex:
                        messagebox.showerror('Error', f'Failed to sign: {ex}')
                tk.Button(d, text='Sign', bg='#27ae60', fg='white', command=do_sign).pack(pady=10)
                tk.Button(d, text='Cancel', bg='#dc3545', fg='white', command=d.destroy).pack()

            def view_sigs():
                cid = get_selected_id()
                if not cid:
                    messagebox.showwarning('Select','Please select a contract.'); return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute('SELECT digital_signature_owner, digital_signature_contractor FROM contracts WHERE id=?', (cid,))
                    row = cur.fetchone(); conn.close()
                    if not row:
                        messagebox.showerror('Error','Contract not found.'); return
                    owner_sig, contractor_sig = row
                    msg = []
                    msg.append(f'Owner Signature: {"Present" if owner_sig else "Missing"}')
                    msg.append(f'Contractor Signature: {"Present" if contractor_sig else "Missing"}')
                    messagebox.showinfo('Signature Status', "\n".join(msg))
                except Exception as e:
                    messagebox.showerror('Error', f'Failed to retrieve signatures: {e}')

            def on_filter_change(*_):
                # Simple refilter by reloading and letting tags update; for brevity not filtering server-side here
                load_data()
                # After load, optionally hide rows by status
                want = filt_var.get()
                if want == 'All':
                    return
                mapping = {'Unsigned':'unsigned','Partially Signed':'partial','Fully Signed':'full'}
                tag = mapping.get(want)
                for iid in tree.get_children():
                    tags = tree.item(iid,'tags')
                    show = (tag in tags) if tag else (tree.item(iid,'values')[5] == 'Pending Review')
                    if not show:
                        tree.detach(iid)
            filt_var.trace_add('write', on_filter_change)

            refresh_btn.config(command=load_data)
            sign_btn.config(command=sign_owner)
            view_btn.config(command=view_sigs)
            win.bind('<F5>', lambda e: load_data())
            win.bind('<Escape>', lambda e: win.destroy())

            load_data()
            try:
                self.log_audit_action(self.current_user['id'], 'Open Digital Signatures', 'Owner signatures dashboard opened')
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror('Error', f'Failed to open Digital Signatures: {e}')
            except Exception:
                pass
        return None

    def show_transfer_products(self):
        # Delegate to the fully implemented version defined later in the file
        if hasattr(self, '_impl_show_transfer_products'):
            return self._impl_show_transfer_products()
        # As a fallback, try to call the nested implementation inside show_create_contract block
        try:
            return show_transfer_products(self)  # defined within show_create_contract -> show_digital_signatures scope
        except Exception:
            try:
                messagebox.showerror("Transfer", "Transfer Products feature is currently unavailable.")
            except Exception:
                pass
        return None

    def _impl_show_transfer_products(self):
        try:
            win = tk.Toplevel(self.root)
            win.title("Transfer Products Between Stores")
            win.geometry("1100x720")
            win.configure(bg='white')
            win.grab_set()

            # Top controls: store selection
            top = tk.Frame(win, bg='white')
            top.pack(fill='x', padx=12, pady=10)

            tk.Label(top, text="From Store:", bg='white').pack(side='left')
            from_var = tk.StringVar()
            from_cb = ttk.Combobox(top, textvariable=from_var, state='readonly', width=40)
            from_cb.pack(side='left', padx=6)

            tk.Label(top, text="To Store:", bg='white').pack(side='left', padx=(20, 0))
            to_var = tk.StringVar()
            to_cb = ttk.Combobox(top, textvariable=to_var, state='readonly', width=40)
            to_cb.pack(side='left', padx=6)

            # Load stores user can access
            def load_stores():
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                # Load source stores the user can access
                cur.execute(
                    """
                    SELECT id, name
                    FROM stores
                    WHERE is_active = 1 AND (owner_id = ? OR manager_id = ?)
                    ORDER BY name
                    """,
                    (self.current_user['id'], self.current_user['id'])
                )
                rows = cur.fetchall()
                # Decide destination options based on role
                role = None
                try:
                    role = self.current_user.get('role')
                except Exception:
                    role = None
                dest_rows = rows
                if role == 'manager':
                    try:
                        cur.execute(
                            """
                            SELECT s.id, s.name
                            FROM stores s
                            JOIN users u ON u.id = s.owner_id
                            WHERE s.is_active = 1 AND u.role = 'contractor'
                            ORDER BY s.name
                            """
                        )
                        dest_rows = cur.fetchall()
                    except Exception:
                        dest_rows = []
                conn.close()
                from_options = [f"{r[0]} - {r[1]}" for r in rows]
                to_options = [f"{r[0]} - {r[1]}" for r in dest_rows]
                from_cb['values'] = from_options
                to_cb['values'] = to_options
                # Preselect defaults
                if from_options and not from_cb.get():
                    from_cb.set(from_options[0])
                if to_options and not to_cb.get():
                    to_cb.set(to_options[0])
                if role == 'manager' and not to_options:
                    try:
                        messagebox.showinfo("Transfer", "No contractor store available for destination.")
                    except Exception:
                        pass
            load_stores()

            # Middle: inventory of source store
            mid = tk.Frame(win, bg='white')
            mid.pack(fill='both', expand=True, padx=12, pady=(0, 10))

            left = tk.Frame(mid, bg='white')
            left.pack(side='left', fill='both', expand=True)

            tk.Label(left, text="Source Inventory", font=('Arial', 11, 'bold'), bg='white').pack(anchor='w')
            search_var = tk.StringVar()
            tk.Entry(left, textvariable=search_var).pack(fill='x', pady=4)

            inv_scroll = ttk.Scrollbar(left)
            inv_scroll.pack(side='right', fill='y')
            inv = ttk.Treeview(left, columns=("Material","Category","Qty","Unit","Unit Price"), show='headings', yscrollcommand=inv_scroll.set, height=12)
            inv.pack(fill='both', expand=True)
            inv_scroll.config(command=inv.yview)
            for c,w in [("Material",220),("Category",120),("Qty",80),("Unit",90),("Unit Price",100)]:
                inv.heading(c, text=c)
                inv.column(c, width=w, anchor='center' if c in ("Qty","Unit","Unit Price") else 'w')

            # Right: transfer list
            right = tk.Frame(mid, bg='white')
            right.pack(side='left', fill='both', expand=True, padx=(12,0))
            tk.Label(right, text="Transfer List", font=('Arial', 11, 'bold'), bg='white').pack(anchor='w')
            list_scroll = ttk.Scrollbar(right)
            list_scroll.pack(side='right', fill='y')
            tlist = ttk.Treeview(right, columns=("Material","Qty","Unit","Unit Price","Total","Reason","Notes"), show='headings', yscrollcommand=list_scroll.set, height=12)
            tlist.pack(fill='both', expand=True)
            list_scroll.config(command=tlist.yview)
            for c,w in [("Material",220),("Qty",80),("Unit",90),("Unit Price",100),("Total",110),("Reason",140),("Notes",200)]:
                tlist.heading(c, text=c)
                tlist.column(c, width=w, anchor='center' if c in ("Qty","Unit","Unit Price","Total") else 'w')

            # Bottom controls: quantity/reason/notes and actions
            bottom = tk.Frame(win, bg='white')
            bottom.pack(fill='x', padx=12, pady=10)

            tk.Label(bottom, text="Quantity:", bg='white').pack(side='left')
            qty_var = tk.StringVar()
            tk.Entry(bottom, textvariable=qty_var, width=10).pack(side='left', padx=6)

            tk.Label(bottom, text="Reason:", bg='white').pack(side='left', padx=(10,0))
            reason_var = tk.StringVar(value='Stock Rebalancing')
            rcb = ttk.Combobox(bottom, textvariable=reason_var, state='readonly', width=22)
            rcb['values'] = ['Stock Rebalancing','Store Restocking','Customer Request','Seasonal Adjustment','Emergency Supply']
            rcb.pack(side='left', padx=6)

            tk.Label(bottom, text="Notes:", bg='white').pack(side='left', padx=(10,0))
            notes_var = tk.StringVar()
            tk.Entry(bottom, textvariable=notes_var, width=40).pack(side='left', padx=6)

            total_lbl = tk.Label(bottom, text="Total: 0 FCFA", bg='white', font=('Arial', 10, 'bold'))
            total_lbl.pack(side='right')

            transfer_items = []  # list of dicts

            def refresh_total():
                total = sum(i['total'] for i in transfer_items)
                total_lbl.config(text=f"Total: {total:,.0f} FCFA")

            def load_inventory(*_):
                for iid in inv.get_children():
                    inv.delete(iid)
                sel = from_var.get()
                if not sel:
                    return
                try:
                    store_id = sel.split(' - ')[0]
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(
                        """
                        SELECT bm.id, bm.name, bm.category, i.quantity, bm.unit, i.unit_price
                        FROM inventory i
                        JOIN building_materials bm ON bm.id = i.material_id
                        WHERE i.store_id = ? AND i.quantity > 0
                        ORDER BY bm.category, bm.name
                        """,
                        (store_id,)
                    )
                    rows = cur.fetchall()
                    conn.close()
                    q = (search_var.get() or '').lower()
                    for mid, name, cat, qty, unit, price in rows:
                        if q and q not in name.lower():
                            continue
                        inv.insert('', 'end', values=(name, cat, f"{qty:,.2f}", unit, f"{price:,.0f}"), tags=(str(mid),))
                except Exception as e:
                    try:
                        messagebox.showerror('Inventory', f'Failed to load inventory: {e}')
                    except Exception:
                        pass

            from_cb.bind('<<ComboboxSelected>>', load_inventory)
            search_var.trace('w', load_inventory)

            def add_selected():
                sel = inv.selection()
                if not sel:
                    messagebox.showwarning('Select', 'Select a material from the source inventory.')
                    return
                try:
                    q = float(qty_var.get())
                    if q <= 0:
                        raise ValueError
                except Exception:
                    messagebox.showerror('Quantity', 'Enter a valid transfer quantity (> 0).')
                    return
                item = inv.item(sel[0])
                name, cat, qty_str, unit, unit_price_str = item['values']
                unit_price = float(str(unit_price_str).replace(',', ''))
                total = unit_price * q
                transfer_items.append({
                    'material': name,
                    'quantity': q,
                    'unit': unit,
                    'unit_price': unit_price,
                    'total': total,
                    'reason': reason_var.get() or '',
                    'notes': notes_var.get() or ''
                })
                tlist.insert('', 'end', values=(name, f"{q:,.2f}", unit, f"{unit_price:,.0f}", f"{total:,.0f}", reason_var.get() or '', notes_var.get() or ''))
                refresh_total()

            def clear_list():
                transfer_items.clear()
                for iid in tlist.get_children():
                    tlist.delete(iid)
                refresh_total()

            def execute():
                # validations
                if not from_var.get() or not to_var.get():
                    messagebox.showerror('Stores', 'Please select both From and To stores.')
                    return
                if from_var.get().split(' - ')[0] == to_var.get().split(' - ')[0]:
                    messagebox.showerror('Stores', 'Source and Destination stores must be different.')
                    return
                if not transfer_items:
                    messagebox.showwarning('Transfer', 'No items to transfer.')
                    return
                if not messagebox.askyesno('Confirm', f"Execute transfer of {len(transfer_items)} items?"):
                    return
                try:
                    source_id = int(from_var.get().split(' - ')[0])
                    dest_id = int(to_var.get().split(' - ')[0])
                    # Managers can only transfer to contractor-owned stores
                    try:
                        _role = self.current_user.get('role') if getattr(self, 'current_user', None) else None
                    except Exception:
                        _role = None
                    if _role == 'manager':
                        try:
                            _conn_chk = self.db_manager.create_connection(); _cur_chk = _conn_chk.cursor()
                            _cur_chk.execute("SELECT COALESCE(u.role,'') FROM stores s JOIN users u ON u.id = s.owner_id WHERE s.id = ?", (dest_id,))
                            _row_chk = _cur_chk.fetchone(); _conn_chk.close()
                            if not _row_chk or str(_row_chk[0]).lower() != 'contractor':
                                messagebox.showerror('Permission', 'Managers can only transfer to contractor stores.')
                                return
                        except Exception:
                            messagebox.showerror('Permission', 'Unable to verify destination store ownership.'); return
                    now = datetime.now()
                    reference = f"TR-{now.strftime('%Y%m%d-%H%M%S')}-{self.current_user['id']}"

                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()

                    # Start transaction
                    cur.execute('BEGIN')

                    # Compute totals
                    total_items = len(transfer_items)
                    total_value = sum(i['total'] for i in transfer_items)

                    # Insert transfer header
                    cur.execute(
                        """
                        INSERT INTO transfers (reference, source_store_id, dest_store_id, total_items, total_value,
                                               status, reason, notes, signature_name, signature_date, created_at, initiated_by)
                        VALUES (?, ?, ?, ?, ?, 'Completed', ?, ?, ?, ?, ?, ?)
                        """,
                        (
                            reference,
                            source_id,
                            dest_id,
                            total_items,
                            total_value,
                            ', '.join(sorted(set(i['reason'] for i in transfer_items if i['reason']))),
                            '; '.join(filter(None, (i['notes'] for i in transfer_items))),
                            self.current_user.get('full_name') or self.current_user.get('username') or 'User',
                            now.isoformat(sep=' '),
                            now.isoformat(sep=' '),
                            self.current_user['id']
                        )
                    )
                    transfer_row_id = cur.lastrowid

                    # For each item: find material id, update inventories, insert line
                    for it in transfer_items:
                        # Resolve material id
                        cur.execute("SELECT id, unit FROM building_materials WHERE name = ?", (it['material'],))
                        res = cur.fetchone()
                        if not res:
                            raise Exception(f"Material not found: {it['material']}")
                        material_id, unit_from_db = res
                        qty = float(it['quantity'])

                        # Decrease source inventory
                        cur.execute(
                            """
                            UPDATE inventory SET quantity = quantity - ?, last_updated = ?
                            WHERE store_id = ? AND material_id = ? AND quantity >= ?
                            """,
                            (qty, now.isoformat(sep=' '), source_id, material_id, qty)
                        )
                        if cur.rowcount == 0:
                            raise Exception(f"Insufficient stock for {it['material']} at source store")

                        # Increase or insert destination inventory
                        cur.execute(
                            "SELECT quantity FROM inventory WHERE store_id = ? AND material_id = ?",
                            (dest_id, material_id)
                        )
                        row = cur.fetchone()
                        if row:
                            cur.execute(
                                """
                                UPDATE inventory SET quantity = quantity + ?, last_updated = ?, unit_price = ?
                                WHERE store_id = ? AND material_id = ?
                                """,
                                (qty, now.isoformat(sep=' '), it['unit_price'], dest_id, material_id)
                            )
                        else:
                            cur.execute(
                                """
                                INSERT INTO inventory (store_id, material_id, quantity, unit_price, reorder_level, last_updated)
                                VALUES (?, ?, ?, ?, 10, ?)
                                """,
                                (dest_id, material_id, qty, it['unit_price'], now.isoformat(sep=' '))
                            )

                        # Insert transfer line
                        cur.execute(
                            """
                            INSERT INTO transfer_items (transfer_id, material_id, quantity, unit, unit_price, total)
                            VALUES (?, ?, ?, ?, ?, ?)
                            """,
                            (transfer_row_id, material_id, qty, unit_from_db or it['unit'], it['unit_price'], it['total'])
                        )

                    conn.commit()
                    conn.close()

                    try:
                        self.log_audit_action(self.current_user['id'], 'Product Transfer', f'{reference} {total_items} items {total_value:,.0f} FCFA from {source_id} to {dest_id}')
                    except Exception:
                        pass

                    messagebox.showinfo('Success', f'Transfer {reference} completed successfully.')
                    clear_list()
                    load_inventory()
                except Exception as e:
                    try:
                        conn.rollback()
                    except Exception:
                        pass
                    try:
                        messagebox.showerror('Transfer Failed', str(e))
                    except Exception:
                        pass

            # Action buttons
            actions = tk.Frame(win, bg='white')
            actions.pack(fill='x', padx=12, pady=(0, 12))
            tk.Button(actions, text='Add Selected', command=add_selected, bg='#17a2b8', fg='white', width=14).pack(side='left')
            tk.Button(actions, text='Clear List', command=clear_list, bg='#e67e22', fg='white', width=12).pack(side='left', padx=6)
            tk.Button(actions, text='Execute Transfer', command=execute, bg='#27ae60', fg='white', width=18).pack(side='right')

            # Shortcuts
            win.bind('<F5>', lambda e: load_inventory())
            win.bind('<Escape>', lambda e: win.destroy())

            # Initial load
            if from_cb['values']:
                from_cb.current(0)
            load_inventory()

        except Exception as e:
            try:
                messagebox.showerror('Error', f'Failed to open Transfer window: {e}')
            except Exception:
                pass
            return None
        return None

    def show_post_job(self):
        try:
            win = tk.Toplevel(self.root)
            win.title("Post a Job")
            win.geometry("800x650")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=12, pady=12)
            tk.Label(header, text="Post a New Job", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Form area
            form = tk.Frame(win, bg='white')
            form.pack(fill='both', expand=True, padx=16, pady=(0,10))

            # Title
            tk.Label(form, text="Job Title*:", bg='white').grid(row=0, column=0, sticky='e', padx=6, pady=6)
            title_var = tk.StringVar()
            tk.Entry(form, textvariable=title_var, width=50).grid(row=0, column=1, sticky='w')

            # Location
            tk.Label(form, text="Location:", bg='white').grid(row=1, column=0, sticky='e', padx=6, pady=6)
            location_var = tk.StringVar()
            tk.Entry(form, textvariable=location_var, width=50).grid(row=1, column=1, sticky='w')

            # Salary range
            tk.Label(form, text="Salary Range:", bg='white').grid(row=2, column=0, sticky='e', padx=6, pady=6)
            salary_var = tk.StringVar()
            tk.Entry(form, textvariable=salary_var, width=50).grid(row=2, column=1, sticky='w')

            # Deadline
            tk.Label(form, text="Application Deadline (YYYY-MM-DD):", bg='white').grid(row=3, column=0, sticky='e', padx=6, pady=6)
            deadline_var = tk.StringVar()
            tk.Entry(form, textvariable=deadline_var, width=20).grid(row=3, column=1, sticky='w')

            # Status
            tk.Label(form, text="Status:", bg='white').grid(row=4, column=0, sticky='e', padx=6, pady=6)
            status_var = tk.StringVar(value='Open')
            status_cb = ttk.Combobox(form, textvariable=status_var, state='readonly', width=20)
            status_cb['values'] = ['Open','Closed','On Hold']
            status_cb.grid(row=4, column=1, sticky='w')

            # Description
            tk.Label(form, text="Description:", bg='white').grid(row=5, column=0, sticky='ne', padx=6, pady=6)
            desc_text = tk.Text(form, width=60, height=8)
            desc_text.grid(row=5, column=1, sticky='w')

            # Requirements
            tk.Label(form, text="Requirements:", bg='white').grid(row=6, column=0, sticky='ne', padx=6, pady=6)
            req_text = tk.Text(form, width=60, height=6)
            req_text.grid(row=6, column=1, sticky='w')

            # Buttons
            btns = tk.Frame(win, bg='white')
            btns.pack(fill='x', padx=16, pady=12)
            save_btn = tk.Button(btns, text="Post Job", bg="#27ae60", fg="white", width=14)
            save_btn.pack(side='left')
            tk.Button(btns, text="Cancel", bg="#e74c3c", fg="white", width=12, command=win.destroy).pack(side='right')

            def validate_date_str(s):
                if not s:
                    return True
                try:
                    datetime.strptime(s, '%Y-%m-%d')
                    return True
                except Exception:
                    return False

            def save_job():
                try:
                    title = title_var.get().strip()
                    if not title:
                        messagebox.showwarning("Validation", "Job Title is required.")
                        return
                    location = location_var.get().strip()
                    salary = salary_var.get().strip()
                    deadline = deadline_var.get().strip()
                    if deadline and not validate_date_str(deadline):
                        messagebox.showerror("Validation", "Deadline must be in YYYY-MM-DD format")
                        return
                    status = status_var.get().strip() or 'Open'
                    description = desc_text.get('1.0','end').strip()
                    requirements = req_text.get('1.0','end').strip()

                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(
                        """
                        INSERT INTO jobs (title, description, employer_id, location, salary_range, requirements, status, posted_date, deadline)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                        """,
                        (
                            title,
                            description,
                            self.current_user['id'],
                            location,
                            salary,
                            requirements,
                            status,
                            date.today().isoformat(),
                            deadline if deadline else None
                        )
                    )
                    conn.commit()
                    conn.close()

                    try:
                        self.log_audit_action(self.current_user['id'], "Post Job", f"{title}")
                    except Exception:
                        pass

                    messagebox.showinfo("Success", "Job posted successfully.")
                    win.destroy()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to post job: {str(e)}")
                    except Exception:
                        pass

            save_btn.config(command=save_job)

            # Shortcuts
            win.bind('<Return>', lambda e: save_job())
            win.bind('<Escape>', lambda e: win.destroy())
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Post Job: {str(e)}")
            except Exception:
                pass
        return None

    def show_manage_applications(self):
        try:
            win = tk.Toplevel(self.root)
            win.title("Manage Applications")
            win.geometry("1100x650")
            win.configure(bg='white')
            win.grab_set()

            # Header
            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Job Applications", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filt = tk.LabelFrame(win, text="Filters", bg='white')
            filt.pack(fill='x', padx=10, pady=(0,10))
            tk.Label(filt, text="Job:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            job_var = tk.StringVar()
            job_cb = ttk.Combobox(filt, textvariable=job_var, state='readonly', width=40)
            job_cb.grid(row=0, column=1, sticky='w', padx=5, pady=6)
            tk.Label(filt, text="Status:", bg='white').grid(row=0, column=2, sticky='e', padx=5, pady=6)
            status_var = tk.StringVar(value='All')
            status_cb = ttk.Combobox(filt, textvariable=status_var, state='readonly', width=20)
            status_cb['values'] = ['All','Submitted','Under Review','Interview','Rejected','Hired']
            status_cb.grid(row=0, column=3, sticky='w', padx=5, pady=6)
            tk.Label(filt, text="Applicant contains:", bg='white').grid(row=0, column=4, sticky='e', padx=5, pady=6)
            search_var = tk.StringVar()
            tk.Entry(filt, textvariable=search_var, width=22).grid(row=0, column=5, sticky='w', padx=5, pady=6)
            act = tk.Frame(filt, bg='white')
            act.grid(row=0, column=6, padx=5, pady=6, sticky='w')
            refresh_btn = tk.Button(act, text="Refresh", bg="#3498db", fg="white")
            refresh_btn.pack(side='left')
            export_btn = tk.Button(act, text="Export CSV")
            export_btn.pack(side='left', padx=6)

            # Table
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Job","Applicant","Applied On","Status","Resume","Cover Letter")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=160 if c in ("Job","Applicant") else 120)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Buttons
            btns = tk.Frame(win, bg='white')
            btns.pack(fill='x', padx=10, pady=(0,10))
            review_btn = tk.Button(btns, text="Mark Under Review", bg="#2980b9", fg="white")
            interview_btn = tk.Button(btns, text="Schedule Interview", bg="#8e44ad", fg="white")
            reject_btn = tk.Button(btns, text="Reject", bg="#c0392b", fg="white")
            hire_btn = tk.Button(btns, text="Hire", bg="#27ae60", fg="white")
            open_resume_btn = tk.Button(btns, text="Open Resume")
            open_cover_btn = tk.Button(btns, text="View Cover Letter")
            review_btn.pack(side='left')
            interview_btn.pack(side='left', padx=6)
            reject_btn.pack(side='left')
            hire_btn.pack(side='left', padx=6)
            open_resume_btn.pack(side='right')
            open_cover_btn.pack(side='right', padx=6)

            # Load jobs: employers see their jobs; admins see all; contract_owner maybe all
            job_map = {"All Jobs": None}
            def load_jobs():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    role = self.current_user['role']
                    if role in ['administrator','contract_owner']:
                        cur.execute("SELECT id, title FROM jobs ORDER BY posted_date DESC")
                        rows = cur.fetchall()
                    else:
                        cur.execute("SELECT id, title FROM jobs WHERE employer_id=? ORDER BY posted_date DESC", (self.current_user['id'],))
                        rows = cur.fetchall()
                    values = ["All Jobs"]
                    for jid, title in rows:
                        disp = f"{title} (ID:{jid})"
                        job_map[disp] = jid
                        values.append(disp)
                    job_cb['values'] = values
                    job_cb.set(values[0])
                    conn.close()
                except Exception:
                    job_cb['values'] = ["All Jobs"]
                    job_cb.set("All Jobs")

            def refresh():
                try:
                    jid = job_map.get(job_var.get())
                    st = status_var.get()
                    q = search_var.get().strip()
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    query = (
                        "SELECT ja.id, j.title, u.full_name, ja.application_date, ja.status, ja.resume_path, substr(ja.cover_letter,1,50) "
                        "FROM job_applications ja "
                        "JOIN jobs j ON j.id = ja.job_id "
                        "JOIN users u ON u.id = ja.applicant_id WHERE 1=1 "
                    )
                    params = []
                    # Scope by employer unless admin/contract_owner
                    role = self.current_user['role']
                    if role not in ['administrator','contract_owner']:
                        query += "AND j.employer_id = ? "
                        params.append(self.current_user['id'])
                    if jid:
                        query += "AND ja.job_id = ? "
                        params.append(jid)
                    if st and st != 'All':
                        query += "AND ja.status = ? "
                        params.append(st)
                    if q:
                        query += "AND (u.full_name LIKE ? OR j.title LIKE ?) "
                        like = f"%{q}%"
                        params.extend([like, like])
                    query += "ORDER BY ja.application_date DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to load applications: {str(e)}")
                    except Exception:
                        pass
                    rows = []
                for it in tree.get_children():
                    tree.delete(it)
                for r in rows:
                    tree.insert('', 'end', values=r)
                try:
                    self.log_audit_action(self.current_user['id'], "View Applications", json.dumps({
                        'job': job_var.get(), 'status': status_var.get(), 'q': search_var.get()
                    }))
                except Exception:
                    pass

            def get_selected_id():
                sel = tree.selection()
                if not sel:
                    messagebox.showwarning("Select", "Select an application first.")
                    return None
                return tree.item(sel[0], 'values')[0]

            def update_status(new_status):
                app_id = get_selected_id()
                if not app_id:
                    return
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("UPDATE job_applications SET status=? WHERE id=?", (new_status, app_id))
                    conn.commit()
                    conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Update Application Status", f"{app_id} -> {new_status}")
                    except Exception:
                        pass
                    refresh()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to update status: {str(e)}")
                    except Exception:
                        pass

            def schedule_interview():
                app_id = get_selected_id()
                if not app_id:
                    return
                try:
                    dlg = tk.Toplevel(win)
                    dlg.title("Schedule Interview")
                    dlg.geometry("420x220")
                    dlg.configure(bg='white')
                    dlg.grab_set()
                    tk.Label(dlg, text="Interview Date (YYYY-MM-DD):", bg='white').pack(padx=10, pady=8, anchor='w')
                    date_var = tk.StringVar()
                    tk.Entry(dlg, textvariable=date_var, width=20).pack(padx=10, anchor='w')
                    tk.Label(dlg, text="Notes:", bg='white').pack(padx=10, pady=(8,0), anchor='w')
                    notes_text = tk.Text(dlg, width=45, height=5)
                    notes_text.pack(padx=10, pady=5)
                    def save_itv():
                        # For now, just record status change and log note (no interviews table yet)
                        update_status('Interview')
                        dlg.destroy()
                    tk.Button(dlg, text="Save", bg="#27ae60", fg="white", command=save_itv).pack(padx=10, pady=8, anchor='w')
                    tk.Button(dlg, text="Cancel", bg="#e74c3c", fg="white", command=dlg.destroy).pack(padx=10, pady=8, anchor='e')
                except Exception:
                    pass

            def open_resume():
                app_id = get_selected_id()
                if not app_id:
                    return
                # Find file path
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT resume_path FROM job_applications WHERE id=?", (app_id,))
                    row = cur.fetchone()
                    conn.close()
                    if not row or not row[0]:
                        messagebox.showinfo("Resume", "No resume uploaded for this application.")
                        return
                    path = row[0]
                    if os.path.exists(path):
                        os.startfile(path)
                    else:
                        messagebox.showwarning("Resume", f"File not found: {path}")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to open resume: {str(e)}")
                    except Exception:
                        pass

            def view_cover():
                app_id = get_selected_id()
                if not app_id:
                    return
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT cover_letter FROM job_applications WHERE id=?", (app_id,))
                    row = cur.fetchone()
                    conn.close()
                    text = row[0] if row and row[0] else "No cover letter."
                    dlg = tk.Toplevel(win)
                    dlg.title("Cover Letter")
                    dlg.geometry("600x400")
                    dlg.configure(bg='white')
                    txt = tk.Text(dlg, wrap='word')
                    txt.pack(fill='both', expand=True)
                    txt.insert('1.0', text)
                    txt.config(state='disabled')
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to open cover letter: {str(e)}")
                    except Exception:
                        pass

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"applications_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Applications", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"),("All files","*.*")])
                    if not filename:
                        return
                    # current filters
                    jid = job_map.get(job_var.get())
                    st = status_var.get()
                    q = search_var.get().strip()
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    query = (
                        "SELECT ja.id, j.title, u.full_name, ja.application_date, ja.status, ja.resume_path, ja.cover_letter "
                        "FROM job_applications ja "
                        "JOIN jobs j ON j.id = ja.job_id "
                        "JOIN users u ON u.id = ja.applicant_id WHERE 1=1 "
                    )
                    params = []
                    role = self.current_user['role']
                    if role not in ['administrator','contract_owner']:
                        query += "AND j.employer_id = ? "
                        params.append(self.current_user['id'])
                    if jid:
                        query += "AND ja.job_id = ? "
                        params.append(jid)
                    if st and st != 'All':
                        query += "AND ja.status = ? "
                        params.append(st)
                    if q:
                        query += "AND (u.full_name LIKE ? OR j.title LIKE ?) "
                        like = f"%{q}%"
                        params.extend([like, like])
                    query += "ORDER BY ja.application_date DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(["ID","Job","Applicant","Applied On","Status","Resume","Cover Letter"])
                        for r in rows:
                            writer.writerow(r)
                    messagebox.showinfo("Export", "Applications exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            # Wire actions
            refresh_btn.config(command=refresh)
            export_btn.config(command=export_csv)
            review_btn.config(command=lambda: update_status('Under Review'))
            interview_btn.config(command=schedule_interview)
            reject_btn.config(command=lambda: update_status('Rejected'))
            hire_btn.config(command=lambda: update_status('Hired'))
            open_resume_btn.config(command=open_resume)
            open_cover_btn.config(command=view_cover)

            # Change triggers
            job_var.trace('w', lambda *a: refresh())
            status_var.trace('w', lambda *a: refresh())
            search_var.trace('w', lambda *a: refresh())

            # Context menu
            def context_menu(event):
                selection = tree.selection()
                menu = tk.Menu(win, tearoff=0)
                menu.add_command(label="Mark Under Review", command=lambda: update_status('Under Review'))
                menu.add_command(label="Schedule Interview", command=schedule_interview)
                if selection:
                    menu.add_command(label="Reject", command=lambda: update_status('Rejected'))
                    menu.add_command(label="Hire", command=lambda: update_status('Hired'))
                    menu.add_separator()
                    menu.add_command(label="Open Resume", command=open_resume)
                    menu.add_command(label="View Cover Letter", command=view_cover)
                try:
                    menu.tk_popup(event.x_root, event.y_root)
                finally:
                    menu.grab_release()
            tree.bind("<Button-3>", context_menu)
            tree.bind('<Double-1>', lambda e: view_cover())

            # Shortcuts
            win.bind('<F5>', lambda e: refresh())
            win.bind('<Escape>', lambda e: win.destroy())

            # Load
            load_jobs()
            refresh()

            # Audit
            try:
                self.log_audit_action(self.current_user['id'], "Access Manage Applications", "Opened job applications manager")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Manage Applications: {str(e)}")
            except Exception:
                pass
        return None

    def show_view_contracts(self):
        # View Contracts window for contractors
        contracts_window = tk.Toplevel(self.root)
        contracts_window.title("View Contracts - Contractor Dashboard")
        contracts_window.geometry("1300x750")
        contracts_window.configure(bg='white')
        contracts_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(contracts_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="Contract Dashboard - Contractor View", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Filter frame
        filter_frame = tk.Frame(header_frame, bg='white')
        filter_frame.pack(side='right')

        # Status filter
        tk.Label(filter_frame, text="Status:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        status_filter_var = tk.StringVar()
        status_filter = ttk.Combobox(filter_frame, textvariable=status_filter_var, width=12, state='readonly')
        status_filter['values'] = ['All', 'Available', 'Assigned to Me', 'Active', 'Completed', 'On Hold']
        status_filter.set('All')
        status_filter.pack(side='left', padx=(0, 10))

        # Date filter
        tk.Label(filter_frame, text="Period:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        date_filter_var = tk.StringVar()
        date_filter = ttk.Combobox(filter_frame, textvariable=date_filter_var, width=12, state='readonly')
        date_filter['values'] = ['All Time', 'This Year', 'Last 6 Months', 'This Month']
        date_filter.set('All Time')
        date_filter.pack(side='left', padx=(0, 10))

        # Search entry
        tk.Label(filter_frame, text="Search:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        search_var = tk.StringVar()
        search_entry = tk.Entry(filter_frame, textvariable=search_var, font=('Arial', 10), width=15)
        search_entry.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(filter_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left')

        # Statistics frame
        stats_frame = tk.Frame(main_frame, bg='#ecf0f1', relief='raised', bd=1)
        stats_frame.pack(fill='x', pady=(0, 10))

        stats_inner = tk.Frame(stats_frame, bg='#ecf0f1')
        stats_inner.pack(pady=10)

        # Statistics labels
        available_label = tk.Label(stats_inner, text="Available: 0", font=('Arial', 10, 'bold'),
                                   bg='#ecf0f1', fg='#3498db')
        available_label.pack(side='left', padx=20)

        my_contracts_label = tk.Label(stats_inner, text="My Contracts: 0", font=('Arial', 10, 'bold'),
                                      bg='#ecf0f1', fg='#27ae60')
        my_contracts_label.pack(side='left', padx=20)

        active_label = tk.Label(stats_inner, text="Active: 0", font=('Arial', 10, 'bold'),
                                bg='#ecf0f1', fg='#e67e22')
        active_label.pack(side='left', padx=20)

        total_value_label = tk.Label(stats_inner, text="Total Value: 0 FCFA", font=('Arial', 10, 'bold'),
                                     bg='#ecf0f1', fg='#9b59b6')
        total_value_label.pack(side='left', padx=20)

        # Contracts treeview frame
        tree_frame = tk.Frame(main_frame, bg='white')
        tree_frame.pack(fill='both', expand=True, pady=(0, 20))

        # Treeview with scrollbars
        tree_scroll_y = ttk.Scrollbar(tree_frame)
        tree_scroll_y.pack(side='right', fill='y')

        tree_scroll_x = ttk.Scrollbar(tree_frame, orient='horizontal')
        tree_scroll_x.pack(side='bottom', fill='x')

        contracts_tree = ttk.Treeview(tree_frame,
                                      columns=('ID', 'Title', 'Owner', 'Budget', 'Start Date', 'End Date', 'Status',
                                               'Assignment'),
                                      show='headings',
                                      yscrollcommand=tree_scroll_y.set,
                                      xscrollcommand=tree_scroll_x.set)
        contracts_tree.pack(fill='both', expand=True)

        tree_scroll_y.config(command=contracts_tree.yview)
        tree_scroll_x.config(command=contracts_tree.xview)

        # Configure columns
        columns_config = [
            ('ID', 60, 'center'),
            ('Title', 220, 'w'),
            ('Owner', 150, 'w'),
            ('Budget', 120, 'e'),
            ('Start Date', 100, 'center'),
            ('End Date', 100, 'center'),
            ('Status', 100, 'center'),
            ('Assignment', 120, 'center')
        ]

        for col, width, anchor in columns_config:
            contracts_tree.heading(col, text=col)
            contracts_tree.column(col, width=width, anchor=anchor)

        # Configure row colors based on assignment and status
        contracts_tree.tag_configure('available', background='#e8f4fd')
        contracts_tree.tag_configure('assigned_to_me', background='#e8f5e8')
        contracts_tree.tag_configure('active', background='#fff3e0')
        contracts_tree.tag_configure('completed', background='#f3e5f5')
        contracts_tree.tag_configure('on_hold', background='#ffebee')
        contracts_tree.tag_configure('overdue', background='#ffcdd2', foreground='#d32f2f')

        # Action buttons frame
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(0, 10))

        # Left side buttons (contract actions)
        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')

        apply_btn = tk.Button(left_buttons, text="Apply for Contract", font=('Arial', 10, 'bold'),
                              bg='#28a745', fg='white', width=15)
        apply_btn.pack(side='left', padx=(0, 5))

        view_details_btn = tk.Button(left_buttons, text="View Details", font=('Arial', 10, 'bold'),
                                     bg='#17a2b8', fg='white', width=12)
        view_details_btn.pack(side='left', padx=(0, 5))

        submit_proposal_btn = tk.Button(left_buttons, text="Submit Proposal", font=('Arial', 10),
                                        bg='#fd7e14', fg='white', width=14)
        submit_proposal_btn.pack(side='left', padx=(0, 5))

        update_progress_btn = tk.Button(left_buttons, text="Update Progress", font=('Arial', 10),
                                        bg='#6f42c1', fg='white', width=14)
        update_progress_btn.pack(side='left', padx=(0, 5))

        # Right side buttons
        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')

        export_btn = tk.Button(right_buttons, text="Export My Contracts", font=('Arial', 10),
                               bg='#6c757d', fg='white', width=16)
        export_btn.pack(side='left', padx=(0, 5))

        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10),
                              bg='#dc3545', fg='white', width=10,
                              command=contracts_window.destroy)
        close_btn.pack(side='left')

        # Load and display contracts
        def load_contracts():
            # Clear existing items
            for item in contracts_tree.get_children():
                contracts_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Build query based on filters
                search_text = search_var.get().strip()
                status_filter_text = status_filter_var.get()
                date_filter_text = date_filter_var.get()

                query = '''
                        SELECT c.id,
                               c.title,
                               owner.full_name as owner_name,
                               c.budget,
                               c.start_date,
                               c.end_date,
                               c.status,
                               c.contractor_id,
                               c.created_date,
                               c.description
                        FROM contracts c
                                 JOIN users owner ON c.contract_owner_id = owner.id
                        WHERE 1 = 1
                        '''
                params = []

                # Apply status-based filters
                if status_filter_text == 'Available':
                    query += ' AND c.contractor_id IS NULL AND c.status IN ("Draft", "Pending Review")'
                elif status_filter_text == 'Assigned to Me':
                    query += ' AND c.contractor_id = ?'
                    params.append(self.current_user['id'])
                elif status_filter_text != 'All':
                    query += ' AND c.status = ?'
                    params.append(status_filter_text)

                # Apply search filter
                if search_text:
                    query += ' AND (c.title LIKE ? OR c.description LIKE ? OR owner.full_name LIKE ?)'
                    search_pattern = f'%{search_text}%'
                    params.extend([search_pattern, search_pattern, search_pattern])

                # Apply date filter
                if date_filter_text == 'This Year':
                    query += ' AND strftime("%Y", c.created_date) = strftime("%Y", "now")'
                elif date_filter_text == 'Last 6 Months':
                    query += ' AND c.created_date >= date("now", "-6 months")'
                elif date_filter_text == 'This Month':
                    query += ' AND strftime("%Y-%m", c.created_date) = strftime("%Y-%m", "now")'

                query += ' ORDER BY c.created_date DESC'

                cursor.execute(query, params)
                contracts = cursor.fetchall()

                # Statistics counters
                available_count = 0
                my_contracts_count = 0
                active_count = 0
                total_my_value = 0

                # Process each contract
                from datetime import datetime as dt, date as dt_date
                today = dt_date.today()

                for contract in contracts:
                    contract_id, title, owner, budget, start_date, end_date, status, contractor_id, created_date, description = contract

                    # Determine assignment status
                    if contractor_id == self.current_user['id']:
                        assignment_status = "Assigned to Me"
                        my_contracts_count += 1
                        if budget:
                            total_my_value += budget
                        if status == 'Active':
                            active_count += 1
                    elif contractor_id is None:
                        assignment_status = "Available"
                        available_count += 1
                    else:
                        assignment_status = "Assigned to Other"

                    # Determine row styling
                    tags = []
                    if contractor_id == self.current_user['id']:
                        tags.append('assigned_to_me')
                        if status == 'Active':
                            tags.append('active')
                        elif status == 'Completed':
                            tags.append('completed')
                        elif status == 'On Hold':
                            tags.append('on_hold')
                    elif contractor_id is None:
                        tags.append('available')

                    # Check if overdue
                    if end_date and status == 'Active' and contractor_id == self.current_user['id']:
                        try:
                            end_dt = dt.strptime(end_date, '%Y-%m-%d').date()
                            if today > end_dt:
                                tags.append('overdue')
                        except:
                            pass

                    # Format budget
                    budget_display = f"{budget:,.0f}" if budget else "0"

                    contracts_tree.insert('', 'end', values=(
                        contract_id,
                        title[:35] + '...' if len(title) > 35 else title,
                        owner,
                        budget_display,
                        start_date or 'N/A',
                        end_date or 'N/A',
                        status,
                        assignment_status
                    ), tags=tags)

                # Update statistics
                available_label.config(text=f"Available: {available_count}")
                my_contracts_label.config(text=f"My Contracts: {my_contracts_count}")
                active_label.config(text=f"Active: {active_count}")
                total_value_label.config(text=f"Total Value: {total_my_value:,.0f} FCFA")

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contracts: {str(e)}")

        # Apply filters when changed
        def on_filter_change(*args):
            load_contracts()

        status_filter_var.trace_add('write', on_filter_change)
        date_filter_var.trace_add('write', on_filter_change)

        def show_context_menu(event):
            # Context menu for treeview
            item = contracts_tree.identify_row(event.y)
            if not item:
                return
            contracts_tree.selection_set(item)

            menu = tk.Menu(contracts_window, tearoff=0)
            menu.add_command(label="View Details", command=view_contract_details)
            menu.add_command(label="Apply for Contract", command=apply_for_contract)
            menu.add_command(label="Update Progress", command=lambda: update_progress_dialog(get_selected_id()))
            menu.tk_popup(event.x_root, event.y_root)

        contracts_tree.bind('<Button-3>', show_context_menu)

        def get_selected_id():
            sel = contracts_tree.selection()
            if not sel:
                return None
            vals = contracts_tree.item(sel, 'values')
            return int(vals[0]) if vals else None

        def apply_for_contract():
            contract_id = get_selected_id()
            if not contract_id:
                messagebox.showwarning("Select Contract", "Please select a contract to apply for.")
                return

            # Check if already assigned or applied
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()

                # Ensure table exists
                try:
                    cur.execute('''
                        CREATE TABLE IF NOT EXISTS contract_applications (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            contract_id INTEGER NOT NULL,
                            contractor_id INTEGER NOT NULL,
                            proposal_summary TEXT,
                            quoted_amount REAL,
                            estimated_duration INTEGER,
                            status TEXT,
                            applied_date TEXT
                        )
                    ''')
                except Exception:
                    pass

                # Check if contract already assigned
                cur.execute("SELECT contractor_id, status FROM contracts WHERE id=?", (contract_id,))
                row = cur.fetchone()
                if not row:
                    messagebox.showerror("Error", "Selected contract not found.")
                    conn.close()
                    return

                contractor_id, status = row
                if contractor_id:
                    messagebox.showinfo("Already Assigned", "This contract has already been assigned.")
                    conn.close()
                    return

                # Check if already applied
                cur.execute("SELECT COUNT(*) FROM contract_applications WHERE contract_id=? AND contractor_id=?",
                            (contract_id, self.current_user['id']))
                if cur.fetchone()[0] > 0:
                    messagebox.showinfo("Already Applied", "You have already applied for this contract.")
                    conn.close()
                    return

                # Show application dialog
                dialog = tk.Toplevel(contracts_window)
                dialog.title("Apply for Contract")
                dialog.geometry("580x420")
                dialog.configure(bg='white')
                dialog.grab_set()

                tk.Label(dialog, text="Application for Contract #" + str(contract_id), font=('Arial', 14, 'bold'),
                         bg='white').pack(pady=10)

                form = tk.Frame(dialog, bg='white')
                form.pack(fill='x', padx=10)

                tk.Label(form, text="Proposal Summary:", bg='white').grid(row=0, column=0, sticky='ne', padx=5, pady=5)
                proposal_var = tk.Text(form, width=50, height=6)
                proposal_var.grid(row=0, column=1, sticky='w', padx=5, pady=5)

                tk.Label(form, text="Quoted Amount (FCFA):", bg='white').grid(row=1, column=0, sticky='e', padx=5, pady=5)
                amount_var = tk.StringVar()
                tk.Entry(form, textvariable=amount_var, width=20).grid(row=1, column=1, sticky='w', padx=5, pady=5)

                tk.Label(form, text="Estimated Duration (days):", bg='white').grid(row=2, column=0, sticky='e', padx=5, pady=5)
                duration_var = tk.StringVar()
                tk.Entry(form, textvariable=duration_var, width=20).grid(row=2, column=1, sticky='w', padx=5, pady=5)

                btns = tk.Frame(dialog, bg='white')
                btns.pack(pady=10)
                def submit_application():
                    try:
                        amt = float(amount_var.get().replace(',', '').strip() or 0)
                    except Exception:
                        messagebox.showerror("Invalid Amount", "Please enter a valid numeric amount.")
                        return
                    try:
                        dur = int(duration_var.get().strip() or 0)
                    except Exception:
                        messagebox.showerror("Invalid Duration", "Please enter a whole number of days.")
                        return
                    proposal = proposal_var.get("1.0", "end").strip()
                    if not proposal:
                        messagebox.showwarning("Missing", "Please enter a brief proposal summary.")
                        return
                    try:
                        cur.execute(
                            """
                            INSERT INTO contract_applications
                                (contract_id, contractor_id, proposal_summary, quoted_amount, estimated_duration, status, applied_date)
                            VALUES (?, ?, ?, ?, ?, 'Submitted', date('now'))
                            """,
                            (contract_id, self.current_user['id'], proposal, amt, dur)
                        )
                        conn.commit()
                        messagebox.showinfo("Submitted", "Your application has been submitted.")
                        dialog.destroy()
                        load_contracts()
                        # Audit
                        try:
                            self.log_audit_action(self.current_user['id'], "Apply for Contract",
                                                  f"Applied for contract {contract_id}")
                        except Exception:
                            pass
                    except Exception as ex:
                        messagebox.showerror("Error", f"Failed to submit application: {ex}")

                tk.Button(btns, text="Submit", bg="#28a745", fg="white", command=submit_application).pack(side='left', padx=5)
                tk.Button(btns, text="Cancel", bg="#dc3545", fg="white", command=dialog.destroy).pack(side='left', padx=5)

                conn.close()
            except Exception as e:
                messagebox.showerror("Error", f"Unable to process application: {e}")

        apply_btn.config(command=apply_for_contract)

        def view_contract_details():
            contract_id = get_selected_id()
            if not contract_id:
                messagebox.showwarning("Select Contract", "Please select a contract to view details.")
                return
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                cur.execute(
                    """
                    SELECT c.id, c.title, u.full_name AS owner_name, c.description, c.requirements,
                           COALESCE(c.contract_kind,'Labour Only') AS contract_kind,
                           COALESCE(c.includes_materials,0) AS includes_materials,
                           c.budget, c.start_date, c.end_date, c.status, c.created_date
                    FROM contracts c JOIN users u ON c.contract_owner_id = u.id
                    WHERE c.id=?
                    """, (contract_id,)
                )
                row = cur.fetchone()
                conn.close()
                if not row:
                    messagebox.showerror("Error", "Contract not found.")
                    return
                # Detail window
                d = tk.Toplevel(contracts_window)
                d.title(f"Contract #{row[0]} - Details")
                d.geometry("820x620")
                d.configure(bg='white')
                d.grab_set()

                header = tk.Frame(d, bg='white')
                header.pack(fill='x', padx=10, pady=10)
                tk.Label(header, text=row[1], font=('Arial', 16, 'bold'), bg='white').pack(side='left')

                body = tk.Frame(d, bg='white')
                body.pack(fill='both', expand=True, padx=10, pady=10)

                # Text area with scroll
                text_frame = tk.Frame(body, bg='white')
                text_frame.pack(fill='both', expand=True)
                sy = ttk.Scrollbar(text_frame, orient='vertical')
                sx = ttk.Scrollbar(text_frame, orient='horizontal')
                text = tk.Text(text_frame, wrap='word', yscrollcommand=sy.set, xscrollcommand=sx.set, bg='white')
                sy.config(command=text.yview)
                sx.config(command=text.xview)
                text.pack(side='left', fill='both', expand=True)
                sy.pack(side='right', fill='y')
                sx.pack(side='bottom', fill='x')

                # Populate content
                def add_line(title, value):
                    text.insert('end', f"{title}: ")
                    text.insert('end', f"{value}\n\n")
                add_line("Owner", row[2])
                add_line("Contract Kind", row[5] or 'Labour Only')
                add_line("Includes Materials", 'Yes' if (row[6]==1 or row[6]==True) else 'No')
                add_line("Budget", f"{(row[7] or 0):,.0f} FCFA")
                add_line("Start Date", row[8] or 'N/A')
                add_line("End Date", row[9] or 'N/A')
                add_line("Status", row[10])
                text.insert('end', "Description:\n")
                text.insert('end', (row[3] or 'No description provided.') + "\n\n")
                text.insert('end', "Requirements:\n")
                text.insert('end', (row[4] or 'No requirements provided.') + "\n")

                # Close
                tk.Button(d, text="Close", bg="#dc3545", fg="white", command=d.destroy).pack(pady=8)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to open details: {e}")

        view_details_btn.config(command=view_contract_details)

        def update_progress_dialog(contract_id):
            if not contract_id:
                messagebox.showwarning("Select Contract", "Please select a contract to update progress.")
                return
            try:
                d = tk.Toplevel(contracts_window)
                d.title(f"Update Progress - Contract #{contract_id}")
                d.geometry("520x360")
                d.configure(bg='white')
                d.grab_set()

                tk.Label(d, text="Progress Update", font=('Arial', 14, 'bold'), bg='white').pack(pady=10)
                form = tk.Frame(d, bg='white')
                form.pack(fill='x', padx=10)
                tk.Label(form, text="Current Status:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
                status_var = tk.StringVar(value='On Track')
                cb = ttk.Combobox(form, textvariable=status_var, state='readonly', values=['On Track','Delayed','At Risk','Completed'])
                cb.grid(row=0, column=1, sticky='w', padx=5, pady=6)
                tk.Label(form, text="Progress Note:", bg='white').grid(row=1, column=0, sticky='ne', padx=5, pady=6)
                note = tk.Text(form, width=46, height=8)
                note.grid(row=1, column=1, sticky='w', padx=5, pady=6)
                def save_progress():
                    try:
                        conn = self.db_manager.create_connection()
                        cur = conn.cursor()
                        # Ensure progress table exists
                        try:
                            cur.execute('''
                                CREATE TABLE IF NOT EXISTS contract_progress (
                                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                                    contract_id INTEGER NOT NULL,
                                    contractor_id INTEGER NOT NULL,
                                    status TEXT,
                                    note TEXT,
                                    update_time TEXT
                                )
                            ''')
                        except Exception:
                            pass
                        cur.execute(
                            """
                            INSERT INTO contract_progress (contract_id, contractor_id, status, note, update_time)
                            VALUES (?, ?, ?, ?, datetime('now'))
                            """,
                            (contract_id, self.current_user['id'], status_var.get(), note.get("1.0","end").strip())
                        )
                        conn.commit()
                        conn.close()
                        messagebox.showinfo("Saved", "Progress updated.")
                        d.destroy()
                    except Exception as ex:
                        messagebox.showerror("Error", f"Failed to save progress: {ex}")
                btns = tk.Frame(d, bg='white')
                btns.pack(pady=10)
                tk.Button(btns, text="Save", bg="#28a745", fg="white", command=save_progress).pack(side='left', padx=5)
                tk.Button(btns, text="Cancel", bg="#dc3545", fg="white", command=d.destroy).pack(side='left', padx=5)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to open progress dialog: {e}")

        update_progress_btn.config(command=lambda: update_progress_dialog(get_selected_id()))

        def export_my_contracts():
            try:
                # Gather currently visible rows into a DataFrame
                rows = [contracts_tree.item(i, 'values') for i in contracts_tree.get_children()]
                if not rows:
                    messagebox.showinfo("No Data", "There are no contracts to export.")
                    return
                cols = ['ID','Title','Owner','Budget','Start Date','End Date','Status','Assignment']
                if HAS_PANDAS:
                    df = pd.DataFrame(rows, columns=cols)
                else:
                    df = None
                # Save using file dialog
                from tkinter import filedialog
                file_path = filedialog.asksaveasfilename(defaultextension='.csv',
                                                         filetypes=[('CSV Files','*.csv')],
                                                         title='Export Contracts to CSV',
                                                         initialfile='my_contracts.csv')
                if not file_path:
                    return
                if df is not None:
                    df.to_csv(file_path, index=False)
                else:
                    import csv
                    with open(file_path, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(cols)
                        for r in rows:
                            writer.writerow(list(r))
                messagebox.showinfo("Exported", f"Contracts exported to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export: {e}")

        export_btn.config(command=export_my_contracts)

        # Wire up controls to apply filters/search
        refresh_btn.config(command=load_contracts)
        search_entry.bind('<KeyRelease>', lambda e: load_contracts())
        search_entry.bind('<Return>', lambda e: load_contracts())
        contracts_tree.bind('<Double-1>', lambda e: view_contract_details())

        # Keyboard shortcuts
        contracts_window.bind('<F5>', lambda e: load_contracts())
        contracts_window.bind('<Escape>', lambda e: contracts_window.destroy())

        # Initial load
        load_contracts()

        # Log the action
        self.log_audit_action(
            self.current_user['id'],
            "View Contracts",
            "Opened contractor contract dashboard"
        )
        return None

    def show_sign_contracts(self):
        # Sign Contracts window for contractors
        sign_window = tk.Toplevel(self.root)
        sign_window.title("Sign Contracts - Contractor Dashboard")
        sign_window.geometry("1300x750")
        sign_window.configure(bg='white')
        sign_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(sign_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="Digital Contract Signing - Contractor", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Filter frame
        filter_frame = tk.Frame(header_frame, bg='white')
        filter_frame.pack(side='right')

        # Signature status filter
        tk.Label(filter_frame, text="Signature Status:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        signature_filter_var = tk.StringVar()
        signature_filter = ttk.Combobox(filter_frame, textvariable=signature_filter_var, width=15, state='readonly')
        signature_filter['values'] = ['All', 'Unsigned by Me', 'Signed by Me', 'Pending Owner Signature',
                                      'Fully Signed']
        signature_filter.set('All')
        signature_filter.pack(side='left', padx=(0, 10))

        # Contract status filter
        tk.Label(filter_frame, text="Status:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        status_filter_var = tk.StringVar()
        status_filter = ttk.Combobox(filter_frame, textvariable=status_filter_var, width=12, state='readonly')
        status_filter['values'] = ['All', 'Active', 'Pending Review', 'On Hold', 'Completed']
        status_filter.set('All')
        status_filter.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(filter_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left')

        # Statistics frame
        stats_frame = tk.Frame(main_frame, bg='#ecf0f1', relief='raised', bd=1)
        stats_frame.pack(fill='x', pady=(0, 10))

        stats_inner = tk.Frame(stats_frame, bg='#ecf0f1')
        stats_inner.pack(pady=10)

        # Statistics labels
        total_contracts_label = tk.Label(stats_inner, text="My Contracts: 0", font=('Arial', 10, 'bold'),
                                         bg='#ecf0f1', fg='#2c3e50')
        total_contracts_label.pack(side='left', padx=20)

        unsigned_label = tk.Label(stats_inner, text="Unsigned by Me: 0", font=('Arial', 10, 'bold'),
                                  bg='#ecf0f1', fg='#e74c3c')
        unsigned_label.pack(side='left', padx=20)

        signed_label = tk.Label(stats_inner, text="Signed by Me: 0", font=('Arial', 10, 'bold'),
                                bg='#ecf0f1', fg='#27ae60')
        signed_label.pack(side='left', padx=20)

        fully_signed_label = tk.Label(stats_inner, text="Fully Signed: 0", font=('Arial', 10, 'bold'),
                                      bg='#ecf0f1', fg='#9b59b6')
        fully_signed_label.pack(side='left', padx=20)

        # Contracts treeview frame
        tree_frame = tk.Frame(main_frame, bg='white')
        tree_frame.pack(fill='both', expand=True, pady=(0, 20))

        # Treeview with scrollbars
        tree_scroll_y = ttk.Scrollbar(tree_frame)
        tree_scroll_y.pack(side='right', fill='y')

        tree_scroll_x = ttk.Scrollbar(tree_frame, orient='horizontal')
        tree_scroll_x.pack(side='bottom', fill='x')

        contracts_tree = ttk.Treeview(tree_frame,
                                      columns=('ID', 'Title', 'Owner', 'Budget', 'Owner Signed', 'My Signature',
                                               'Status', 'Action Required'),
                                      show='headings',
                                      yscrollcommand=tree_scroll_y.set,
                                      xscrollcommand=tree_scroll_x.set)
        contracts_tree.pack(fill='both', expand=True)

        tree_scroll_y.config(command=contracts_tree.yview)
        tree_scroll_x.config(command=contracts_tree.xview)

        # Configure columns
        columns_config = [
            ('ID', 60, 'center'),
            ('Title', 220, 'w'),
            ('Owner', 150, 'w'),
            ('Budget', 120, 'e'),
            ('Owner Signed', 100, 'center'),
            ('My Signature', 100, 'center'),
            ('Status', 100, 'center'),
            ('Action Required', 120, 'center')
        ]

        for col, width, anchor in columns_config:
            contracts_tree.heading(col, text=col)
            contracts_tree.column(col, width=width, anchor=anchor)

        contracts_tree.tag_configure('action_needed', background='#fff3cd')
        contracts_tree.tag_configure('done', background='#e8f5e9')

        # Action buttons
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(0, 10))

        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')
        sign_btn = tk.Button(left_buttons, text="Sign Contract", font=('Arial', 10, 'bold'), bg='#28a745', fg='white', width=14)
        sign_btn.pack(side='left', padx=5)
        view_btn = tk.Button(left_buttons, text="View Contract", font=('Arial', 10, 'bold'), bg='#17a2b8', fg='white', width=14)
        view_btn.pack(side='left', padx=5)
        sigs_btn = tk.Button(left_buttons, text="View Signatures", font=('Arial', 10), bg='#6f42c1', fg='white', width=16)
        sigs_btn.pack(side='left', padx=5)
        dl_btn = tk.Button(left_buttons, text="Download", font=('Arial', 10), bg='#6c757d', fg='white', width=12)
        dl_btn.pack(side='left', padx=5)

        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')
        report_btn = tk.Button(right_buttons, text="Export Report", font=('Arial', 10), bg='#fd7e14', fg='white', width=14)
        report_btn.pack(side='left', padx=5)
        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10), bg='#dc3545', fg='white', width=10, command=sign_window.destroy)
        close_btn.pack(side='left')

        def get_selected_id():
            sel = contracts_tree.selection()
            if not sel:
                return None
            vals = contracts_tree.item(sel, 'values')
            return int(vals[0]) if vals else None

        def load_contracts():
            for item in contracts_tree.get_children():
                contracts_tree.delete(item)
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                # Load only contracts assigned to this contractor
                query = """
                        SELECT c.id, c.title, owner.full_name, c.budget,
                               CASE WHEN c.owner_signature IS NOT NULL THEN 'Yes' ELSE 'No' END AS owner_signed,
                               CASE WHEN c.contractor_signature IS NOT NULL THEN 'Yes' ELSE 'No' END AS my_signed,
                               c.status,
                               CASE
                                 WHEN c.contractor_signature IS NULL THEN 'Your Signature'
                                 WHEN c.owner_signature IS NULL THEN 'Owner Signature'
                                 ELSE 'None'
                               END as action_required
                        FROM contracts c JOIN users owner ON c.contract_owner_id=owner.id
                        WHERE c.contractor_id=?
                        ORDER BY c.id DESC
                        """
                # Ensure signature columns exist; try adding if missing
                try:
                    cur.execute(query, (self.current_user['id'],))
                except Exception:
                    try:
                        cur.execute("ALTER TABLE contracts ADD COLUMN owner_signature BLOB")
                    except Exception:
                        pass
                    try:
                        cur.execute("ALTER TABLE contracts ADD COLUMN contractor_signature BLOB")
                    except Exception:
                        pass
                    cur.execute(query, (self.current_user['id'],))
                rows = cur.fetchall()
                total = len(rows)
                unsigned = sum(1 for r in rows if r[5] == 'No')
                signed = sum(1 for r in rows if r[5] == 'Yes')
                fully_signed = sum(1 for r in rows if r[4] == 'Yes' and r[5] == 'Yes')
                total_contracts_label.config(text=f"My Contracts: {total}")
                unsigned_label.config(text=f"Unsigned by Me: {unsigned}")
                signed_label.config(text=f"Signed by Me: {signed}")
                fully_signed_label.config(text=f"Fully Signed: {fully_signed}")

                # Fill table
                for r in rows:
                    tags = []
                    if r[7] != 'None':
                        tags.append('action_needed')
                    else:
                        tags.append('done')
                    budget_display = f"{(r[3] or 0):,.0f}"
                    contracts_tree.insert('', 'end', values=(r[0], r[1], r[2], budget_display, r[4], r[5], r[6], r[7]), tags=tags)
                conn.close()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contracts: {e}")

        def sign_contract():
            cid = get_selected_id()
            if not cid:
                messagebox.showwarning("Select", "Please select a contract to sign.")
                return
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                cur.execute("SELECT contractor_signature, owner_signature, title FROM contracts WHERE id=? AND contractor_id=?", (cid, self.current_user['id']))
                row = cur.fetchone()
                if not row:
                    conn.close()
                    messagebox.showerror("Error", "Contract not found or not assigned to you.")
                    return
                my_sig, owner_sig, title = row
                if my_sig:
                    conn.close()
                    messagebox.showinfo("Signed", "You have already signed this contract.")
                    return

                # Signature dialog
                d = tk.Toplevel(sign_window)
                d.title("Sign Contract")
                d.geometry("520x360")
                d.configure(bg='white')
                d.grab_set()

                tk.Label(d, text=f"Sign Contract #{cid} - {title}", font=('Arial', 14, 'bold'), bg='white').pack(pady=10)
                tk.Label(d, text="Type your full name as signature:", bg='white').pack(pady=(10,4))
                name_var = tk.StringVar(value=self.current_user.get('full_name') or self.current_user.get('username'))
                entry = tk.Entry(d, textvariable=name_var, width=40)
                entry.pack()

                def create_contractor_signature():
                    sig_text = name_var.get().strip()
                    if not sig_text:
                        messagebox.showwarning("Missing", "Please enter your name to sign.")
                        return
                    try:
                        # Store a simple text signature; could be extended to digital signature
                        cur.execute("UPDATE contracts SET contractor_signature=? WHERE id=?", (sig_text.encode('utf-8'), cid))
                        conn.commit()
                        try:
                            self.ensure_contract_active_if_fully_signed(cid)
                        except Exception:
                            pass
                        conn.close()
                        messagebox.showinfo("Signed", "Contract signed successfully.")
                        d.destroy()
                        load_contracts()
                        try:
                            self.log_audit_action(self.current_user['id'], "Sign Contract", f"Signed contract {cid}")
                        except Exception:
                            pass
                    except Exception as ex:
                        messagebox.showerror("Error", f"Failed to sign: {ex}")

                btns = tk.Frame(d, bg='white')
                btns.pack(pady=10)
                tk.Button(btns, text="Sign", bg="#28a745", fg="white", command=create_contractor_signature).pack(side='left', padx=6)
                tk.Button(btns, text="Cancel", bg="#dc3545", fg="white", command=d.destroy).pack(side='left', padx=6)
            except Exception as e:
                messagebox.showerror("Error", f"Unable to sign: {e}")

        def view_contract():
            cid = get_selected_id()
            if not cid:
                messagebox.showwarning("Select", "Please select a contract to view.")
                return
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                cur.execute(
                    """
                    SELECT c.id, c.title, u.full_name, c.description, c.requirements, c.budget,
                           c.start_date, c.end_date, c.status,
                           CASE WHEN c.owner_signature IS NOT NULL THEN 'Yes' ELSE 'No' END,
                           CASE WHEN c.contractor_signature IS NOT NULL THEN 'Yes' ELSE 'No' END
                    FROM contracts c JOIN users u ON c.contract_owner_id=u.id
                    WHERE c.id=?
                    """, (cid,)
                )
                row = cur.fetchone()
                conn.close()
                if not row:
                    messagebox.showerror("Error", "Contract not found.")
                    return
                w = tk.Toplevel(sign_window)
                w.title(f"Contract #{row[0]} - {row[1]}")
                w.geometry("860x640")
                w.configure(bg='white')
                w.grab_set()

                header = tk.Frame(w, bg='white')
                header.pack(fill='x', padx=10, pady=10)
                tk.Label(header, text=row[1], font=('Arial', 16, 'bold'), bg='white').pack(side='left')

                body = tk.Frame(w, bg='white')
                body.pack(fill='both', expand=True, padx=10, pady=10)

                text_frame = tk.Frame(body, bg='white')
                text_frame.pack(fill='both', expand=True)
                sy = ttk.Scrollbar(text_frame, orient='vertical')
                sx = ttk.Scrollbar(text_frame, orient='horizontal')
                text = tk.Text(text_frame, wrap='word', yscrollcommand=sy.set, xscrollcommand=sx.set, bg='white')
                sy.config(command=text.yview)
                sx.config(command=text.xview)
                text.pack(side='left', fill='both', expand=True)
                sy.pack(side='right', fill='y')
                sx.pack(side='bottom', fill='x')

                def add_line(title, value):
                    text.insert('end', f"{title}: ")
                    text.insert('end', f"{value}\n\n")
                add_line("Owner", row[2])
                add_line("Budget", f"{(row[5] or 0):,.0f} FCFA")
                add_line("Start Date", row[6] or 'N/A')
                add_line("End Date", row[7] or 'N/A')
                add_line("Status", row[8])
                add_line("Owner Signed", row[9])
                add_line("My Signature", row[10])
                text.insert('end', "Description:\n")
                text.insert('end', (row[3] or 'No description provided.') + "\n\n")
                text.insert('end', "Requirements:\n")
                text.insert('end', (row[4] or 'No requirements provided.') + "\n")

                tk.Button(w, text="Close", bg="#dc3545", fg="white", command=w.destroy).pack(pady=8)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to open contract: {e}")

        def view_signatures():
            cid = get_selected_id()
            if not cid:
                messagebox.showwarning("Select", "Please select a contract.")
                return
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                cur.execute("SELECT owner_signature, contractor_signature FROM contracts WHERE id=?", (cid,))
                row = cur.fetchone()
                conn.close()
                if not row:
                    messagebox.showerror("Error", "Contract not found.")
                    return
                owner_sig, my_sig = row
                info = []
                info.append(f"Owner Signature: {'Present' if owner_sig else 'Missing'}")
                info.append(f"My Signature: {'Present' if my_sig else 'Missing'}")
                messagebox.showinfo("Signature Status", "\n".join(info))
            except Exception as e:
                messagebox.showerror("Error", f"Failed to retrieve signatures: {e}")

        def download_contract():
            cid = get_selected_id()
            if not cid:
                messagebox.showwarning("Select", "Please select a contract.")
                return
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                cur.execute("SELECT title, description, requirements FROM contracts WHERE id=?", (cid,))
                row = cur.fetchone()
                conn.close()
                if not row:
                    messagebox.showerror("Error", "Contract not found.")
                    return
                from tkinter import filedialog
                path = filedialog.asksaveasfilename(defaultextension='.txt', filetypes=[('Text Files','*.txt')], initialfile=f"contract_{cid}.txt")
                if not path:
                    return
                with open(path, 'w', encoding='utf-8') as f:
                    f.write(f"Contract #{cid} - {row[0]}\n\n")
                    f.write("Description:\n")
                    f.write((row[1] or '') + "\n\n")
                    f.write("Requirements:\n")
                    f.write((row[2] or '') + "\n")
                messagebox.showinfo("Downloaded", f"Contract saved to {path}")
            except Exception as e:
                messagebox.showerror("Error", f"Download failed: {e}")

        def export_report():
            try:
                rows = [contracts_tree.item(i, 'values') for i in contracts_tree.get_children()]
                if not rows:
                    messagebox.showinfo("No Data", "There is no data to export.")
                    return
                if HAS_PANDAS:
                    df = pd.DataFrame(rows, columns=['ID','Title','Owner','Budget','Owner Signed','My Signature','Status','Action Required'])
                else:
                    # Fallback: write CSV manually if pandas is not available
                    df = None
                from tkinter import filedialog
                path = filedialog.asksaveasfilename(defaultextension='.csv', filetypes=[('CSV','*.csv')], initialfile='sign_contracts_report.csv')
                if not path:
                    return
                if df is not None:
                    df.to_csv(path, index=False)
                else:
                    import csv
                    headers = ['ID','Title','Owner','Budget','Owner Signed','My Signature','Status','Action Required']
                    with open(path, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(headers)
                        for r in rows:
                            writer.writerow(list(r))
                messagebox.showinfo("Exported", f"Report exported to {path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export: {e}")

        # Bind buttons
        refresh_btn.config(command=load_contracts)
        sign_btn.config(command=sign_contract)
        view_btn.config(command=view_contract)
        sigs_btn.config(command=view_signatures)
        dl_btn.config(command=download_contract)
        report_btn.config(command=export_report)

        # Context menu
        def show_context_menu(event):
            item = contracts_tree.identify_row(event.y)
            if not item:
                return
            contracts_tree.selection_set(item)
            m = tk.Menu(sign_window, tearoff=0)
            m.add_command(label="Sign Contract", command=sign_contract)
            m.add_command(label="View Contract", command=view_contract)
            m.add_command(label="View Signatures", command=view_signatures)
            m.add_command(label="Download", command=download_contract)
            m.tk_popup(event.x_root, event.y_root)
        contracts_tree.bind('<Button-3>', show_context_menu)

        # Filters
        def on_filter_change(*args):
            load_contracts()
        signature_filter_var.trace_add('write', on_filter_change)
        status_filter_var.trace_add('write', on_filter_change)

        # Shortcuts
        sign_window.bind('<F5>', lambda e: load_contracts())
        sign_window.bind('<Escape>', lambda e: sign_window.destroy())

        # Initial load
        load_contracts()

        # Audit
        try:
            self.log_audit_action(self.current_user['id'], "Sign Contracts", "Opened contractor signing dashboard")
        except Exception:
            pass
        return None

    def show_material_reports(self):
        # Prefer in-class contractor material reports implementation if available
        if hasattr(self, '_impl_show_material_reports'):
            try:
                return self._impl_show_material_reports()
            except Exception:
                pass
        # Fallback to module-level implementation if present
        if 'show_material_reports' in globals() and callable(globals()['show_material_reports']):
            return globals()['show_material_reports'](self)
        # Safe placeholder
        try:
            messagebox.showinfo("Feature", "Material Reports will be implemented here")
        except Exception:
            pass
        return None


    def show_create_worker(self):
        if 'show_create_worker' in globals() and callable(globals()['show_create_worker']):
            return globals()['show_create_worker'](self)
        try:
            messagebox.showinfo("Feature", "Create Worker will be implemented here")
        except Exception:
            pass
        return None

    def show_manage_workers(self):
        if 'show_manage_workers' in globals() and callable(globals()['show_manage_workers']):
            return globals()['show_manage_workers'](self)
        try:
            messagebox.showinfo("Feature", "Manage Workers will be implemented here")
        except Exception:
            pass
        return None

    def show_view_applications(self):
        try:
            win = tk.Toplevel(self.root)
            win.title("View Job Applications")
            win.geometry("1000x620")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="View Job Applications", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filt = tk.LabelFrame(win, text="Filters", bg='white')
            filt.pack(fill='x', padx=10, pady=(0,10))
            tk.Label(filt, text="Job:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            job_var = tk.StringVar()
            job_cb = ttk.Combobox(filt, textvariable=job_var, state='readonly', width=40)
            job_cb.grid(row=0, column=1, sticky='w', padx=5, pady=6)
            tk.Label(filt, text="Status:", bg='white').grid(row=0, column=2, sticky='e', padx=5, pady=6)
            status_var = tk.StringVar(value='All')
            status_cb = ttk.Combobox(filt, textvariable=status_var, state='readonly', width=20)
            status_cb['values'] = ['All','Submitted','Under Review','Interview','Rejected','Hired']
            status_cb.grid(row=0, column=3, sticky='w', padx=5, pady=6)
            tk.Label(filt, text="Applicant contains:", bg='white').grid(row=0, column=4, sticky='e', padx=5, pady=6)
            search_var = tk.StringVar()
            tk.Entry(filt, textvariable=search_var, width=22).grid(row=0, column=5, sticky='w', padx=5, pady=6)
            act = tk.Frame(filt, bg='white')
            act.grid(row=0, column=6, padx=5, pady=6, sticky='w')
            refresh_btn = tk.Button(act, text="Refresh", bg="#3498db", fg="white")
            refresh_btn.pack(side='left')
            export_btn = tk.Button(act, text="Export CSV")
            export_btn.pack(side='left', padx=6)

            # Table
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Job","Applicant","Applied On","Status","Resume","Cover Letter")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=150 if c in ("Job","Applicant") else 120)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Employers see only their jobs; job seekers see their own applications; admin/contract_owner see all; contractor/employer also allowed to see their jobs
            job_map = {"All Jobs": None}
            def load_jobs():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    role = self.current_user['role']
                    if role in ['administrator','contract_owner']:
                        cur.execute("SELECT id, title FROM jobs ORDER BY posted_date DESC")
                        rows = cur.fetchall()
                    elif role in ['employer','contractor']:
                        cur.execute("SELECT id, title FROM jobs WHERE employer_id=? ORDER BY posted_date DESC", (self.current_user['id'],))
                        rows = cur.fetchall()
                    else:
                        # job seekers: load jobs they applied to
                        cur.execute("""
                            SELECT DISTINCT j.id, j.title
                            FROM jobs j JOIN job_applications ja ON ja.job_id=j.id
                            WHERE ja.applicant_id=? ORDER BY j.posted_date DESC
                        """, (self.current_user['id'],))
                        rows = cur.fetchall()
                    values = ["All Jobs"]
                    for jid, title in rows:
                        disp = f"{title} (ID:{jid})"
                        job_map[disp] = jid
                        values.append(disp)
                    job_cb['values'] = values
                    job_cb.set(values[0])
                    conn.close()
                except Exception:
                    job_cb['values'] = ["All Jobs"]
                    job_cb.set("All Jobs")

            def refresh():
                try:
                    jid = job_map.get(job_var.get())
                    st = status_var.get()
                    q = search_var.get().strip()
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    query = (
                        "SELECT ja.id, j.title, u.full_name, ja.application_date, ja.status, ja.resume_path, substr(ja.cover_letter,1,50) "
                        "FROM job_applications ja "
                        "JOIN jobs j ON j.id = ja.job_id "
                        "JOIN users u ON u.id = ja.applicant_id WHERE 1=1 "
                    )
                    params = []
                    role = self.current_user['role']
                    if role == ROLE_JOB_SEEKER:
                        query += "AND ja.applicant_id = ? "
                        params.append(self.current_user['id'])
                    elif role in ['employer','contractor']:
                        query += "AND j.employer_id = ? "
                        params.append(self.current_user['id'])
                    # admin and contract_owner have full visibility
                    if jid:
                        query += "AND ja.job_id = ? "
                        params.append(jid)
                    if st and st != 'All':
                        query += "AND ja.status = ? "
                        params.append(st)
                    if q:
                        query += "AND (u.full_name LIKE ? OR j.title LIKE ?) "
                        like = f"%{q}%"
                        params.extend([like, like])
                    query += "ORDER BY ja.application_date DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to load applications: {str(e)}")
                    except Exception:
                        pass
                    rows = []
                for it in tree.get_children():
                    tree.delete(it)
                for r in rows:
                    tree.insert('', 'end', values=r)
                try:
                    self.log_audit_action(self.current_user['id'], "View Applications (Read-only)", json.dumps({
                        'job': job_var.get(), 'status': status_var.get(), 'q': search_var.get()
                    }))
                except Exception:
                    pass

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"applications_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Applications", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"),("All files","*.*")])
                    if not filename:
                        return
                    jid = job_map.get(job_var.get())
                    st = status_var.get()
                    q = search_var.get().strip()
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    query = (
                        "SELECT ja.id, j.title, u.full_name, ja.application_date, ja.status, ja.resume_path, ja.cover_letter "
                        "FROM job_applications ja "
                        "JOIN jobs j ON j.id = ja.job_id "
                        "JOIN users u ON u.id = ja.applicant_id WHERE 1=1 "
                    )
                    params = []
                    role = self.current_user['role']
                    if role == ROLE_JOB_SEEKER:
                        query += "AND ja.applicant_id = ? "
                        params.append(self.current_user['id'])
                    elif role in ['employer','contractor']:
                        query += "AND j.employer_id = ? "
                        params.append(self.current_user['id'])
                    if jid:
                        query += "AND ja.job_id = ? "
                        params.append(jid)
                    if st and st != 'All':
                        query += "AND ja.status = ? "
                        params.append(st)
                    if q:
                        query += "AND (u.full_name LIKE ? OR j.title LIKE ?) "
                        like = f"%{q}%"
                        params.extend([like, like])
                    query += "ORDER BY ja.application_date DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(["ID","Job","Applicant","Applied On","Status","Resume","Cover Letter"])
                        for r in rows:
                            writer.writerow(r)
                    messagebox.showinfo("Export", "Applications exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            # Wire actions and triggers
            refresh_btn.config(command=refresh)
            export_btn.config(command=export_csv)
            job_var.trace('w', lambda *a: refresh())
            status_var.trace('w', lambda *a: refresh())
            search_var.trace('w', lambda *a: refresh())

            # Context: Double-click to see cover letter
            def on_double(_e=None):
                sel = tree.selection()
                if not sel:
                    return
                try:
                    app_id = tree.item(sel[0], 'values')[0]
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT cover_letter FROM job_applications WHERE id=?", (app_id,))
                    row = cur.fetchone()
                    conn.close()
                    dlg = tk.Toplevel(win)
                    dlg.title("Cover Letter")
                    dlg.geometry("600x400")
                    dlg.configure(bg='white')
                    txt = tk.Text(dlg, wrap='word')
                    txt.pack(fill='both', expand=True)
                    txt.insert('1.0', row[0] if row and row[0] else "No cover letter.")
                    txt.config(state='disabled')
                except Exception:
                    pass
            tree.bind('<Double-1>', on_double)

            # Load
            load_jobs()
            refresh()

            # Shortcuts
            win.bind('<F5>', lambda e: refresh())
            win.bind('<Escape>', lambda e: win.destroy())
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open View Applications: {str(e)}")
            except Exception:
                pass
        return None

#=============== create contract functionality ===================
def show_create_contract(self):
    # Create Contract window
    create_contract_window = tk.Toplevel(self.root)
    create_contract_window.title("Create New Contract")
    create_contract_window.geometry("800x900")
    create_contract_window.configure(bg='#34495e')
    create_contract_window.grab_set()  # Make modal
    create_contract_window.resizable(False, False)

    # Center the window
    create_contract_window.transient(self.root)

    # Main container
    main_frame = tk.Frame(create_contract_window, bg='#34495e', padx=30, pady=20)
    main_frame.pack(fill='both', expand=True)

    # Title
    title_label = tk.Label(main_frame, text="Create New Contract",
                           font=('Arial', 18, 'bold'), bg='#34495e', fg='white')
    title_label.pack(pady=(0, 30))

    # Form frame with scrollbar support
    canvas = tk.Canvas(main_frame, bg='#34495e', highlightthickness=0)
    scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas, bg='#34495e')

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Form entries dictionary
    form_entries = {}

    # Basic Contract Information Section
    basic_section = tk.LabelFrame(scrollable_frame, text="Basic Contract Information",
                                  font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
    basic_section.pack(fill='x', pady=(0, 20), padx=5)

    # Contract Title
    title_frame = tk.Frame(basic_section, bg='#34495e')
    title_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(title_frame, text="Contract Title *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    title_entry = tk.Entry(title_frame, font=('Arial', 11), width=40)
    title_entry.pack(side='left', padx=(10, 0))
    form_entries['title'] = title_entry

    # Contract Type
    type_frame = tk.Frame(basic_section, bg='#34495e')
    type_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(type_frame, text="Contract Type *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    type_var = tk.StringVar()
    type_combo = ttk.Combobox(type_frame, textvariable=type_var,
                              font=('Arial', 11), width=37, state='readonly')
    type_combo['values'] = [
        'Construction Contract',
        'Supply Contract',
        'Service Contract',
        'Maintenance Contract',
        'Renovation Contract',
        'Design Contract',
        'Consultation Contract'
    ]
    type_combo.pack(side='left', padx=(10, 0))
    form_entries['contract_type'] = type_combo

    # Contract Kind (Labour/Materials)
    kind_frame = tk.Frame(basic_section, bg='#34495e')
    kind_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(kind_frame, text="Contract Kind *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    kind_var = tk.StringVar(value='Labour Only')
    kind_combo = ttk.Combobox(kind_frame, textvariable=kind_var,
                              font=('Arial', 11), width=37, state='readonly')
    kind_combo['values'] = ['Labour Only','Labour + Materials']
    kind_combo.pack(side='left', padx=(10, 0))
    form_entries['contract_kind'] = kind_combo

    # Includes Materials
    inc_frame = tk.Frame(basic_section, bg='#34495e')
    inc_frame.pack(fill='x', padx=10, pady=8)
    includes_var = tk.IntVar(value=0)
    inc_cb = tk.Checkbutton(inc_frame, text="Includes Materials", variable=includes_var,
                             bg='#34495e', fg='white', selectcolor='#2c3e50', onvalue=1, offvalue=0)
    inc_cb.pack(side='left')
    form_entries['includes_materials'] = includes_var

    def _sync_inc(*_a):
        try:
            includes_var.set(1 if kind_var.get() == 'Labour + Materials' else 0)
        except Exception:
            pass
    kind_var.trace('w', _sync_inc)
    _sync_inc()

    # Project Category
    category_frame = tk.Frame(basic_section, bg='#34495e')
    category_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(category_frame, text="Project Category *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    category_var = tk.StringVar()
    category_combo = ttk.Combobox(category_frame, textvariable=category_var,
                                  font=('Arial', 11), width=37, state='readonly')
    category_combo['values'] = [
        'Residential Building',
        'Commercial Building',
        'Industrial Building',
        'Road Construction',
        'Bridge Construction',
        'Water Infrastructure',
        'Electrical Infrastructure',
        'Renovation/Repair',
        'Other'
    ]
    category_combo.pack(side='left', padx=(10, 0))
    form_entries['category'] = category_combo

    # Contract Description
    desc_frame = tk.Frame(basic_section, bg='#34495e')
    desc_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(desc_frame, text="Description *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    desc_text = tk.Text(desc_frame, font=('Arial', 11), width=40, height=4)
    desc_text.pack(side='left', padx=(10, 0))
    form_entries['description'] = desc_text

    # Project Details Section
    project_section = tk.LabelFrame(scrollable_frame, text="Project Details",
                                    font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
    project_section.pack(fill='x', pady=(0, 20), padx=5)

    # Project Location
    location_frame = tk.Frame(project_section, bg='#34495e')
    location_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(location_frame, text="Project Location *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    location_entry = tk.Entry(location_frame, font=('Arial', 11), width=40)
    location_entry.pack(side='left', padx=(10, 0))
    form_entries['location'] = location_entry

    # Project Size/Scope
    scope_frame = tk.Frame(project_section, bg='#34495e')
    scope_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(scope_frame, text="Project Scope", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    scope_entry = tk.Entry(scope_frame, font=('Arial', 11), width=40)
    scope_entry.pack(side='left', padx=(10, 0))
    form_entries['scope'] = scope_entry

    # Timeline Section
    timeline_section = tk.LabelFrame(scrollable_frame, text="Project Timeline",
                                     font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
    timeline_section.pack(fill='x', pady=(0, 20), padx=5)

    # Start Date
    start_date_frame = tk.Frame(timeline_section, bg='#34495e')
    start_date_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(start_date_frame, text="Start Date *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    start_date_entry = tk.Entry(start_date_frame, font=('Arial', 11), width=40)
    start_date_entry.insert(0, date.today().strftime('%Y-%m-%d'))
    start_date_entry.pack(side='left', padx=(10, 0))
    form_entries['start_date'] = start_date_entry

    # End Date
    end_date_frame = tk.Frame(timeline_section, bg='#34495e')
    end_date_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(end_date_frame, text="Expected End Date *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    end_date_entry = tk.Entry(end_date_frame, font=('Arial', 11), width=40)
    end_date_entry.pack(side='left', padx=(10, 0))
    form_entries['end_date'] = end_date_entry

    # Duration in Days
    duration_frame = tk.Frame(timeline_section, bg='#34495e')
    duration_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(duration_frame, text="Duration (Days)", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    duration_entry = tk.Entry(duration_frame, font=('Arial', 11), width=40)
    duration_entry.pack(side='left', padx=(10, 0))
    form_entries['duration'] = duration_entry

    # Financial Details Section
    financial_section = tk.LabelFrame(scrollable_frame, text="Financial Details",
                                      font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
    financial_section.pack(fill='x', pady=(0, 20), padx=5)

    # Contract Value/Budget
    budget_frame = tk.Frame(financial_section, bg='#34495e')
    budget_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(budget_frame, text="Contract Value (FCFA) *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    budget_entry = tk.Entry(budget_frame, font=('Arial', 11), width=40)
    budget_entry.pack(side='left', padx=(10, 0))
    form_entries['budget'] = budget_entry

    # Payment Terms
    payment_frame = tk.Frame(financial_section, bg='#34495e')
    payment_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(payment_frame, text="Payment Terms", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    payment_var = tk.StringVar()
    payment_combo = ttk.Combobox(payment_frame, textvariable=payment_var,
                                 font=('Arial', 11), width=37, state='readonly')
    payment_combo['values'] = [
        '100% on completion',
        '50% upfront, 50% on completion',
        '30% upfront, 70% on completion',
        '25% upfront, 25% at 50%, 50% on completion',
        'Monthly installments',
        'Milestone-based payments',
        'Other (specify in notes)'
    ]
    payment_combo.pack(side='left', padx=(10, 0))
    form_entries['payment_terms'] = payment_combo

    # Contractor Assignment Section
    contractor_section = tk.LabelFrame(scrollable_frame, text="Contractor Assignment",
                                       font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
    contractor_section.pack(fill='x', pady=(0, 20), padx=5)

    # Contractor Selection
    contractor_frame = tk.Frame(contractor_section, bg='#34495e')
    contractor_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(contractor_frame, text="Assign Contractor", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    contractor_var = tk.StringVar()
    contractor_combo = ttk.Combobox(contractor_frame, textvariable=contractor_var,
                                    font=('Arial', 11), width=37, state='readonly')

    # Load available contractors (scoped to creator unless admin)
    try:
        conn = self.db_manager.create_connection()
        cursor = conn.cursor()
        q = '''
                       SELECT id, username, full_name
                       FROM users
                       WHERE role = 'contractor'
                         AND is_active = 1
                       '''
        params = []
        try:
            if self.current_user.get('role') != 'administrator':
                q += ' AND created_by = ? '
                params.append(self.current_user['id'])
        except Exception:
            pass
        q += ' ORDER BY full_name'
        cursor.execute(q, params)
        contractors = cursor.fetchall()
        contractor_options = ['Not Assigned'] + [f"{c[0]} - {c[2]} ({c[1]})" for c in contractors]
        contractor_combo['values'] = contractor_options
        contractor_combo.set('Not Assigned')
        conn.close()
    except Exception as e:
        contractor_combo['values'] = ['Not Assigned']
        contractor_combo.set('Not Assigned')

    contractor_combo.pack(side='left', padx=(10, 0))
    form_entries['contractor'] = contractor_combo

    # Contract Status
    status_frame = tk.Frame(contractor_section, bg='#34495e')
    status_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(status_frame, text="Initial Status *", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    status_var = tk.StringVar(value='Draft')
    status_combo = ttk.Combobox(status_frame, textvariable=status_var,
                                font=('Arial', 11), width=37, state='readonly')
    status_combo['values'] = ['Draft', 'Pending Review', 'Active', 'On Hold']
    status_combo.pack(side='left', padx=(10, 0))
    form_entries['status'] = status_combo

    # Additional Information Section
    additional_section = tk.LabelFrame(scrollable_frame, text="Additional Information",
                                       font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
    additional_section.pack(fill='x', pady=(0, 20), padx=5)

    # Requirements/Specifications
    requirements_frame = tk.Frame(additional_section, bg='#34495e')
    requirements_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(requirements_frame, text="Requirements", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    requirements_text = tk.Text(requirements_frame, font=('Arial', 11), width=40, height=3)
    requirements_text.pack(side='left', padx=(10, 0))
    form_entries['requirements'] = requirements_text

    # Special Conditions
    conditions_frame = tk.Frame(additional_section, bg='#34495e')
    conditions_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(conditions_frame, text="Special Conditions", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    conditions_text = tk.Text(conditions_frame, font=('Arial', 11), width=40, height=3)
    conditions_text.pack(side='left', padx=(10, 0))
    form_entries['conditions'] = conditions_text

    # Notes
    notes_frame = tk.Frame(additional_section, bg='#34495e')
    notes_frame.pack(fill='x', padx=10, pady=8)
    tk.Label(notes_frame, text="Notes", font=('Arial', 11),
             bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
    notes_text = tk.Text(notes_frame, font=('Arial', 11), width=40, height=2)
    notes_text.pack(side='left', padx=(10, 0))
    form_entries['notes'] = notes_text

    # Pack canvas and scrollbar
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # Validation functions
    def validate_date(date_str):
        if not date_str:
            return False, "Date is required"
        try:
            from datetime import datetime as dt
            dt.strptime(date_str, '%Y-%m-%d')
            return True, "Valid"
        except ValueError:
            return False, "Please use YYYY-MM-DD format"

    def validate_budget(budget_str):
        if not budget_str:
            return False, "Budget is required"
        try:
            budget = float(budget_str.replace(',', ''))
            if budget <= 0:
                return False, "Budget must be greater than zero"
            return True, "Valid"
        except ValueError:
            return False, "Please enter a valid number"

    # Create contract function
    def create_new_contract():
        try:
            # Get all form data
            form_data = {}

            # Get text entries
            text_fields = ['title', 'location', 'scope', 'start_date', 'end_date', 'duration', 'budget']
            for field in text_fields:
                widget = form_entries[field]
                form_data[field] = widget.get().strip()

            # Get combo boxes
            combo_fields = ['contract_type', 'category', 'payment_terms', 'contractor', 'status', 'contract_kind']
            for field in combo_fields:
                form_data[field] = form_entries[field].get()

            # Get text widgets
            text_widget_fields = ['description', 'requirements', 'conditions', 'notes']
            for field in text_widget_fields:
                widget = form_entries[field]
                form_data[field] = widget.get('1.0', 'end-1c').strip()

            # Includes materials (checkbox)
            includes_val = 1 if form_entries['includes_materials'].get() else 0

            # Validation
            errors = []

            # Required fields
            required_fields = ['title', 'contract_type', 'category', 'description', 'location', 'start_date',
                               'end_date', 'budget', 'contract_kind']
            for field in required_fields:
                if not form_data.get(field):
                    field_display = field.replace('_', ' ').title()
                    errors.append(f"{field_display} is required")

            # If contract kind implies materials, enforce includes flag
            if form_data.get('contract_kind') == 'Labour + Materials':
                includes_val = 1

            # Date validation
            if form_data.get('start_date'):
                is_valid, message = validate_date(form_data['start_date'])
                if not is_valid:
                    errors.append(f"Start date: {message}")

            if form_data.get('end_date'):
                is_valid, message = validate_date(form_data['end_date'])
                if not is_valid:
                    errors.append(f"End date: {message}")

            # Date logic validation
            if form_data.get('start_date') and form_data.get('end_date'):
                try:
                    from datetime import datetime as dt
                    start_dt = dt.strptime(form_data['start_date'], '%Y-%m-%d')
                    end_dt = dt.strptime(form_data['end_date'], '%Y-%m-%d')
                    if end_dt <= start_dt:
                        errors.append("End date must be after start date")
                except:
                    pass

            # Budget validation
            if form_data.get('budget'):
                is_valid, message = validate_budget(form_data['budget'])
                if not is_valid:
                    errors.append(f"Budget: {message}")

            # Show validation errors
            if errors:
                error_message = "Please fix the following errors:\n\n" + "\n".join(f"• {error}" for error in errors)
                messagebox.showerror("Validation Error", error_message)
                return

            # Parse contractor ID if assigned
            contractor_id = None
            if form_data['contractor'] != 'Not Assigned' and form_data['contractor']:
                contractor_id = int(form_data['contractor'].split(' - ')[0])

            # Parse budget
            budget_value = float(form_data['budget'].replace(',', ''))

            # Database operations
            conn = self.db_manager.create_connection()
            cursor = conn.cursor()

            # Insert new contract
            cursor.execute('''
                           INSERT INTO contracts (title, description, contract_owner_id, contractor_id,
                                                  start_date, end_date, budget, status, created_date,
                                                  contract_kind, includes_materials)
                           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                           ''', (
                               form_data['title'],
                               form_data['description'],
                               self.current_user['id'],
                               contractor_id,
                               form_data['start_date'],
                               form_data['end_date'],
                               budget_value,
                               form_data['status'],
                               date.today(),
                               form_data['contract_kind'] or 'Labour Only',
                               includes_val
                           ))

            contract_id = cursor.lastrowid

            # Store additional contract details in a separate table or as JSON in a field
            # For now, we'll log them in the audit trail
            additional_details = {
                'contract_type': form_data['contract_type'],
                'contract_kind': form_data['contract_kind'],
                'includes_materials': bool(includes_val),
                'category': form_data['category'],
                'location': form_data['location'],
                'scope': form_data['scope'],
                'duration': form_data['duration'],
                'payment_terms': form_data['payment_terms'],
                'requirements': form_data['requirements'],
                'conditions': form_data['conditions'],
                'notes': form_data['notes']
            }

            conn.commit()
            conn.close()

            # Log the action
            self.log_audit_action(
                self.current_user['id'],
                "Create Contract",
                f"Created new contract: {form_data['title']} (ID: {contract_id}) - Budget: {budget_value:,.0f} FCFA"
            )

            # Show success message
            contractor_name = "Not Assigned"
            if contractor_id:
                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('SELECT full_name FROM users WHERE id = ?', (contractor_id,))
                    result = cursor.fetchone()
                    if result:
                        contractor_name = result[0]
                    conn.close()
                except:
                    pass

            success_message = (
                f"Contract created successfully!\n\n"
                f"Contract ID: {contract_id}\n"
                f"Title: {form_data['title']}\n"
                f"Type: {form_data['contract_type']}\n"
                f"Category: {form_data['category']}\n"
                f"Budget: {budget_value:,.0f} FCFA\n"
                f"Duration: {form_data['start_date']} to {form_data['end_date']}\n"
                f"Contractor: {contractor_name}\n"
                f"Status: {form_data['status']}"
            )

            messagebox.showinfo("Success", success_message)

            # Ask if user wants to add materials/requirements
            if messagebox.askyesno("Additional Setup",
                                   "Would you like to add material requirements for this contract?"):
                create_contract_window.destroy()
                # You can implement material requirements setup here
                messagebox.showinfo("Info", "Material requirements setup will be available in contract management.")
            else:
                create_contract_window.destroy()

        except ValueError as e:
            messagebox.showerror("Error", "Please check contractor selection format")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to create contract: {str(e)}")

    # Clear form function
    def clear_form():
        for field_name, widget in form_entries.items():
            if hasattr(widget, 'delete'):
                if isinstance(widget, tk.Text):
                    widget.delete('1.0', 'end')
                else:
                    widget.delete(0, 'end')
                    # Reset default values
                    if field_name == 'start_date':
                        widget.insert(0, date.today().strftime('%Y-%m-%d'))
            elif hasattr(widget, 'set'):
                if field_name == 'status':
                    widget.set('Draft')
                elif field_name == 'contractor':
                    widget.set('Not Assigned')
                else:
                    widget.set('')

    # Button frame
    button_frame = tk.Frame(main_frame, bg='#34495e')
    button_frame.pack(fill='x', pady=(20, 0))

    # Buttons
    tk.Button(button_frame, text="Create Contract", font=('Arial', 12, 'bold'),
              bg='#27ae60', fg='white', width=15, height=2,
              command=create_new_contract).pack(side='left', padx=(0, 10))

    tk.Button(button_frame, text="Clear Form", font=('Arial', 12),
              bg='#f39c12', fg='white', width=15, height=2,
              command=clear_form).pack(side='left', padx=(0, 10))

    tk.Button(button_frame, text="Cancel", font=('Arial', 12),
              bg='#e74c3c', fg='white', width=15, height=2,
              command=create_contract_window.destroy).pack(side='right')

    # Help frame
    help_frame = tk.Frame(main_frame, bg='#34495e')
    help_frame.pack(fill='x', pady=(10, 0))

    help_text = (
        "Tips for creating a contract:\n"
        "• Fields marked with * are required\n"
        "• Use YYYY-MM-DD format for dates (e.g., 2024-12-31)\n"
        "• Budget should be in FCFA (Francs CFA)\n"
        "• You can assign a contractor now or leave it for later assignment\n"
        "• Draft contracts can be modified before finalizing"
    )

    tk.Label(help_frame, text=help_text, font=('Arial', 9),
             bg='#34495e', fg='#bdc3c7', justify='left').pack(anchor='w')

    # Set focus to first field
    form_entries['title'].focus()

    # Keyboard shortcuts
    create_contract_window.bind('<Escape>', lambda e: create_contract_window.destroy())

    # Calculate duration when dates change
    def calculate_duration(*args):
        try:
            start_date_str = form_entries['start_date'].get()
            end_date_str = form_entries['end_date'].get()

            if start_date_str and end_date_str:
                from datetime import datetime as dt
                start_dt = dt.strptime(start_date_str, '%Y-%m-%d')
                end_dt = dt.strptime(end_date_str, '%Y-%m-%d')
                duration = (end_dt - start_dt).days

                if duration > 0:
                    form_entries['duration'].delete(0, 'end')
                    form_entries['duration'].insert(0, str(duration))
        except:
            pass

    # Bind date fields to auto-calculate duration
    form_entries['start_date'].bind('<FocusOut>', calculate_duration)
    form_entries['end_date'].bind('<FocusOut>', calculate_duration)

#======================= Manage Contracts functions =======================
    def show_manage_contracts(self):
        # Bind implementation to instance so class wrapper can reuse it
        try:
            self._impl_show_manage_contracts = show_manage_contracts
        except Exception:
            pass
        # Manage Contracts window
        manage_window = tk.Toplevel(self.root)
        manage_window.title("Manage Contracts")
        manage_window.geometry("1400x800")
        manage_window.configure(bg='white')
        manage_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(manage_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="Contract Management", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Search and filter frame
        search_frame = tk.Frame(header_frame, bg='white')
        search_frame.pack(side='right')

        # Search entry
        tk.Label(search_frame, text="Search:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        search_var = tk.StringVar()
        search_entry = tk.Entry(search_frame, textvariable=search_var, font=('Arial', 10), width=20)
        search_entry.pack(side='left', padx=(0, 10))

        # Status filter
        tk.Label(search_frame, text="Status:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        status_filter_var = tk.StringVar()
        status_filter = ttk.Combobox(search_frame, textvariable=status_filter_var, width=12, state='readonly')
        status_filter['values'] = ['All', 'Draft', 'Pending Review', 'Active', 'Completed', 'On Hold', 'Cancelled']
        status_filter.set('All')
        status_filter.pack(side='left', padx=(0, 10))

        # Date filter
        tk.Label(search_frame, text="Period:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        date_filter_var = tk.StringVar()
        date_filter = ttk.Combobox(search_frame, textvariable=date_filter_var, width=12, state='readonly')
        date_filter['values'] = ['All Time', 'This Year', 'Last 6 Months', 'Last 3 Months', 'This Month']
        date_filter.set('All Time')
        date_filter.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(search_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left')

        # Statistics frame
        stats_frame = tk.Frame(main_frame, bg='#ecf0f1', relief='raised', bd=1)
        stats_frame.pack(fill='x', pady=(0, 10))

        stats_inner = tk.Frame(stats_frame, bg='#ecf0f1')
        stats_inner.pack(pady=10)

        # Statistics labels (will be updated by load_contracts)
        total_contracts_label = tk.Label(stats_inner, text="Total: 0", font=('Arial', 10, 'bold'),
                                         bg='#ecf0f1', fg='#2c3e50')
        total_contracts_label.pack(side='left', padx=20)

        active_contracts_label = tk.Label(stats_inner, text="Active: 0", font=('Arial', 10, 'bold'),
                                          bg='#ecf0f1', fg='#27ae60')
        active_contracts_label.pack(side='left', padx=20)

        total_value_label = tk.Label(stats_inner, text="Total Value: 0 FCFA", font=('Arial', 10, 'bold'),
                                     bg='#ecf0f1', fg='#e67e22')
        total_value_label.pack(side='left', padx=20)

        pending_label = tk.Label(stats_inner, text="Pending: 0", font=('Arial', 10, 'bold'),
                                 bg='#ecf0f1', fg='#f39c12')
        pending_label.pack(side='left', padx=20)

        # Contracts treeview frame
        tree_frame = tk.Frame(main_frame, bg='white')
        tree_frame.pack(fill='both', expand=True, pady=(0, 20))

        # Treeview with scrollbars
        tree_scroll_y = ttk.Scrollbar(tree_frame)
        tree_scroll_y.pack(side='right', fill='y')

        tree_scroll_x = ttk.Scrollbar(tree_frame, orient='horizontal')
        tree_scroll_x.pack(side='bottom', fill='x')

        contracts_tree = ttk.Treeview(tree_frame,
                                      columns=('ID', 'Title', 'Contractor', 'Budget', 'Start Date', 'End Date',
                                               'Status', 'Progress'),
                                      show='headings',
                                      yscrollcommand=tree_scroll_y.set,
                                      xscrollcommand=tree_scroll_x.set)
        contracts_tree.pack(fill='both', expand=True)

        tree_scroll_y.config(command=contracts_tree.yview)
        tree_scroll_x.config(command=contracts_tree.xview)

        # Configure columns
        columns_config = [
            ('ID', 60, 'center'),
            ('Title', 200, 'w'),
            ('Contractor', 150, 'w'),
            ('Budget', 120, 'e'),
            ('Start Date', 100, 'center'),
            ('End Date', 100, 'center'),
            ('Status', 100, 'center'),
            ('Progress', 80, 'center')
        ]

        for col, width, anchor in columns_config:
            contracts_tree.heading(col, text=col)
            contracts_tree.column(col, width=width, anchor=anchor)

        # Configure row colors based on status
        contracts_tree.tag_configure('active', background='#d5f4e6')
        contracts_tree.tag_configure('draft', background='#fff3cd')
        contracts_tree.tag_configure('completed', background='#d1ecf1')
        contracts_tree.tag_configure('on_hold', background='#f8d7da')
        contracts_tree.tag_configure('cancelled', background='#f5c6cb')
        contracts_tree.tag_configure('overdue', background='#ffebee', foreground='#d32f2f')

        # Action buttons frame
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(0, 10))

        # Left side buttons (contract actions)
        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')

        new_btn = tk.Button(left_buttons, text="New Contract", font=('Arial', 10, 'bold'),
                            bg='#27ae60', fg='white', width=12)
        new_btn.pack(side='left', padx=(0, 5))

        edit_btn = tk.Button(left_buttons, text="Edit", font=('Arial', 10, 'bold'),
                             bg='#3498db', fg='white', width=10)
        edit_btn.pack(side='left', padx=(0, 5))

        view_btn = tk.Button(left_buttons, text="View Details", font=('Arial', 10, 'bold'),
                             bg='#17a2b8', fg='white', width=12)
        view_btn.pack(side='left', padx=(0, 5))

        duplicate_btn = tk.Button(left_buttons, text="Duplicate", font=('Arial', 10),
                                  bg='#6c757d', fg='white', width=10)
        duplicate_btn.pack(side='left', padx=(0, 5))

        status_btn = tk.Button(left_buttons, text="Change Status", font=('Arial', 10),
                               bg='#fd7e14', fg='white', width=12)
        status_btn.pack(side='left', padx=(0, 5))

        delete_btn = tk.Button(left_buttons, text="Delete", font=('Arial', 10, 'bold'),
                               bg='#dc3545', fg='white', width=10)
        delete_btn.pack(side='left', padx=(0, 5))

        # Right side buttons (reports and export)
        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')

        export_btn = tk.Button(right_buttons, text="Export", font=('Arial', 10),
                               bg='#28a745', fg='white', width=10)
        export_btn.pack(side='left', padx=(0, 5))

        report_btn = tk.Button(right_buttons, text="Generate Report", font=('Arial', 10),
                               bg='#6f42c1', fg='white', width=12)
        report_btn.pack(side='left', padx=(0, 5))

        print_btn = tk.Button(right_buttons, text="Print PDF", font=('Arial', 10),
                              bg='#17a2b8', fg='white', width=10)
        print_btn.pack(side='left', padx=(0,5))

        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10),
                              bg='#6c757d', fg='white', width=10,
                              command=manage_window.destroy)
        close_btn.pack(side='left')

        # Load and display contracts function
        def load_contracts():
            # Clear existing items
            for item in contracts_tree.get_children():
                contracts_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Build query based on filters
                search_text = search_var.get().strip()
                status_filter_text = status_filter_var.get()
                date_filter_text = date_filter_var.get()

                query = '''
                        SELECT c.id,
                               c.title,
                               COALESCE(u.full_name, 'Not Assigned') as contractor_name,
                               c.budget,
                               c.start_date,
                               c.end_date,
                               c.status,
                               c.created_date,
                               c.description
                        FROM contracts c
                                 LEFT JOIN users u ON c.contractor_id = u.id
                        WHERE c.contract_owner_id = ?
                        '''
                params = [self.current_user['id']]

                # Apply search filter
                if search_text:
                    query += ' AND (c.title LIKE ? OR c.description LIKE ? OR u.full_name LIKE ?)'
                    search_pattern = f'%{search_text}%'
                    params.extend([search_pattern, search_pattern, search_pattern])

                # Apply status filter
                if status_filter_text and status_filter_text != 'All':
                    query += ' AND c.status = ?'
                    params.append(status_filter_text)

                # Apply date filter
                if date_filter_text == 'This Year':
                    query += ' AND strftime("%Y", c.created_date) = strftime("%Y", "now")'
                elif date_filter_text == 'Last 6 Months':
                    query += ' AND c.created_date >= date("now", "-6 months")'
                elif date_filter_text == 'Last 3 Months':
                    query += ' AND c.created_date >= date("now", "-3 months")'
                elif date_filter_text == 'This Month':
                    query += ' AND strftime("%Y-%m", c.created_date) = strftime("%Y-%m", "now")'

                query += ' ORDER BY c.created_date DESC'

                cursor.execute(query, params)
                contracts = cursor.fetchall()

                # Statistics
                total_count = len(contracts)
                active_count = sum(1 for c in contracts if c[6] == 'Active')
                total_value = sum(c[3] or 0 for c in contracts)
                pending_count = sum(1 for c in contracts if c[6] in ['Draft', 'Pending Review'])

                # Insert contracts into tree
                from datetime import datetime as dt, date as dt_date
                today = dt_date.today()

                for contract in contracts:
                    contract_id, title, contractor, budget, start_date, end_date, status, created_date, description = contract

                    # Calculate progress (simple estimation based on dates)
                    progress = "N/A"
                    tags = []

                    # Determine row styling
                    status_lower = status.lower().replace(' ', '_')
                    if status_lower in ['active', 'draft', 'completed', 'on_hold', 'cancelled']:
                        tags.append(status_lower)

                    # Check if overdue
                    if end_date and status == 'Active':
                        try:
                            end_dt = dt.strptime(end_date, '%Y-%m-%d').date()
                            if today > end_dt:
                                tags.append('overdue')
                                progress = "OVERDUE"
                            elif start_date:
                                start_dt = dt.strptime(start_date, '%Y-%m-%d').date()
                                total_days = (end_dt - start_dt).days
                                elapsed_days = (today - start_dt).days
                                if total_days > 0:
                                    progress_pct = min(100, max(0, (elapsed_days / total_days) * 100))
                                    progress = f"{progress_pct:.0f}%"
                        except:
                            pass

                    # Format budget
                    budget_display = f"{budget:,.0f}" if budget else "0"

                    contracts_tree.insert('', 'end', values=(
                        contract_id,
                        title[:50] + '...' if len(title) > 50 else title,
                        contractor,
                        budget_display,
                        start_date or 'N/A',
                        end_date or 'N/A',
                        status,
                        progress
                    ), tags=tags)

                # Update statistics
                total_contracts_label.config(text=f"Total: {total_count}")
                active_contracts_label.config(text=f"Active: {active_count}")
                total_value_label.config(text=f"Total Value: {total_value:,.0f} FCFA")
                pending_label.config(text=f"Pending: {pending_count}")

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contracts: {str(e)}")

        # New contract function
        def new_contract():
            manage_window.destroy()
            self.show_create_contract()

        # Edit contract function
        def edit_contract():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to edit")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]
            edit_contract_window(contract_id)

        def edit_contract_window(contract_id):
            # Load contract data
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT title, description, contractor_id, start_date, end_date, budget, status
                               FROM contracts
                               WHERE id = ?
                                 AND contract_owner_id = ?
                               ''', (contract_id, self.current_user['id']))
                contract_data = cursor.fetchone()
                conn.close()

                if not contract_data:
                    messagebox.showerror("Error", "Contract not found or access denied")
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contract: {str(e)}")
                return

            # Create edit window
            edit_window = tk.Toplevel(manage_window)
            edit_window.title(f"Edit Contract - {contract_data[0]}")
            edit_window.geometry("600x500")
            edit_window.configure(bg='#34495e')
            edit_window.grab_set()
            edit_window.transient(manage_window)

            # Edit form
            form_frame = tk.Frame(edit_window, bg='#34495e', padx=30, pady=30)
            form_frame.pack(fill='both', expand=True)

            tk.Label(form_frame, text=f"Edit Contract (ID: {contract_id})",
                     font=('Arial', 16, 'bold'), bg='#34495e', fg='white').pack(pady=(0, 20))

            # Form fields
            edit_entries = {}

            # Title
            tk.Label(form_frame, text="Title:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))
            title_entry = tk.Entry(form_frame, font=('Arial', 11), width=50)
            title_entry.insert(0, contract_data[0])
            title_entry.pack(pady=(0, 10))
            edit_entries['title'] = title_entry

            # Description
            tk.Label(form_frame, text="Description:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))
            desc_text = tk.Text(form_frame, font=('Arial', 11), width=50, height=4)
            desc_text.insert('1.0', contract_data[1])
            desc_text.pack(pady=(0, 10))
            edit_entries['description'] = desc_text

            # Contractor
            tk.Label(form_frame, text="Contractor:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))
            contractor_var = tk.StringVar()
            contractor_combo = ttk.Combobox(form_frame, textvariable=contractor_var, width=47, state='readonly')

            # Load contractors
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                # Load contractors (scoped to creator unless admin)
                q = (
                    "SELECT id, username, full_name FROM users "
                    "WHERE role = 'contractor' AND is_active = 1 "
                )
                params = []
                try:
                    if self.current_user.get('role') != 'administrator':
                        q += "AND created_by = ? "
                        params.append(self.current_user['id'])
                except Exception:
                    pass
                q += "ORDER BY full_name"
                cursor.execute(q, params)
                contractors = cursor.fetchall()
                contractor_options = ['Not Assigned'] + [f"{c[0]} - {c[2]} ({c[1]})" for c in contractors]
                contractor_combo['values'] = contractor_options

                # Set current contractor
                if contract_data[2]:
                    cursor.execute('SELECT full_name, username FROM users WHERE id = ?', (contract_data[2],))
                    current_contractor = cursor.fetchone()
                    if current_contractor:
                        contractor_combo.set(f"{contract_data[2]} - {current_contractor[0]} ({current_contractor[1]})")
                    else:
                        contractor_combo.set('Not Assigned')
                else:
                    contractor_combo.set('Not Assigned')

                conn.close()
            except:
                contractor_combo['values'] = ['Not Assigned']
                contractor_combo.set('Not Assigned')

            contractor_combo.pack(pady=(0, 10))
            edit_entries['contractor'] = contractor_combo

            # Dates and Budget in a frame
            details_frame = tk.Frame(form_frame, bg='#34495e')
            details_frame.pack(fill='x', pady=10)

            # Start Date
            tk.Label(details_frame, text="Start Date:", font=('Arial', 11),
                     bg='#34495e', fg='white').grid(row=0, column=0, sticky='w', padx=(0, 10))
            start_date_entry = tk.Entry(details_frame, font=('Arial', 11), width=15)
            start_date_entry.insert(0, contract_data[3] or '')
            start_date_entry.grid(row=0, column=1, padx=(0, 20))
            edit_entries['start_date'] = start_date_entry

            # End Date
            tk.Label(details_frame, text="End Date:", font=('Arial', 11),
                     bg='#34495e', fg='white').grid(row=0, column=2, sticky='w', padx=(0, 10))
            end_date_entry = tk.Entry(details_frame, font=('Arial', 11), width=15)
            end_date_entry.insert(0, contract_data[4] or '')
            end_date_entry.grid(row=0, column=3)
            edit_entries['end_date'] = end_date_entry

            # Budget
            tk.Label(details_frame, text="Budget (FCFA):", font=('Arial', 11),
                     bg='#34495e', fg='white').grid(row=1, column=0, sticky='w', pady=(10, 0))
            budget_entry = tk.Entry(details_frame, font=('Arial', 11), width=20)
            budget_entry.insert(0, str(contract_data[5]) if contract_data[5] else '')
            budget_entry.grid(row=1, column=1, pady=(10, 0))
            edit_entries['budget'] = budget_entry

            # Status
            tk.Label(details_frame, text="Status:", font=('Arial', 11),
                     bg='#34495e', fg='white').grid(row=1, column=2, sticky='w', padx=(0, 10), pady=(10, 0))
            status_var = tk.StringVar(value=contract_data[6])
            status_combo = ttk.Combobox(details_frame, textvariable=status_var, width=12, state='readonly')
            status_combo['values'] = ['Draft', 'Pending Review', 'Active', 'On Hold', 'Completed', 'Cancelled']
            status_combo.grid(row=1, column=3, pady=(10, 0))
            edit_entries['status'] = status_combo

            def save_changes():
                try:
                    # Get contractor ID
                    contractor_id = None
                    contractor_selection = edit_entries['contractor'].get()
                    if contractor_selection != 'Not Assigned' and contractor_selection:
                        contractor_id = int(contractor_selection.split(' - ')[0])

                    # Get budget
                    budget_value = None
                    if edit_entries['budget'].get():
                        budget_value = float(edit_entries['budget'].get().replace(',', ''))

                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    cursor.execute('''
                                   UPDATE contracts
                                   SET title         = ?,
                                       description   = ?,
                                       contractor_id = ?,
                                       start_date    = ?,
                                       end_date      = ?,
                                       budget        = ?,
                                       status        = ?
                                   WHERE id = ?
                                     AND contract_owner_id = ?
                                   ''', (
                                       edit_entries['title'].get(),
                                       edit_entries['description'].get('1.0', 'end-1c'),
                                       contractor_id,
                                       edit_entries['start_date'].get() or None,
                                       edit_entries['end_date'].get() or None,
                                       budget_value,
                                       edit_entries['status'].get(),
                                       contract_id,
                                       self.current_user['id']
                                   ))

                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        "Edit Contract",
                        f"Modified contract {edit_entries['title'].get()} (ID: {contract_id})"
                    )

                    messagebox.showinfo("Success", "Contract updated successfully!")
                    edit_window.destroy()
                    load_contracts()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to update contract: {str(e)}")

            # Buttons
            btn_frame = tk.Frame(form_frame, bg='#34495e')
            btn_frame.pack(pady=(20, 0))

            tk.Button(btn_frame, text="Save Changes", font=('Arial', 11, 'bold'),
                      bg='#27ae60', fg='white', width=15,
                      command=save_changes).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Cancel", font=('Arial', 11),
                      bg='#e74c3c', fg='white', width=15,
                      command=edit_window.destroy).pack(side='left')

        # View contract details function
        def view_contract():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to view")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]

            # Create view window
            view_window = tk.Toplevel(manage_window)
            view_window.title("Contract Details")
            view_window.geometry("700x600")
            view_window.configure(bg='#f8f9fa')
            view_window.grab_set()
            view_window.transient(manage_window)

            # Load contract details
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT c.title,
                                      c.description,
                                      c.start_date,
                                      c.end_date,
                                      c.budget,
                                      c.status,
                                      c.created_date,
                                      COALESCE(u.full_name, 'Not Assigned') as contractor_name,
                                      COALESCE(u.email, '')                 as contractor_email,
                                      COALESCE(u.phone, '')                 as contractor_phone
                               FROM contracts c
                                        LEFT JOIN users u ON c.contractor_id = u.id
                               WHERE c.id = ?
                                 AND c.contract_owner_id = ?
                               ''', (contract_id, self.current_user['id']))

                contract_info = cursor.fetchone()
                conn.close()

                if not contract_info:
                    messagebox.showerror("Error", "Contract not found")
                    view_window.destroy()
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contract details: {str(e)}")
                view_window.destroy()
                return

            # Display contract information
            main_frame = tk.Frame(view_window, bg='#f8f9fa', padx=30, pady=20)
            main_frame.pack(fill='both', expand=True)

            # Title
            tk.Label(main_frame, text=f"Contract Details - ID: {contract_id}",
                     font=('Arial', 18, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))

            # Contract information
            info_frame = tk.Frame(main_frame, bg='white', relief='raised', bd=1, padx=20, pady=20)
            info_frame.pack(fill='both', expand=True, pady=(0, 20))

            contract_details = [
                ("Contract Title:", contract_info[0]),
                ("Status:", contract_info[5]),
                ("Budget:", f"{contract_info[4]:,.0f} FCFA" if contract_info[4] else "Not specified"),
                ("Start Date:", contract_info[2] or "Not specified"),
                ("End Date:", contract_info[3] or "Not specified"),
                ("Created Date:", contract_info[6]),
                ("Contractor:", contract_info[7]),
                ("Contractor Email:", contract_info[8] or "N/A"),
                ("Contractor Phone:", contract_info[9] or "N/A")
            ]

            for i, (label_text, value) in enumerate(contract_details):
                detail_frame = tk.Frame(info_frame, bg='white')
                detail_frame.pack(fill='x', pady=3)

                tk.Label(detail_frame, text=label_text, font=('Arial', 11, 'bold'),
                         bg='white', fg='#2c3e50', width=20, anchor='w').pack(side='left')

                tk.Label(detail_frame, text=str(value), font=('Arial', 11),
                         bg='white', fg='#34495e', wraplength=400, justify='left').pack(side='left', padx=(10, 0))

            # Description
            tk.Label(info_frame, text="Description:", font=('Arial', 11, 'bold'),
                     bg='white', fg='#2c3e50').pack(anchor='w', pady=(20, 5))

            desc_text = tk.Text(info_frame, height=6, width=60, font=('Arial', 10),
                                wrap='word', state='normal', bg='#f8f9fa')
            desc_text.pack(fill='both', expand=True, pady=(0, 10))
            desc_text.insert('1.0', contract_info[1] or "No description provided")
            desc_text.config(state='disabled')

            # Close button
            tk.Button(main_frame, text="Close", font=('Arial', 11, 'bold'),
                      bg='#6c757d', fg='white', width=15,
                      command=view_window.destroy).pack(pady=10)

        # Change status function
        def change_status():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to change status")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]
            current_status = contracts_tree.item(selected[0])['values'][6]

            # Status change dialog
            status_window = tk.Toplevel(manage_window)
            status_window.title("Change Contract Status")
            status_window.geometry("400x250")
            status_window.configure(bg='#34495e')
            status_window.grab_set()
            status_window.transient(manage_window)

            frame = tk.Frame(status_window, bg='#34495e', padx=30, pady=30)
            frame.pack(fill='both', expand=True)

            tk.Label(frame, text=f"Change Status for Contract ID: {contract_id}",
                     font=('Arial', 12, 'bold'), bg='#34495e', fg='white').pack(pady=(0, 10))

            tk.Label(frame, text=f"Current Status: {current_status}",
                     font=('Arial', 10), bg='#34495e', fg='#ecf0f1').pack(pady=(0, 20))

            tk.Label(frame, text="New Status:", font=('Arial', 11),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            status_var = tk.StringVar(value=current_status)
            status_combo = ttk.Combobox(frame, textvariable=status_var, width=30, state='readonly')
            status_combo['values'] = ['Draft', 'Pending Review', 'Active', 'On Hold', 'Completed', 'Cancelled']
            status_combo.pack(pady=(0, 20))

            def update_status():
                new_status = status_var.get()
                if new_status == current_status:
                    messagebox.showinfo("Info", "Status unchanged")
                    status_window.destroy()
                    return

                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('UPDATE contracts SET status = ? WHERE id = ? AND contract_owner_id = ?',
                                   (new_status, contract_id, self.current_user['id']))
                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        "Change Contract Status",
                        f"Changed contract {contract_id} status from {current_status} to {new_status}"
                    )

                    messagebox.showinfo("Success", f"Contract status updated to: {new_status}")
                    status_window.destroy()
                    load_contracts()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to update status: {str(e)}")

            tk.Button(frame, text="Update Status", font=('Arial', 11, 'bold'),
                      bg='#27ae60', fg='white', width=15,
                      command=update_status).pack(side='left', padx=(0, 10))

            tk.Button(frame, text="Cancel", font=('Arial', 11),
                      bg='#e74c3c', fg='white', width=15,
                      command=status_window.destroy).pack(side='left')

        # Delete contract function
        def delete_contract():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to delete")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]
            contract_title = contracts_tree.item(selected[0])['values'][1]

            if messagebox.askyesno("Confirm Delete",
                                   f"Are you sure you want to delete contract:\n'{contract_title}' (ID: {contract_id})\n\n"
                                   f"This action cannot be undone!"):
                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('DELETE FROM contracts WHERE id = ? AND contract_owner_id = ?',
                                   (contract_id, self.current_user['id']))
                    conn.commit()
                    conn.close()

                    self.log_audit_action(
                        self.current_user['id'],
                        "Delete Contract",
                        f"Deleted contract '{contract_title}' (ID: {contract_id})"
                    )

                    messagebox.showinfo("Success", "Contract deleted successfully")
                    load_contracts()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to delete contract: {str(e)}")

        # Export function
        def export_contracts():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".csv",
                    filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                    title="Export Contracts"
                )

                if filename:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('''
                                   SELECT c.id,
                                          c.title,
                                          c.description,
                                          COALESCE(u.full_name, 'Not Assigned'),
                                          c.budget,
                                          c.start_date,
                                          c.end_date,
                                          c.status,
                                          c.created_date
                                   FROM contracts c
                                            LEFT JOIN users u ON c.contractor_id = u.id
                                   WHERE c.contract_owner_id = ?
                                   ORDER BY c.created_date DESC
                                   ''', (self.current_user['id'],))

                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerow(
                            ['ID', 'Title', 'Description', 'Contractor', 'Budget', 'Start Date', 'End Date', 'Status',
                             'Created Date'])
                        writer.writerows(cursor.fetchall())

                    conn.close()
                    messagebox.showinfo("Success", f"Contracts exported to {filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to export contracts: {str(e)}")

        # Print to PDF function
        def print_contract_pdf():
            try:
                selected = contracts_tree.selection()
                if not selected:
                    messagebox.showwarning("Warning", "Please select a contract to print")
                    return
                contract_id = contracts_tree.item(selected[0])['values'][0]

                # Load the full contract details
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                cur.execute(
                    '''
                    SELECT c.id, c.title, c.description, c.requirements, c.budget,
                           c.start_date, c.end_date, c.status, c.created_date,
                           owner.full_name AS owner_name,
                           COALESCE(con.full_name, 'Not Assigned') AS contractor_name
                    FROM contracts c
                    JOIN users owner ON c.contract_owner_id = owner.id
                    LEFT JOIN users con ON c.contractor_id = con.id
                    WHERE c.id = ? AND c.contract_owner_id = ?
                    ''', (contract_id, self.current_user['id'])
                )
                row = cur.fetchone()
                conn.close()
                if not row:
                    messagebox.showerror("Error", "Contract details not found or access denied")
                    return

                # Ask for destination file
                filename = filedialog.asksaveasfilename(
                    defaultextension=".pdf",
                    filetypes=[("PDF files","*.pdf"), ("All files","*.*")],
                    title="Save Contract as PDF",
                    initialfile=f"contract_{contract_id}.pdf"
                )
                if not filename:
                    return

                # Try to import reportlab locally to avoid hard dependency at module import
                try:
                    from reportlab.lib.pagesizes import A4
                    from reportlab.pdfgen import canvas
                    from reportlab.lib.units import cm
                    from reportlab.lib.utils import simpleSplit
                except Exception:
                    messagebox.showerror(
                        "Missing Library",
                        "ReportLab is required to print PDF. Please install it with:\n\npip install reportlab"
                    )
                    return

                # Unpack row
                (cid, title, description, requirements, budget, start_date, end_date,
                 status, created_date, owner_name, contractor_name) = row

                # Create PDF
                c = canvas.Canvas(filename, pagesize=A4)
                width, height = A4
                left = 2.0*cm
                right = width - 2.0*cm
                top = height - 2.0*cm
                y = top

                def draw_heading(text):
                    nonlocal y
                    c.setFont("Helvetica-Bold", 16)
                    c.drawString(left, y, text)
                    y -= 0.8*cm

                def draw_label_value(label, value):
                    nonlocal y
                    c.setFont("Helvetica-Bold", 11)
                    c.drawString(left, y, f"{label}:")
                    c.setFont("Helvetica", 11)
                    txt = str(value or "")
                    # wrap
                    wrapped = simpleSplit(txt, "Helvetica", 11, right-left)
                    if wrapped:
                        c.drawString(left+3.7*cm, y, wrapped[0])
                        for line in wrapped[1:]:
                            y -= 0.55*cm
                            c.drawString(left+3.7*cm, y, line)
                    y -= 0.7*cm

                def draw_paragraph(label, text_content):
                    nonlocal y
                    c.setFont("Helvetica-Bold", 12)
                    c.drawString(left, y, f"{label}:")
                    y -= 0.5*cm
                    c.setFont("Helvetica", 11)
                    txt = str(text_content or "")
                    lines = simpleSplit(txt, "Helvetica", 11, right-left)
                    for line in lines:
                        if y < 2.5*cm:
                            c.showPage()
                            y = top
                            c.setFont("Helvetica", 11)
                        c.drawString(left, y, line)
                        y -= 0.5*cm
                    y -= 0.3*cm

                # Header
                draw_heading(f"Contract #{cid}: {title}")
                c.setFont("Helvetica", 10)
                c.drawString(left, y, f"Owner: {owner_name}")
                c.drawRightString(right, y, f"Date Created: {created_date or ''}")
                y -= 0.6*cm
                c.drawString(left, y, f"Contractor: {contractor_name}")
                c.drawRightString(right, y, f"Status: {status}")
                y -= 0.8*cm

                # Summary fields
                draw_label_value("Budget", f"{(budget or 0):,.0f} FCFA")
                draw_label_value("Start Date", start_date or 'N/A')
                draw_label_value("End Date", end_date or 'N/A')

                # Long sections
                draw_paragraph("Description", description or "No description provided.")
                draw_paragraph("Requirements", requirements or "No requirements provided.")

                # Digital signatures at bottom
                try:
                    conn2 = self.db_manager.create_connection(); cur2 = conn2.cursor()
                    cur2.execute('SELECT digital_signature_owner, digital_signature_contractor FROM contracts WHERE id=?', (cid,))
                    sigrow = cur2.fetchone(); conn2.close()
                except Exception:
                    sigrow = None
                owner_sig_line = 'Owner: Not signed'
                cont_sig_line = 'Contractor: Not signed'
                if sigrow:
                    try:
                        own_enc, con_enc = sigrow
                        if own_enc:
                            try:
                                info = json.loads(self.security_manager.decrypt_data(own_enc))
                                owner_sig_line = f"Owner: {info.get('signer_name','')} on {info.get('timestamp','')}"
                            except Exception:
                                owner_sig_line = 'Owner: Signed'
                        if con_enc:
                            try:
                                info2 = json.loads(self.security_manager.decrypt_data(con_enc))
                                cont_sig_line = f"Contractor: {info2.get('signer_name','')} on {info2.get('timestamp','')}"
                            except Exception:
                                cont_sig_line = 'Contractor: Signed'
                    except Exception:
                        pass
                if y < 3.0*cm:
                    c.showPage(); y = top
                c.setFont('Helvetica-Bold', 12)
                c.drawString(left, 3.2*cm, 'Digital Signatures')
                c.setFont('Helvetica', 10)
                c.drawString(left, 2.6*cm, owner_sig_line)
                c.drawString(left, 2.2*cm, cont_sig_line)

                # Footer
                c.setFont("Helvetica-Oblique", 9)
                c.drawString(left, 1.6*cm, "Generated by CBPM - Contract Management")
                from datetime import datetime as _dt
                c.drawRightString(right, 1.6*cm, _dt.now().strftime("%Y-%m-%d %H:%M"))

                c.save()

                try:
                    self.log_audit_action(self.current_user['id'], "Print Contract PDF", f"Contract {contract_id}")
                except Exception:
                    pass

                messagebox.showinfo("Success", f"Contract saved to PDF:\n{filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to print PDF: {e}")

        # Bind button commands
        new_btn.config(command=new_contract)
        edit_btn.config(command=edit_contract)
        view_btn.config(command=view_contract)
        status_btn.config(command=change_status)
        delete_btn.config(command=delete_contract)
        export_btn.config(command=export_contracts)
        print_btn.config(command=lambda: print_contract_pdf())
        refresh_btn.config(command=load_contracts)

        # Bind search and filter events
        def on_filter_change(*args):
            load_contracts()

        search_var.trace('w', on_filter_change)
        status_filter_var.trace('w', on_filter_change)
        date_filter_var.trace('w', on_filter_change)

        # Double-click to view details
        contracts_tree.bind('<Double-1>', lambda e: view_contract())

        # Right-click context menu
        def show_context_menu(event):
            selection = contracts_tree.selection()
            if selection:
                context_menu = tk.Menu(manage_window, tearoff=0)
                context_menu.add_command(label="View Details", command=view_contract)
                context_menu.add_command(label="Edit Contract", command=edit_contract)
                context_menu.add_separator()
                context_menu.add_command(label="Change Status", command=change_status)
                context_menu.add_separator()
                context_menu.add_command(label="Delete Contract", command=delete_contract)

                try:
                    context_menu.tk_popup(event.x_root, event.y_root)
                finally:
                    context_menu.grab_release()

        contracts_tree.bind("<Button-3>", show_context_menu)  # Right-click

        # Keyboard shortcuts
        manage_window.bind('<F5>', lambda e: load_contracts())
        manage_window.bind('<Escape>', lambda e: manage_window.destroy())
        manage_window.bind('<Delete>', lambda e: delete_contract())
        manage_window.bind('<Control-p>', lambda e: print_contract_pdf())

        # Initial load
        load_contracts()

        # Log the action
        self.log_audit_action(
            self.current_user['id'],
            "Access Contract Management",
            "Opened contract management interface"
        )

#==================== digital signatures functionality ====================

    def show_digital_signatures(self):
        # Digital Signatures Management window
        signatures_window = tk.Toplevel(self.root)
        signatures_window.title("Digital Signatures Management")
        signatures_window.geometry("1200x700")
        signatures_window.configure(bg='white')
        signatures_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(signatures_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="Digital Signatures Management", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Filter frame
        filter_frame = tk.Frame(header_frame, bg='white')
        filter_frame.pack(side='right')

        # Signature status filter
        tk.Label(filter_frame, text="Status:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        status_filter_var = tk.StringVar()
        status_filter = ttk.Combobox(filter_frame, textvariable=status_filter_var, width=15, state='readonly')
        status_filter['values'] = ['All', 'Unsigned', 'Partially Signed', 'Fully Signed', 'Pending']
        status_filter.set('All')
        status_filter.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(filter_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left')

        # Signature statistics frame
        stats_frame = tk.Frame(main_frame, bg='#ecf0f1', relief='raised', bd=1)
        stats_frame.pack(fill='x', pady=(0, 10))

        stats_inner = tk.Frame(stats_frame, bg='#ecf0f1')
        stats_inner.pack(pady=10)

        # Statistics labels
        total_contracts_label = tk.Label(stats_inner, text="Total Contracts: 0", font=('Arial', 10, 'bold'),
                                         bg='#ecf0f1', fg='#2c3e50')
        total_contracts_label.pack(side='left', padx=20)

        unsigned_label = tk.Label(stats_inner, text="Unsigned: 0", font=('Arial', 10, 'bold'),
                                  bg='#ecf0f1', fg='#e74c3c')
        unsigned_label.pack(side='left', padx=20)

        partial_label = tk.Label(stats_inner, text="Partially Signed: 0", font=('Arial', 10, 'bold'),
                                 bg='#ecf0f1', fg='#f39c12')
        partial_label.pack(side='left', padx=20)

        fully_signed_label = tk.Label(stats_inner, text="Fully Signed: 0", font=('Arial', 10, 'bold'),
                                      bg='#ecf0f1', fg='#27ae60')
        fully_signed_label.pack(side='left', padx=20)

        # Contracts treeview frame
        tree_frame = tk.Frame(main_frame, bg='white')
        tree_frame.pack(fill='both', expand=True, pady=(0, 20))

        # Treeview with scrollbars
        tree_scroll_y = ttk.Scrollbar(tree_frame)
        tree_scroll_y.pack(side='right', fill='y')

        tree_scroll_x = ttk.Scrollbar(tree_frame, orient='horizontal')
        tree_scroll_x.pack(side='bottom', fill='x')

        signatures_tree = ttk.Treeview(tree_frame,
                                       columns=('ID', 'Title', 'Contractor', 'Owner Signature', 'Contractor Signature',
                                                'Status', 'Last Updated'),
                                       show='headings',
                                       yscrollcommand=tree_scroll_y.set,
                                       xscrollcommand=tree_scroll_x.set)
        signatures_tree.pack(fill='both', expand=True)

        tree_scroll_y.config(command=signatures_tree.yview)
        tree_scroll_x.config(command=signatures_tree.xview)

        # Configure columns
        columns_config = [
            ('ID', 60, 'center'),
            ('Title', 250, 'w'),
            ('Contractor', 150, 'w'),
            ('Owner Signature', 120, 'center'),
            ('Contractor Signature', 130, 'center'),
            ('Status', 100, 'center'),
            ('Last Updated', 120, 'center')
        ]

        for col, width, anchor in columns_config:
            signatures_tree.heading(col, text=col)
            signatures_tree.column(col, width=width, anchor=anchor)

        # Configure row colors based on signature status
        signatures_tree.tag_configure('unsigned', background='#ffebee')
        signatures_tree.tag_configure('partial', background='#fff3e0')
        signatures_tree.tag_configure('fully_signed', background='#e8f5e8')
        signatures_tree.tag_configure('pending', background='#e3f2fd')

        # Action buttons frame
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(0, 10))

        # Left side buttons (signature actions)
        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')

        sign_owner_btn = tk.Button(left_buttons, text="Sign as Owner", font=('Arial', 10, 'bold'),
                                   bg='#27ae60', fg='white', width=12)
        sign_owner_btn.pack(side='left', padx=(0, 5))

        view_signature_btn = tk.Button(left_buttons, text="View Signatures", font=('Arial', 10, 'bold'),
                                       bg='#3498db', fg='white', width=12)
        view_signature_btn.pack(side='left', padx=(0, 5))

        generate_cert_btn = tk.Button(left_buttons, text="Generate Certificate", font=('Arial', 10),
                                      bg='#9b59b6', fg='white', width=15)
        generate_cert_btn.pack(side='left', padx=(0, 5))

        verify_btn = tk.Button(left_buttons, text="Verify Signatures", font=('Arial', 10),
                               bg='#17a2b8', fg='white', width=12)
        verify_btn.pack(side='left', padx=(0, 5))

        # Right side buttons
        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')

        export_btn = tk.Button(right_buttons, text="Export Report", font=('Arial', 10),
                               bg='#6c757d', fg='white', width=12)
        export_btn.pack(side='left', padx=(0, 5))

        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10),
                              bg='#dc3545', fg='white', width=10,
                              command=signatures_window.destroy)
        close_btn.pack(side='left')

        # Load and display signature data
        def load_signatures():
            # Clear existing items
            for item in signatures_tree.get_children():
                signatures_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Get contracts with signature information
                status_filter_text = status_filter_var.get()

                query = '''
                        SELECT c.id,
                               c.title,
                               COALESCE(u.full_name, 'Not Assigned') as contractor_name,
                               c.digital_signature_owner,
                               c.digital_signature_contractor,
                               c.status,
                               c.created_date
                        FROM contracts c
                                 LEFT JOIN users u ON c.contractor_id = u.id
                        WHERE c.contract_owner_id = ?
                        '''
                params = [self.current_user['id']]

                query += ' ORDER BY c.created_date DESC'

                cursor.execute(query, params)
                contracts = cursor.fetchall()

                # Statistics counters
                total_count = len(contracts)
                unsigned_count = 0
                partial_count = 0
                fully_signed_count = 0

                # Process each contract
                for contract in contracts:
                    contract_id, title, contractor, owner_sig, contractor_sig, status, created_date = contract

                    # Determine signature status
                    owner_status = "✓ Signed" if owner_sig else "✗ Unsigned"
                    contractor_status = "✓ Signed" if contractor_sig else "✗ Unsigned"

                    # Overall signature status
                    if not owner_sig and not contractor_sig:
                        sig_status = "Unsigned"
                        tags = ['unsigned']
                        unsigned_count += 1
                    elif owner_sig and contractor_sig:
                        sig_status = "Fully Signed"
                        tags = ['fully_signed']
                        fully_signed_count += 1
                    else:
                        sig_status = "Partially Signed"
                        tags = ['partial']
                        partial_count += 1

                    # Apply filter
                    if status_filter_text != 'All':
                        if status_filter_text == 'Unsigned' and sig_status != 'Unsigned':
                            continue
                        elif status_filter_text == 'Partially Signed' and sig_status != 'Partially Signed':
                            continue
                        elif status_filter_text == 'Fully Signed' and sig_status != 'Fully Signed':
                            continue
                        elif status_filter_text == 'Pending' and status != 'Pending Review':
                            continue

                    # Format date
                    try:
                        from datetime import datetime as dt
                        created_dt = dt.strptime(created_date, '%Y-%m-%d')
                        formatted_date = created_dt.strftime('%Y-%m-%d')
                    except:
                        formatted_date = created_date or 'N/A'

                    signatures_tree.insert('', 'end', values=(
                        contract_id,
                        title[:40] + '...' if len(title) > 40 else title,
                        contractor,
                        owner_status,
                        contractor_status,
                        sig_status,
                        formatted_date
                    ), tags=tags)

                # Update statistics
                total_contracts_label.config(text=f"Total Contracts: {total_count}")
                unsigned_label.config(text=f"Unsigned: {unsigned_count}")
                partial_label.config(text=f"Partially Signed: {partial_count}")
                fully_signed_label.config(text=f"Fully Signed: {fully_signed_count}")

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load signatures: {str(e)}")

        # Sign contract as owner
        def sign_as_owner():
            selected = signatures_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to sign")
                return

            contract_id = signatures_tree.item(selected[0])['values'][0]
            contract_title = signatures_tree.item(selected[0])['values'][1]

            # Check if already signed
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('SELECT digital_signature_owner FROM contracts WHERE id = ?', (contract_id,))
                result = cursor.fetchone()

                if result and result[0]:
                    messagebox.showinfo("Info", "You have already signed this contract")
                    conn.close()
                    return

                conn.close()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to check signature status: {str(e)}")
                return

            # Digital signature dialog
            sign_window = tk.Toplevel(signatures_window)
            sign_window.title("Digital Signature - Owner")
            sign_window.geometry("500x400")
            sign_window.configure(bg='#34495e')
            sign_window.grab_set()
            sign_window.transient(signatures_window)

            # Signature form
            form_frame = tk.Frame(sign_window, bg='#34495e', padx=30, pady=30)
            form_frame.pack(fill='both', expand=True)

            tk.Label(form_frame, text="Digital Signature - Contract Owner",
                     font=('Arial', 16, 'bold'), bg='#34495e', fg='white').pack(pady=(0, 10))

            tk.Label(form_frame, text=f"Contract: {contract_title}",
                     font=('Arial', 12), bg='#34495e', fg='#ecf0f1').pack(pady=(0, 20))

            # Signature method selection
            tk.Label(form_frame, text="Signature Method:", font=('Arial', 11, 'bold'),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            method_var = tk.StringVar(value='password')

            password_radio = tk.Radiobutton(form_frame, text="Password Authentication",
                                            variable=method_var, value='password',
                                            bg='#34495e', fg='white', selectcolor='#2c3e50',
                                            activebackground='#34495e', font=('Arial', 10))
            password_radio.pack(anchor='w', pady=2)

            digital_radio = tk.Radiobutton(form_frame, text="Digital Certificate",
                                           variable=method_var, value='certificate',
                                           bg='#34495e', fg='white', selectcolor='#2c3e50',
                                           activebackground='#34495e', font=('Arial', 10))
            digital_radio.pack(anchor='w', pady=2)

            # Password field
            password_frame = tk.Frame(form_frame, bg='#34495e')
            password_frame.pack(fill='x', pady=(20, 0))

            tk.Label(password_frame, text="Enter your password to confirm signature:",
                     font=('Arial', 11), bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            password_entry = tk.Entry(password_frame, show="*", font=('Arial', 11), width=40)
            password_entry.pack(pady=(0, 10))

            # Signature text
            tk.Label(password_frame, text="Signature Comment (Optional):",
                     font=('Arial', 11), bg='#34495e', fg='white').pack(anchor='w', pady=(10, 5))

            comment_text = tk.Text(password_frame, height=3, width=40, font=('Arial', 10))
            comment_text.pack()

            def create_signature():
                password = password_entry.get()
                if not password:
                    messagebox.showerror("Error", "Password is required for signature")
                    return

                # Verify password
                password_hash = self.security_manager.hash_password(password)

                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('SELECT password_hash FROM users WHERE id = ?', (self.current_user['id'],))
                    stored_hash = cursor.fetchone()[0]

                    if password_hash != stored_hash:
                        messagebox.showerror("Error", "Invalid password")
                        conn.close()
                        return

                    # Create digital signature
                    from datetime import datetime
                    signature_data = {
                        'signer_id': self.current_user['id'],
                        'signer_name': self.current_user['full_name'],
                        'timestamp': datetime.now().isoformat(),
                        'method': method_var.get(),
                        'comment': comment_text.get('1.0', 'end-1c').strip(),
                        'ip_address': 'localhost',  # In real implementation, get actual IP
                        'contract_id': contract_id
                    }

                    # Encrypt signature data
                    signature_json = json.dumps(signature_data)
                    encrypted_signature = self.security_manager.encrypt_data(signature_json)

                    # Update contract with signature
                    cursor.execute('''
                                   UPDATE contracts
                                   SET digital_signature_owner = ?
                                   WHERE id = ?
                                     AND contract_owner_id = ?
                                   ''', (encrypted_signature, contract_id, self.current_user['id']))

                    conn.commit()
                    try:
                        self.ensure_contract_active_if_fully_signed(contract_id)
                    except Exception:
                        pass
                    conn.close()

                    # Log the action
                    self.log_audit_action(
                        self.current_user['id'],
                        "Digital Signature",
                        f"Signed contract '{contract_title}' (ID: {contract_id}) as owner"
                    )

                    messagebox.showinfo("Success", "Contract signed successfully!")
                    sign_window.destroy()
                    load_signatures()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to create signature: {str(e)}")

            # Buttons
            btn_frame = tk.Frame(form_frame, bg='#34495e')
            btn_frame.pack(pady=(20, 0))

            tk.Button(btn_frame, text="Sign Contract", font=('Arial', 11, 'bold'),
                      bg='#27ae60', fg='white', width=15,
                      command=create_signature).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Cancel", font=('Arial', 11),
                      bg='#e74c3c', fg='white', width=15,
                      command=sign_window.destroy).pack(side='left')

        # View signatures function
        def view_signatures():
            selected = signatures_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to view signatures")
                return

            contract_id = signatures_tree.item(selected[0])['values'][0]

            # Load signature data
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT c.title,
                                      c.digital_signature_owner,
                                      c.digital_signature_contractor,
                                      owner.full_name      as owner_name,
                                      contractor.full_name as contractor_name
                               FROM contracts c
                                        JOIN users owner ON c.contract_owner_id = owner.id
                                        LEFT JOIN users contractor ON c.contractor_id = contractor.id
                               WHERE c.id = ?
                               ''', (contract_id,))

                contract_data = cursor.fetchone()
                conn.close()

                if not contract_data:
                    messagebox.showerror("Error", "Contract not found")
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load signature data: {str(e)}")
                return

            # Create view window
            view_window = tk.Toplevel(signatures_window)
            view_window.title("Digital Signatures - Contract Details")
            view_window.geometry("700x600")
            view_window.configure(bg='#f8f9fa')
            view_window.grab_set()
            view_window.transient(signatures_window)

            # Main content
            main_frame = tk.Frame(view_window, bg='#f8f9fa', padx=30, pady=20)
            main_frame.pack(fill='both', expand=True)

            # Title
            tk.Label(main_frame, text=f"Digital Signatures - Contract ID: {contract_id}",
                     font=('Arial', 16, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 10))

            tk.Label(main_frame, text=f"Contract: {contract_data[0]}",
                     font=('Arial', 12), bg='#f8f9fa', fg='#34495e').pack(pady=(0, 20))

            # Owner signature section
            owner_frame = tk.LabelFrame(main_frame, text="Contract Owner Signature",
                                        font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            owner_frame.pack(fill='x', pady=(0, 20), padx=10, ipady=10)

            if contract_data[1]:  # Owner signature exists
                try:
                    decrypted_data = self.security_manager.decrypt_data(contract_data[1])
                    signature_info = json.loads(decrypted_data)

                    tk.Label(owner_frame, text=f"✓ Signed by: {signature_info['signer_name']}",
                             font=('Arial', 11), bg='#f8f9fa', fg='#27ae60').pack(anchor='w', padx=10)

                    tk.Label(owner_frame, text=f"Timestamp: {signature_info['timestamp']}",
                             font=('Arial', 10), bg='#f8f9fa', fg='#34495e').pack(anchor='w', padx=10)

                    tk.Label(owner_frame, text=f"Method: {signature_info['method'].title()}",
                             font=('Arial', 10), bg='#f8f9fa', fg='#34495e').pack(anchor='w', padx=10)

                    if signature_info.get('comment'):
                        tk.Label(owner_frame, text=f"Comment: {signature_info['comment']}",
                                 font=('Arial', 10), bg='#f8f9fa', fg='#34495e',
                                 wraplength=600).pack(anchor='w', padx=10, pady=(5, 0))

                except Exception as e:
                    tk.Label(owner_frame, text="✗ Error reading signature data",
                             font=('Arial', 11), bg='#f8f9fa', fg='#e74c3c').pack(anchor='w', padx=10)
            else:
                tk.Label(owner_frame, text="✗ Not signed",
                         font=('Arial', 11), bg='#f8f9fa', fg='#e74c3c').pack(anchor='w', padx=10)

            # Contractor signature section
            contractor_frame = tk.LabelFrame(main_frame, text="Contractor Signature",
                                             font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            contractor_frame.pack(fill='x', pady=(0, 20), padx=10, ipady=10)

            if contract_data[2]:  # Contractor signature exists
                try:
                    decrypted_data = self.security_manager.decrypt_data(contract_data[2])
                    signature_info = json.loads(decrypted_data)

                    tk.Label(contractor_frame, text=f"✓ Signed by: {signature_info['signer_name']}",
                             font=('Arial', 11), bg='#f8f9fa', fg='#27ae60').pack(anchor='w', padx=10)

                    tk.Label(contractor_frame, text=f"Timestamp: {signature_info['timestamp']}",
                             font=('Arial', 10), bg='#f8f9fa', fg='#34495e').pack(anchor='w', padx=10)

                    tk.Label(contractor_frame, text=f"Method: {signature_info['method'].title()}",
                             font=('Arial', 10), bg='#f8f9fa', fg='#34495e').pack(anchor='w', padx=10)

                    if signature_info.get('comment'):
                        tk.Label(contractor_frame, text=f"Comment: {signature_info['comment']}",
                                 font=('Arial', 10), bg='#f8f9fa', fg='#34495e',
                                 wraplength=600).pack(anchor='w', padx=10, pady=(5, 0))

                except Exception as e:
                    tk.Label(contractor_frame, text="✗ Error reading signature data",
                             font=('Arial', 11), bg='#f8f9fa', fg='#e74c3c').pack(anchor='w', padx=10)
            else:
                if contract_data[4]:  # Contractor assigned
                    tk.Label(contractor_frame, text=f"✗ Not signed by {contract_data[4]}",
                             font=('Arial', 11), bg='#f8f9fa', fg='#e74c3c').pack(anchor='w', padx=10)
                else:
                    tk.Label(contractor_frame, text="✗ No contractor assigned",
                             font=('Arial', 11), bg='#f8f9fa', fg='#6c757d').pack(anchor='w', padx=10)

            # Close button
            tk.Button(main_frame, text="Close", font=('Arial', 11, 'bold'),
                      bg='#6c757d', fg='white', width=15,
                      command=view_window.destroy).pack(pady=20)

        # Generate certificate function
        def generate_certificate():
            selected = signatures_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a fully signed contract")
                return

            contract_id = signatures_tree.item(selected[0])['values'][0]
            signature_status = signatures_tree.item(selected[0])['values'][5]

            if signature_status != "Fully Signed":
                messagebox.showwarning("Warning", "Certificate can only be generated for fully signed contracts")
                return

            # Generate completion certificate
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT c.title,
                                      c.budget,
                                      c.start_date,
                                      c.end_date,
                                      owner.full_name      as owner_name,
                                      contractor.full_name as contractor_name
                               FROM contracts c
                                        JOIN users owner ON c.contract_owner_id = owner.id
                                        LEFT JOIN users contractor ON c.contractor_id = contractor.id
                               WHERE c.id = ?
                               ''', (contract_id,))

                contract_info = cursor.fetchone()
                conn.close()

                if not contract_info:
                    messagebox.showerror("Error", "Contract not found")
                    return

                # Save certificate as text file (in real implementation, could be PDF)
                filename = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
                    title="Save Certificate",
                    initialname=f"Contract_{contract_id}_Certificate.txt"
                )

                if filename:
                    from datetime import datetime

                    certificate_content = f"""
    DIGITAL CONTRACT COMPLETION CERTIFICATE

    Contract ID: {contract_id}
    Contract Title: {contract_info[0]}
    Contract Value: {contract_info[1]:,.0f} FCFA
    Duration: {contract_info[2]} to {contract_info[3]}

    Parties:
    - Contract Owner: {contract_info[4]}
    - Contractor: {contract_info[5]}

    Certification:
    This certificate confirms that the above contract has been digitally signed by all parties
    and is legally binding under the digital signature framework.

    Certificate Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    Generated by: {self.current_user['full_name']}

    Digital Signature Verification: VALID
    Certificate Authority: CBPM System

    ---
    This is a system-generated certificate.
    """

                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(certificate_content)

                    messagebox.showinfo("Success", f"Certificate saved to {filename}")

                    # Log the action
                    self.log_audit_action(
                        self.current_user['id'],
                        "Generate Certificate",
                        f"Generated completion certificate for contract {contract_id}"
                    )

            except Exception as e:
                messagebox.showerror("Error", f"Failed to generate certificate: {str(e)}")

        # Verify signatures function
        def verify_signatures():
            selected = signatures_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to verify signatures")
                return

            contract_id = signatures_tree.item(selected[0])['values'][0]

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT digital_signature_owner, digital_signature_contractor, title
                               FROM contracts
                               WHERE id = ?
                               ''', (contract_id,))

                result = cursor.fetchone()
                conn.close()

                if not result:
                    messagebox.showerror("Error", "Contract not found")
                    return

                owner_sig, contractor_sig, title = result

                verification_results = []

                # Verify owner signature
                if owner_sig:
                    try:
                        decrypted_data = self.security_manager.decrypt_data(owner_sig)
                        signature_info = json.loads(decrypted_data)
                        verification_results.append("✓ Owner signature: VALID")
                        verification_results.append(f"  - Signed by: {signature_info['signer_name']}")
                        verification_results.append(f"  - Timestamp: {signature_info['timestamp']}")
                    except Exception as e:
                        verification_results.append("✗ Owner signature: INVALID or CORRUPTED")
                else:
                    verification_results.append("✗ Owner signature: NOT PRESENT")

                # Verify contractor signature
                if contractor_sig:
                    try:
                        decrypted_data = self.security_manager.decrypt_data(contractor_sig)
                        signature_info = json.loads(decrypted_data)
                        verification_results.append("✓ Contractor signature: VALID")
                        verification_results.append(f"  - Signed by: {signature_info['signer_name']}")
                        verification_results.append(f"  - Timestamp: {signature_info['timestamp']}")
                    except Exception as e:
                        verification_results.append("✗ Contractor signature: INVALID or CORRUPTED")
                else:
                    verification_results.append("✗ Contractor signature: NOT PRESENT")

                # Show results
                result_message = f"Signature Verification Results\nContract: {title}\n\n" + "\n".join(
                    verification_results)
                messagebox.showinfo("Signature Verification", result_message)

                # Log the action
                self.log_audit_action(
                    self.current_user['id'],
                    "Verify Signatures",
                    f"Verified signatures for contract {contract_id}"
                )

            except Exception as e:
                messagebox.showerror("Error", f"Failed to verify signatures: {str(e)}")

        # Export report function
        def export_report():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".csv",
                    filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                    title="Export Signature Report"
                )

                if filename:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('''
                                   SELECT c.id,
                                          c.title,
                                          COALESCE(u.full_name, 'Not Assigned'),
                                          CASE
                                              WHEN c.digital_signature_owner IS NOT NULL THEN 'Signed'
                                              ELSE 'Unsigned' END,
                                          CASE
                                              WHEN c.digital_signature_contractor IS NOT NULL THEN 'Signed'
                                              ELSE 'Unsigned' END,
                                          c.budget,
                                          c.status,
                                          c.created_date
                                   FROM contracts c
                                            LEFT JOIN users u ON c.contractor_id = u.id
                                   WHERE c.contract_owner_id = ?
                                   ORDER BY c.created_date DESC
                                   ''', (self.current_user['id'],))

                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerow(
                            ['Contract ID', 'Title', 'Contractor', 'Owner Signature', 'Contractor Signature', 'Budget',
                             'Status', 'Created Date'])
                        writer.writerows(cursor.fetchall())

                    conn.close()
                    messagebox.showinfo("Success", f"Signature report exported to {filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to export report: {str(e)}")

        # Bind button commands
        sign_owner_btn.config(command=sign_as_owner)
        view_signature_btn.config(command=view_signatures)
        generate_cert_btn.config(command=generate_certificate)
        verify_btn.config(command=verify_signatures)
        export_btn.config(command=export_report)
        refresh_btn.config(command=load_signatures)

        # Bind filter events
        status_filter_var.trace('w', lambda *args: load_signatures())

        # Double-click to view signatures
        signatures_tree.bind('<Double-1>', lambda e: view_signatures())

        # Keyboard shortcuts
        signatures_window.bind('<F5>', lambda e: load_signatures())
        signatures_window.bind('<Escape>', lambda e: signatures_window.destroy())

        # Initial load
        load_signatures()

        # Log the action
        self.log_audit_action(
            self.current_user['id'],
            "Access Digital Signatures",
            "Opened digital signatures management interface"
        )
# =========================== transfer product detail =========================
        def show_transfer_products(self):
            # Transfer Products Management window
            transfer_window = tk.Toplevel(self.root)
            transfer_window.title("Transfer Products Between Stores")
            transfer_window.geometry("1400x800")
            transfer_window.configure(bg='white')
            transfer_window.grab_set()  # Make modal

            # Main container
            main_frame = tk.Frame(transfer_window, bg='white', padx=10, pady=10)
            main_frame.pack(fill='both', expand=True)

            # Title and controls frame
            header_frame = tk.Frame(main_frame, bg='white')
            header_frame.pack(fill='x', pady=(0, 20))

            # Title
            tk.Label(header_frame, text="Product Transfer Management", font=('Arial', 18, 'bold'),
                     bg='white', fg='#2c3e50').pack(side='left')

            # Control buttons
            control_frame = tk.Frame(header_frame, bg='white')
            control_frame.pack(side='right')

            new_transfer_btn = tk.Button(control_frame, text="New Transfer", font=('Arial', 11, 'bold'),
                                         bg='#27ae60', fg='white', width=12)
            new_transfer_btn.pack(side='left', padx=(0, 10))

            refresh_btn = tk.Button(control_frame, text="Refresh", font=('Arial', 10),
                                    bg='#3498db', fg='white', width=8)
            refresh_btn.pack(side='left')

            # Create notebook for different sections
            notebook = ttk.Notebook(main_frame)
            notebook.pack(fill='both', expand=True, pady=(0, 10))

            # Tab 1: Create New Transfer
            new_transfer_frame = tk.Frame(notebook, bg='white')
            notebook.add(new_transfer_frame, text="New Transfer")

            # Tab 2: Transfer History
            history_frame = tk.Frame(notebook, bg='white')
            notebook.add(history_frame, text="Transfer History")

            # Tab 3: Pending Transfers
            pending_frame = tk.Frame(notebook, bg='white')
            notebook.add(pending_frame, text="Pending Transfers")

            # =================== TAB 1: NEW TRANSFER ===================
            new_main = tk.Frame(new_transfer_frame, bg='white', padx=20, pady=20)
            new_main.pack(fill='both', expand=True)

            # Store Selection Section
            store_section = tk.LabelFrame(new_main, text="Store Selection",
                                          font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
            store_section.pack(fill='x', pady=(0, 20))

            store_selection_frame = tk.Frame(store_section, bg='white')
            store_selection_frame.pack(fill='x', padx=15, pady=15)

            # Source Store
            source_frame = tk.Frame(store_selection_frame, bg='white')
            source_frame.pack(side='left', fill='x', expand=True, padx=(0, 20))

            tk.Label(source_frame, text="Transfer FROM (Source Store):", font=('Arial', 11, 'bold'),
                     bg='white', fg='#e74c3c').pack(anchor='w', pady=(0, 5))

            source_store_var = tk.StringVar()
            source_store_combo = ttk.Combobox(source_frame, textvariable=source_store_var,
                                              width=35, state='readonly', font=('Arial', 11))
            source_store_combo.pack(fill='x', pady=(0, 10))

            source_info_label = tk.Label(source_frame, text="", font=('Arial', 9),
                                         bg='white', fg='#7f8c8d', wraplength=300)
            source_info_label.pack(anchor='w')

            # Destination Store
            dest_frame = tk.Frame(store_selection_frame, bg='white')
            dest_frame.pack(side='right', fill='x', expand=True, padx=(20, 0))

            tk.Label(dest_frame, text="Transfer TO (Destination Store):", font=('Arial', 11, 'bold'),
                     bg='white', fg='#27ae60').pack(anchor='w', pady=(0, 5))

            dest_store_var = tk.StringVar()
            dest_store_combo = ttk.Combobox(dest_frame, textvariable=dest_store_var,
                                            width=35, state='readonly', font=('Arial', 11))
            dest_store_combo.pack(fill='x', pady=(0, 10))

            dest_info_label = tk.Label(dest_frame, text="", font=('Arial', 9),
                                       bg='white', fg='#7f8c8d', wraplength=300)
            dest_info_label.pack(anchor='w')

            # Available Inventory Section
            inventory_section = tk.LabelFrame(new_main, text="Available Inventory",
                                              font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
            inventory_section.pack(fill='both', expand=True, pady=(0, 20))

            # Search and filter frame
            search_frame = tk.Frame(inventory_section, bg='white')
            search_frame.pack(fill='x', padx=15, pady=(15, 10))

            tk.Label(search_frame, text="Search Products:", font=('Arial', 10),
                     bg='white').pack(side='left')

            search_var = tk.StringVar()
            search_entry = tk.Entry(search_frame, textvariable=search_var, font=('Arial', 10), width=25)
            search_entry.pack(side='left', padx=(5, 20))

            tk.Label(search_frame, text="Category:", font=('Arial', 10),
                     bg='white').pack(side='left')

            category_filter_var = tk.StringVar()
            category_filter = ttk.Combobox(search_frame, textvariable=category_filter_var,
                                           width=15, state='readonly')
            category_filter['values'] = ['All Categories', 'Cement', 'Steel', 'Timber', 'Roofing',
                                         'Aggregate', 'Masonry', 'Paint', 'Electrical', 'Plumbing']
            category_filter.set('All Categories')
            category_filter.pack(side='left', padx=(5, 0))

            # Inventory treeview
            inventory_tree_frame = tk.Frame(inventory_section, bg='white')
            inventory_tree_frame.pack(fill='both', expand=True, padx=15, pady=(0, 15))

            # Scrollbars for inventory tree
            inv_scroll_y = ttk.Scrollbar(inventory_tree_frame)
            inv_scroll_y.pack(side='right', fill='y')

            inv_scroll_x = ttk.Scrollbar(inventory_tree_frame, orient='horizontal')
            inv_scroll_x.pack(side='bottom', fill='x')

            inventory_tree = ttk.Treeview(inventory_tree_frame,
                                          columns=('Material', 'Category', 'Current Stock', 'Unit',
                                                   'Unit Price', 'Total Value', 'Reorder Level'),
                                          show='headings',
                                          yscrollcommand=inv_scroll_y.set,
                                          xscrollcommand=inv_scroll_x.set)
            inventory_tree.pack(fill='both', expand=True)

            inv_scroll_y.config(command=inventory_tree.yview)
            inv_scroll_x.config(command=inventory_tree.xview)

            # Configure inventory tree columns
            inv_columns_config = [
                ('Material', 200, 'w'),
                ('Category', 120, 'center'),
                ('Current Stock', 120, 'e'),
                ('Unit', 80, 'center'),
                ('Unit Price', 120, 'e'),
                ('Total Value', 140, 'e'),
                ('Reorder Level', 120, 'e')
            ]

            for col, width, anchor in inv_columns_config:
                inventory_tree.heading(col, text=col)
                inventory_tree.column(col, width=width, anchor=anchor)

            # Transfer Details Section
            transfer_section = tk.LabelFrame(new_main, text="Transfer Details",
                                             font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
            transfer_section.pack(fill='x', pady=(0, 20))

            transfer_details_frame = tk.Frame(transfer_section, bg='white')
            transfer_details_frame.pack(fill='x', padx=15, pady=15)

            # Selected item info
            selected_frame = tk.Frame(transfer_details_frame, bg='white')
            selected_frame.pack(side='left', fill='x', expand=True, padx=(0, 20))

            tk.Label(selected_frame, text="Selected Item:", font=('Arial', 11, 'bold'),
                     bg='white', fg='#2c3e50').pack(anchor='w')

            selected_item_label = tk.Label(selected_frame, text="No item selected",
                                           font=('Arial', 10), bg='white', fg='#7f8c8d')
            selected_item_label.pack(anchor='w', pady=(5, 10))

            # Transfer quantity
            tk.Label(selected_frame, text="Transfer Quantity:", font=('Arial', 11, 'bold'),
                     bg='white', fg='#2c3e50').pack(anchor='w')

            quantity_frame = tk.Frame(selected_frame, bg='white')
            quantity_frame.pack(anchor='w', pady=(5, 10))

            quantity_var = tk.StringVar()
            quantity_entry = tk.Entry(quantity_frame, textvariable=quantity_var,
                                      font=('Arial', 11), width=15)
            quantity_entry.pack(side='left')

            max_qty_label = tk.Label(quantity_frame, text="", font=('Arial', 9),
                                     bg='white', fg='#7f8c8d')
            max_qty_label.pack(side='left', padx=(10, 0))

            # Transfer reason/notes
            reason_notes_frame = tk.Frame(transfer_details_frame, bg='white')
            reason_notes_frame.pack(side='right', fill='x', expand=True, padx=(20, 0))

            tk.Label(reason_notes_frame, text="Transfer Reason:", font=('Arial', 11, 'bold'),
                     bg='white', fg='#2c3e50').pack(anchor='w')

            reason_var = tk.StringVar()
            reason_combo = ttk.Combobox(reason_notes_frame, textvariable=reason_var,
                                        width=30, state='readonly')
            reason_combo['values'] = [
                'Stock Rebalancing', 'Store Restocking', 'Customer Request',
                'Seasonal Adjustment', 'Emergency Supply', 'Store Closure',
                'Damage/Defect', 'Other'
            ]
            reason_combo.pack(anchor='w', pady=(5, 10))

            tk.Label(reason_notes_frame, text="Notes:", font=('Arial', 11, 'bold'),
                     bg='white', fg='#2c3e50').pack(anchor='w')

            notes_text = tk.Text(reason_notes_frame, height=3, width=30, font=('Arial', 10))
            notes_text.pack(anchor='w', pady=(5, 0))

            # Action buttons for new transfer
            action_frame = tk.Frame(new_main, bg='white')
            action_frame.pack(fill='x', pady=10)

            add_to_transfer_btn = tk.Button(action_frame, text="Add to Transfer List",
                                            font=('Arial', 11, 'bold'), bg='#3498db', fg='white', width=18)
            add_to_transfer_btn.pack(side='left', padx=(0, 10))

            preview_transfer_btn = tk.Button(action_frame, text="Preview Transfer",
                                             font=('Arial', 11), bg='#f39c12', fg='white', width=15)
            preview_transfer_btn.pack(side='left', padx=(0, 10))

            execute_transfer_btn = tk.Button(action_frame, text="Execute Transfer",
                                             font=('Arial', 11, 'bold'), bg='#27ae60', fg='white', width=15)
            execute_transfer_btn.pack(side='left', padx=(0, 10))

            clear_transfer_btn = tk.Button(action_frame, text="Clear All",
                                           font=('Arial', 11), bg='#e74c3c', fg='white', width=12)
            clear_transfer_btn.pack(side='right')

            # Current Transfer List
            transfer_list_section = tk.LabelFrame(new_main, text="Current Transfer List",
                                                  font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
            transfer_list_section.pack(fill='both', expand=True)

            transfer_list_frame = tk.Frame(transfer_list_section, bg='white')
            transfer_list_frame.pack(fill='both', expand=True, padx=15, pady=15)

            # Transfer list treeview
            list_scroll_y = ttk.Scrollbar(transfer_list_frame)
            list_scroll_y.pack(side='right', fill='y')

            transfer_list_tree = ttk.Treeview(transfer_list_frame,
                                              columns=('Material', 'Quantity', 'Unit', 'Unit Price',
                                                       'Total Value', 'Reason'),
                                              show='headings',
                                              yscrollcommand=list_scroll_y.set)
            transfer_list_tree.pack(fill='both', expand=True)

            list_scroll_y.config(command=transfer_list_tree.yview)

            # Configure transfer list columns
            list_columns_config = [
                ('Material', 250, 'w'),
                ('Quantity', 100, 'e'),
                ('Unit', 80, 'center'),
                ('Unit Price', 120, 'e'),
                ('Total Value', 140, 'e'),
                ('Reason', 200, 'w')
            ]

            for col, width, anchor in list_columns_config:
                transfer_list_tree.heading(col, text=col)
                transfer_list_tree.column(col, width=width, anchor=anchor)

            # Transfer list summary
            summary_frame = tk.Frame(transfer_list_section, bg='#ecf0f1', relief='raised', bd=1)
            summary_frame.pack(fill='x', padx=15, pady=(0, 15))

            summary_inner = tk.Frame(summary_frame, bg='#ecf0f1')
            summary_inner.pack(pady=10)

            total_items_label = tk.Label(summary_inner, text="Total Items: 0", font=('Arial', 10, 'bold'),
                                         bg='#ecf0f1', fg='#2c3e50')
            total_items_label.pack(side='left', padx=20)

            total_value_label = tk.Label(summary_inner, text="Total Value: 0 FCFA", font=('Arial', 10, 'bold'),
                                         bg='#ecf0f1', fg='#27ae60')
            total_value_label.pack(side='left', padx=20)

            # =================== TAB 2: TRANSFER HISTORY ===================
            history_main = tk.Frame(history_frame, bg='white', padx=20, pady=20)
            history_main.pack(fill='both', expand=True)

            # History filters
            history_filter_frame = tk.Frame(history_main, bg='white')
            history_filter_frame.pack(fill='x', pady=(0, 15))

            tk.Label(history_filter_frame, text="Date Range:", font=('Arial', 10),
                     bg='white').pack(side='left', padx=(0, 5))

            date_range_var = tk.StringVar()
            date_range_combo = ttk.Combobox(history_filter_frame, textvariable=date_range_var,
                                            width=15, state='readonly')
            date_range_combo['values'] = ['All Time', 'Today', 'Last 7 Days', 'Last 30 Days', 'This Year']
            date_range_combo.set('Last 30 Days')
            date_range_combo.pack(side='left', padx=(0, 20))

            tk.Label(history_filter_frame, text="Status:", font=('Arial', 10),
                     bg='white').pack(side='left', padx=(0, 5))

            status_filter_var = tk.StringVar()
            status_filter_combo = ttk.Combobox(history_filter_frame, textvariable=status_filter_var,
                                               width=15, state='readonly')
            status_filter_combo['values'] = ['All Status', 'Completed', 'Pending', 'In Transit', 'Cancelled']
            status_filter_combo.set('All Status')
            status_filter_combo.pack(side='left', padx=(0, 20))

            export_history_btn = tk.Button(history_filter_frame, text="Export History",
                                           font=('Arial', 10), bg='#17a2b8', fg='white', width=12)
            export_history_btn.pack(side='right')

            # History treeview
            history_tree_frame = tk.Frame(history_main, bg='white')
            history_tree_frame.pack(fill='both', expand=True)

            hist_scroll_y = ttk.Scrollbar(history_tree_frame)
            hist_scroll_y.pack(side='right', fill='y')

            hist_scroll_x = ttk.Scrollbar(history_tree_frame, orient='horizontal')
            hist_scroll_x.pack(side='bottom', fill='x')

            history_tree = ttk.Treeview(history_tree_frame,
                                        columns=('Transfer ID', 'Date', 'From Store', 'To Store',
                                                 'Items', 'Total Value', 'Status', 'Initiated By'),
                                        show='headings',
                                        yscrollcommand=hist_scroll_y.set,
                                        xscrollcommand=hist_scroll_x.set)
            history_tree.pack(fill='both', expand=True)

            hist_scroll_y.config(command=history_tree.yview)
            hist_scroll_x.config(command=history_tree.xview)

            # Configure history tree columns
            hist_columns_config = [
                ('Transfer ID', 100, 'center'),
                ('Date', 120, 'center'),
                ('From Store', 180, 'w'),
                ('To Store', 180, 'w'),
                ('Items', 80, 'center'),
                ('Total Value', 140, 'e'),
                ('Status', 100, 'center'),
                ('Initiated By', 150, 'w')
            ]

            for col, width, anchor in hist_columns_config:
                history_tree.heading(col, text=col)
                history_tree.column(col, width=width, anchor=anchor)

            # Configure row colors for status
            history_tree.tag_configure('completed', background='#d5f4e6')
            history_tree.tag_configure('pending', background='#fff3e0')
            history_tree.tag_configure('in_transit', background='#e3f2fd')
            history_tree.tag_configure('cancelled', background='#ffebee')

            # =================== TAB 3: PENDING TRANSFERS ===================
            pending_main = tk.Frame(pending_frame, bg='white', padx=20, pady=20)
            pending_main.pack(fill='both', expand=True)

            tk.Label(pending_main, text="Transfers Requiring Your Action",
                     font=('Arial', 14, 'bold'), bg='white', fg='#e74c3c').pack(pady=(0, 15))

            # Pending transfers treeview
            pending_tree_frame = tk.Frame(pending_main, bg='white')
            pending_tree_frame.pack(fill='both', expand=True, pady=(0, 15))

            pend_scroll_y = ttk.Scrollbar(pending_tree_frame)
            pend_scroll_y.pack(side='right', fill='y')

            pending_tree = ttk.Treeview(pending_tree_frame,
                                        columns=('Transfer ID', 'Date', 'From Store', 'Items',
                                                 'Total Value', 'Initiated By', 'Action Required'),
                                        show='headings',
                                        yscrollcommand=pend_scroll_y.set)
            pending_tree.pack(fill='both', expand=True)

            pend_scroll_y.config(command=pending_tree.yview)

            # Configure pending tree columns
            pend_columns_config = [
                ('Transfer ID', 100, 'center'),
                ('Date', 120, 'center'),
                ('From Store', 200, 'w'),
                ('Items', 80, 'center'),
                ('Total Value', 140, 'e'),
                ('Initiated By', 150, 'w'),
                ('Action Required', 150, 'center')
            ]

            for col, width, anchor in pend_columns_config:
                pending_tree.heading(col, text=col)
                pending_tree.column(col, width=width, anchor=anchor)

            # Pending actions frame
            pending_actions_frame = tk.Frame(pending_main, bg='white')
            pending_actions_frame.pack(fill='x')

            approve_btn = tk.Button(pending_actions_frame, text="Approve Transfer",
                                    font=('Arial', 11, 'bold'), bg='#27ae60', fg='white', width=15)
            approve_btn.pack(side='left', padx=(0, 10))

            reject_btn = tk.Button(pending_actions_frame, text="Reject Transfer",
                                   font=('Arial', 11, 'bold'), bg='#e74c3c', fg='white', width=15)
            reject_btn.pack(side='left', padx=(0, 10))

            view_details_btn = tk.Button(pending_actions_frame, text="View Details",
                                         font=('Arial', 11), bg='#3498db', fg='white', width=12)
            view_details_btn.pack(side='left')

            # Storage for transfer list items
            current_transfer_items = []

            # Load user's stores
            def load_stores():
                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    # Get stores owned or managed by current user
                    cursor.execute('''
                                   SELECT id, name, location, contact_info
                                   FROM stores
                                   WHERE (owner_id = ? OR manager_id = ?)
                                     AND is_active = 1
                                   ORDER BY name
                                   ''', (self.current_user['id'], self.current_user['id']))

                    stores = cursor.fetchall()

                    store_options = []
                    store_info = {}

                    for store_id, name, location, contact_info in stores:
                        option = f"{store_id} - {name}"
                        store_options.append(option)

                        # Parse contact info for additional details
                        try:
                            contact_data = json.loads(contact_info) if contact_info else {}
                            category = contact_data.get('category', 'General')
                            phone = contact_data.get('phone', 'N/A')
                            store_info[option] = f"Location: {location}\nCategory: {category}\nPhone: {phone}"
                        except:
                            store_info[option] = f"Location: {location}"

                    source_store_combo['values'] = store_options
                    dest_store_combo['values'] = store_options

                    return store_info

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to load stores: {str(e)}")
                    return {}

            # Update store info labels
            def update_store_info(*args):
                info_map = load_stores()

                source_selection = source_store_var.get()
                dest_selection = dest_store_var.get()

                if source_selection in info_map:
                    source_info_label.config(text=info_map[source_selection])

                if dest_selection in info_map:
                    dest_info_label.config(text=info_map[dest_selection])

                # Load inventory when source store changes
                if source_selection:
                    load_inventory()

            # Load inventory for selected source store
            def load_inventory():
                # Clear existing items
                for item in inventory_tree.get_children():
                    inventory_tree.delete(item)

                source_selection = source_store_var.get()
                if not source_selection:
                    return

                try:
                    store_id = int(source_selection.split(' - ')[0])

                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    # Get inventory items for the selected store
                    cursor.execute('''
                                   SELECT i.id,
                                          bm.name,
                                          bm.category,
                                          i.quantity,
                                          bm.unit,
                                          i.unit_price,
                                          i.reorder_level,
                                          i.material_id
                                   FROM inventory i
                                            JOIN building_materials bm ON i.material_id = bm.id
                                   WHERE i.store_id = ?
                                     AND i.quantity > 0
                                   ORDER BY bm.category, bm.name
                                   ''', (store_id,))

                    inventory_items = cursor.fetchall()

                    search_text = search_var.get().lower()
                    category_filter_text = category_filter_var.get()

                    for item in inventory_items:
                        inv_id, name, category, quantity, unit, unit_price, reorder_level, material_id = item

                        # Apply filters
                        if search_text and search_text not in name.lower():
                            continue

                        if category_filter_text != 'All Categories' and category_filter_text != category:
                            continue

                        total_value = quantity * unit_price

                        # Color code based on stock level
                        tags = []
                        if quantity <= reorder_level:
                            tags.append('low_stock')
                        elif quantity > reorder_level * 2:
                            tags.append('high_stock')

                        inventory_tree.insert('', 'end', values=(
                            name, category, f"{quantity:,.1f}", unit,
                            f"{unit_price:,.0f}", f"{total_value:,.0f}",
                            f"{reorder_level:,.1f}"
                        ), tags=tags)

                    # Configure inventory tree tags
                    inventory_tree.tag_configure('low_stock', background='#ffebee')
                    inventory_tree.tag_configure('high_stock', background='#e8f5e8')

                    conn.close()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to load inventory: {str(e)}")

            # Handle inventory selection
            def on_inventory_select(event):
                selection = inventory_tree.selection()
                if not selection:
                    selected_item_label.config(text="No item selected")
                    max_qty_label.config(text="")
                    return

                # Get selected item details
                item_values = inventory_tree.item(selection[0])['values']
                material_name = item_values[0]
                current_stock = float(item_values[2].replace(',', ''))
                unit = item_values[3]

                selected_item_label.config(text=f"{material_name} ({unit})")
                max_qty_label.config(text=f"Max: {current_stock:,.1f} {unit}")

                # Clear previous quantity
                quantity_var.set("")

            # Add item to transfer list
            def add_to_transfer():
                selection = inventory_tree.selection()
                if not selection:
                    messagebox.showwarning("Warning", "Please select an item from inventory")
                    return

                # Validate inputs
                if not quantity_var.get():
                    messagebox.showerror("Error", "Please enter transfer quantity")
                    return

                if not reason_var.get():
                    messagebox.showerror("Error", "Please select transfer reason")
                    return

                if source_store_var.get() == dest_store_var.get():
                    messagebox.showerror("Error", "Source and destination stores cannot be the same")
                    return

                try:
                    transfer_qty = float(quantity_var.get())
                    if transfer_qty <= 0:
                        raise ValueError("Quantity must be positive")

                    # Get item details
                    item_values = inventory_tree.item(selection[0])['values']
                    material_name = item_values[0]
                    current_stock = float(item_values[2].replace(',', ''))
                    unit = item_values[3]
                    unit_price = float(item_values[4].replace(',', ''))

                    if transfer_qty > current_stock:
                        messagebox.showerror("Error",
                                             f"Transfer quantity ({transfer_qty}) exceeds available stock ({current_stock})")
                        return

                    # Check if item already in transfer list
                    for existing_item in current_transfer_items:
                        if existing_item['material'] == material_name:
                            messagebox.showwarning("Warning",
                                                   "Item already in transfer list. Remove it first to add with different quantity.")
                            return

                    # Add to transfer list
                    total_value = transfer_qty * unit_price
                    notes = notes_text.get('1.0', 'end-1c').strip()

                    transfer_item = {
                        'material': material_name,
                        'quantity': transfer_qty,
                        'unit': unit,
                        'unit_price': unit_price,
                        'total_value': total_value,
                        'reason': reason_var.get(),
                        'notes': notes
                    }

                    current_transfer_items.append(transfer_item)

                    # Add to transfer list tree
                    transfer_list_tree.insert('', 'end', values=(
                        material_name, f"{transfer_qty:,.1f}", unit,
                        f"{unit_price:,.0f}", f"{total_value:,.0f}", reason_var.get()
                    ))

                    # Update summary
                    update_transfer_summary()

                    # Clear form
                    quantity_var.set("")
                    notes_text.delete('1.0', 'end')

                    messagebox.showinfo("Success", f"Added {transfer_qty} {unit} of {material_name} to transfer list")

                except ValueError as e:
                    messagebox.showerror("Error", f"Invalid quantity: {str(e)}")

            # Update transfer summary
            def update_transfer_summary():
                total_items = len(current_transfer_items)
                total_value = sum(item['total_value'] for item in current_transfer_items)

                total_items_label.config(text=f"Total Items: {total_items}")
                total_value_label.config(text=f"Total Value: {total_value:,.0f} FCFA")

            # Preview transfer
            def preview_transfer():
                if not current_transfer_items:
                    messagebox.showwarning("Warning", "No items in transfer list")
                    return

                if not source_store_var.get() or not dest_store_var.get():
                    messagebox.showerror("Error", "Please select both source and destination stores")
                    return

                # Create preview window
                preview_window = tk.Toplevel(transfer_window)
                preview_window.title("Transfer Preview")
                preview_window.geometry("700x600")
                preview_window.configure(bg='#f8f9fa')
                preview_window.grab_set()
                preview_window.transient(transfer_window)

                # Preview content
                preview_frame = tk.Frame(preview_window, bg='#f8f9fa', padx=30, pady=20)
                preview_frame.pack(fill='both', expand=True)

                tk.Label(preview_frame, text="Transfer Preview", font=('Arial', 16, 'bold'),
                         bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))

                # Transfer details
                details_frame = tk.LabelFrame(preview_frame, text="Transfer Details",
                                              font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
                details_frame.pack(fill='x', pady=(0, 15))

                details_info = [
                    ("From Store:", source_store_var.get().split(' - ')[1]),
                    ("To Store:", dest_store_var.get().split(' - ')[1]),
                    ("Number of Items:", str(len(current_transfer_items))),
                    ("Total Value:", f"{sum(item['total_value'] for item in current_transfer_items):,.0f} FCFA"),
                    ("Initiated By:", self.current_user['full_name'])
                ]

                for label, value in details_info:
                    info_frame = tk.Frame(details_frame, bg='#f8f9fa')
                    info_frame.pack(fill='x', padx=10, pady=2)

                    tk.Label(info_frame, text=label, font=('Arial', 10, 'bold'),
                             bg='#f8f9fa', fg='#2c3e50', width=15, anchor='w').pack(side='left')
                    tk.Label(info_frame, text=value, font=('Arial', 10),
                             bg='#f8f9fa', fg='#34495e').pack(side='left', padx=(10, 0))

                # Items list
                items_frame = tk.LabelFrame(preview_frame, text="Items to Transfer",
                                            font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
                items_frame.pack(fill='both', expand=True, pady=(0, 15))

                items_text = tk.Text(items_frame, height=15, width=70, font=('Arial', 9),
                                     wrap='none', state='normal', bg='white')
                items_text.pack(fill='both', expand=True, padx=10, pady=10)

                # Format items list
                items_content = f"{'Material':<25} {'Quantity':<12} {'Unit':<8} {'Unit Price':<12} {'Total Value':<15} {'Reason':<20}\n"
                items_content += "-" * 110 + "\n"

                for item in current_transfer_items:
                    items_content += f"{item['material']:<25} {item['quantity']:<12.1f} {item['unit']:<8} {item['unit_price']:<12,.0f} {item['total_value']:<15,.0f} {item['reason']:<20}\n"
                    if item['notes']:
                        items_content += f"    Notes: {item['notes']}\n"

                items_text.insert('1.0', items_content)
                items_text.config(state='disabled')

                # Action buttons
                btn_frame = tk.Frame(preview_frame, bg='#f8f9fa')
                btn_frame.pack(pady=10)

                tk.Button(btn_frame, text="Confirm & Execute", font=('Arial', 11, 'bold'),
                          bg='#27ae60', fg='white', width=18,
                          command=lambda: [preview_window.destroy(), execute_transfer()]).pack(side='left',
                                                                                               padx=(0, 10))

                tk.Button(btn_frame, text="Cancel", font=('Arial', 11),
                          bg='#e74c3c', fg='white', width=15,
                          command=preview_window.destroy).pack(side='left')

            # Execute transfer
            def execute_transfer():
                # Only retail store owners can approve/execute transfers
                if not self.current_user or self.current_user.get('role') != 'retail_store':
                    self.log_audit_action(self.current_user['id'] if self.current_user else None,
                                          "Transfer Request",
                                          "Non-retail user attempted to execute transfer; request requires approval by retail store owner.")
                    messagebox.showinfo("Approval Required", "Only Retail Store Owners can approve and execute transfers. Your request has been noted and requires approval.")
                    return
                if not current_transfer_items:
                    messagebox.showwarning("Warning", "No items in transfer list")
                    return

                if not source_store_var.get() or not dest_store_var.get():
                    messagebox.showerror("Error", "Please select both source and destination stores")
                    return

                if messagebox.askyesno("Confirm Transfer",
                                       f"Execute transfer of {len(current_transfer_items)} items?\n\n"
                                       f"This will update inventory in both stores.\n"
                                       f"This action cannot be easily undone."):

                    try:
                        source_store_id = int(source_store_var.get().split(' - ')[0])
                        dest_store_id = int(dest_store_var.get().split(' - ')[0])

                        conn = self.db_manager.create_connection()
                        cursor = conn.cursor()

                        # Create transfer record (in real implementation, would have transfers table)
                        from datetime import datetime
                        transfer_id = f"T{datetime.now().strftime('%Y%m%d%H%M%S')}"

                        transfer_summary = {
                            'transfer_id': transfer_id,
                            'date': datetime.now().isoformat(),
                            'from_store_id': source_store_id,
                            'to_store_id': dest_store_id,
                            'items': current_transfer_items,
                            'total_value': sum(item['total_value'] for item in current_transfer_items),
                            'initiated_by': self.current_user['id'],
                            'status': 'Completed'
                        }

                        # For each item in transfer, update inventory
                        for item in current_transfer_items:
                            material_name = item['material']
                            transfer_qty = item['quantity']

                            # Get material ID
                            cursor.execute('SELECT id FROM building_materials WHERE name = ?', (material_name,))
                            material_result = cursor.fetchone()
                            if not material_result:
                                continue

                            material_id = material_result[0]

                            # Update source store inventory (decrease)
                            cursor.execute('''
                                           UPDATE inventory
                                           SET quantity = quantity - ?
                                           WHERE store_id = ?
                                             AND material_id = ?
                                           ''', (transfer_qty, source_store_id, material_id))

                            # Check if destination store has this item
                            cursor.execute('''
                                           SELECT quantity
                                           FROM inventory
                                           WHERE store_id = ?
                                             AND material_id = ?
                                           ''', (dest_store_id, material_id))

                            dest_inventory = cursor.fetchone()

                            if dest_inventory:
                                # Update existing inventory (increase)
                                cursor.execute('''
                                               UPDATE inventory
                                               SET quantity     = quantity + ?,
                                                   last_updated = datetime('now')
                                               WHERE store_id = ?
                                                 AND material_id = ?
                                               ''', (transfer_qty, dest_store_id, material_id))
                            else:
                                # Create new inventory record
                                cursor.execute('''
                                               INSERT INTO inventory (store_id, material_id, quantity, unit_price,
                                                                      reorder_level, last_updated)
                                               VALUES (?, ?, ?, ?, 10, datetime('now'))
                                               ''', (dest_store_id, material_id, transfer_qty, item['unit_price']))

                        conn.commit()
                        conn.close()

                        # Log the transfer
                        self.log_audit_action(
                            self.current_user['id'],
                            "Product Transfer",
                            f"Executed transfer {transfer_id}: {len(current_transfer_items)} items worth {sum(item['total_value'] for item in current_transfer_items):,.0f} FCFA from store {source_store_id} to store {dest_store_id}"
                        )

                        # Success message
                        messagebox.showinfo("Transfer Complete",
                                            f"Transfer {transfer_id} completed successfully!\n\n"
                                            f"Transferred {len(current_transfer_items)} items\n"
                                            f"Total value: {sum(item['total_value'] for item in current_transfer_items):,.0f} FCFA")

                        # Clear transfer list
                        clear_transfer_list()

                        # Refresh inventory
                        load_inventory()

                    except Exception as e:
                        messagebox.showerror("Error", f"Transfer failed: {str(e)}")

            # Clear transfer list
            def clear_transfer_list():
                current_transfer_items.clear()

                # Clear transfer list tree
                for item in transfer_list_tree.get_children():
                    transfer_list_tree.delete(item)

                # Update summary
                update_transfer_summary()

                # Clear form fields
                quantity_var.set("")
                reason_var.set("")
                notes_text.delete('1.0', 'end')
                selected_item_label.config(text="No item selected")
                max_qty_label.config(text="")

            # Remove item from transfer list
            def remove_from_transfer():
                selection = transfer_list_tree.selection()
                if not selection:
                    messagebox.showwarning("Warning", "Please select an item to remove")
                    return

                # Get selected item
                item_values = transfer_list_tree.item(selection[0])['values']
                material_name = item_values[0]

                # Remove from current_transfer_items
                current_transfer_items[:] = [item for item in current_transfer_items
                                             if item['material'] != material_name]

                # Remove from tree
                transfer_list_tree.delete(selection[0])

                # Update summary
                update_transfer_summary()

                messagebox.showinfo("Removed", f"Removed {material_name} from transfer list")

            # Load transfer history
            def load_transfer_history():
                # Clear existing items
                for item in history_tree.get_children():
                    history_tree.delete(item)

                # In a real implementation, you would load from transfers table
                # For now, show some sample data
                sample_transfers = [
                    ("T20241201120001", "2024-12-01", "Store A - Downtown", "Store B - Uptown",
                     5, "450,000", "Completed", self.current_user['full_name']),
                    ("T20241130095030", "2024-11-30", "Store B - Uptown", "Store C - Industrial",
                     3, "280,000", "Completed", self.current_user['full_name']),
                    ("T20241129143015", "2024-11-29", "Store A - Downtown", "Store C - Industrial",
                     7, "620,000", "In Transit", self.current_user['full_name']),
                ]

                for transfer in sample_transfers:
                    tags = []
                    status = transfer[6].lower().replace(' ', '_')
                    if status in ['completed', 'pending', 'in_transit', 'cancelled']:
                        tags.append(status)

                    history_tree.insert('', 'end', values=transfer, tags=tags)

            # Load pending transfers
            def load_pending_transfers():
                # Clear existing items
                for item in pending_tree.get_children():
                    pending_tree.delete(item)

                # Sample pending transfers
                sample_pending = [
                    ("T20241202100001", "2024-12-02", "Store D - Remote", 4, "320,000", "John Manager",
                     "Approve Receipt"),
                    ("T20241202110030", "2024-12-02", "Store E - Suburb", 2, "150,000", "Jane Supervisor",
                     "Confirm Delivery"),
                ]

                for transfer in sample_pending:
                    pending_tree.insert('', 'end', values=transfer)

            # Bind events
            source_store_var.trace('w', update_store_info)
            dest_store_var.trace('w', update_store_info)
            search_var.trace('w', lambda *args: load_inventory())
            category_filter_var.trace('w', lambda *args: load_inventory())

            inventory_tree.bind('<ButtonRelease-1>', on_inventory_select)

            # Right-click menu for transfer list
            def show_transfer_list_menu(event):
                selection = transfer_list_tree.selection()
                if selection:
                    context_menu = tk.Menu(transfer_window, tearoff=0)
                    context_menu.add_command(label="Remove Item", command=remove_from_transfer)
                    try:
                        context_menu.tk_popup(event.x_root, event.y_root)
                    finally:
                        context_menu.grab_release()

            transfer_list_tree.bind("<Button-3>", show_transfer_list_menu)

            # Bind button commands
            add_to_transfer_btn.config(command=add_to_transfer)
            preview_transfer_btn.config(command=preview_transfer)
            execute_transfer_btn.config(command=execute_transfer)
            clear_transfer_btn.config(command=clear_transfer_list)
            refresh_btn.config(
                command=lambda: [load_stores(), load_inventory(), load_transfer_history(), load_pending_transfers()])

            # Bind history filter events
            date_range_var.trace('w', lambda *args: load_transfer_history())
            status_filter_var.trace('w', lambda *args: load_transfer_history())

            # Double-click handlers
            history_tree.bind('<Double-1>', lambda e: view_transfer_details('history'))
            pending_tree.bind('<Double-1>', lambda e: view_transfer_details('pending'))

            # View transfer details function
            def view_transfer_details(source):
                if source == 'history':
                    selection = history_tree.selection()
                    tree = history_tree
                else:
                    selection = pending_tree.selection()
                    tree = pending_tree

                if not selection:
                    return

                transfer_id = tree.item(selection[0])['values'][0]

                # Create details window
                details_window = tk.Toplevel(transfer_window)
                details_window.title(f"Transfer Details - {transfer_id}")
                details_window.geometry("600x500")
                details_window.configure(bg='#f8f9fa')
                details_window.grab_set()
                details_window.transient(transfer_window)

                # Details content
                details_frame = tk.Frame(details_window, bg='#f8f9fa', padx=30, pady=20)
                details_frame.pack(fill='both', expand=True)

                tk.Label(details_frame, text=f"Transfer Details - {transfer_id}",
                         font=('Arial', 16, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))

                details_text = tk.Text(details_frame, height=20, width=70, font=('Arial', 10),
                                       wrap='word', state='normal', bg='white')
                details_text.pack(fill='both', expand=True, pady=(0, 15))

                # Sample transfer details
                details_content = f"""
    Transfer Information:
    Transfer ID: {transfer_id}
    Date: 2024-12-01 12:00:01
    Status: Completed

    Stores:
    From: Store A - Downtown Branch
      Location: Yaoundé Central Market
      Manager: John Doe
      Phone: +237 6XX XXX XXX

    To: Store B - Uptown Branch  
      Location: Yaoundé Bastos
      Manager: Jane Smith
      Phone: +237 6YY YYY YYY

    Transferred Items:
    1. Cement Portland - 50 bags @ 6,500 FCFA = 325,000 FCFA
    2. Steel Rebar 10mm - 20 pieces @ 6,800 FCFA = 136,000 FCFA
    3. Sand (River) - 2 cubic meters @ 15,000 FCFA = 30,000 FCFA

    Total Value: 491,000 FCFA

    Transfer Reason: Stock Rebalancing
    Notes: Emergency restocking for upcoming project
    Initiated By: {self.current_user['full_name']}
    Approved By: System (Auto-approved)

    Status Timeline:
    - Created: 2024-12-01 12:00:01
    - Approved: 2024-12-01 12:01:15  
    - In Transit: 2024-12-01 13:30:00
    - Completed: 2024-12-01 15:45:30
                """

                details_text.insert('1.0', details_content)
                details_text.config(state='disabled')

                tk.Button(details_frame, text="Close", font=('Arial', 11, 'bold'),
                          bg='#6c757d', fg='white', width=15,
                          command=details_window.destroy).pack()

            # Action buttons frame at bottom
            action_buttons_frame = tk.Frame(main_frame, bg='white')
            action_buttons_frame.pack(fill='x', pady=10)

            help_btn = tk.Button(action_buttons_frame, text="Transfer Guide", font=('Arial', 10),
                                 bg='#17a2b8', fg='white', width=12)
            help_btn.pack(side='left')

            export_all_btn = tk.Button(action_buttons_frame, text="Export All Data", font=('Arial', 10),
                                       bg='#6f42c1', fg='white', width=12)
            export_all_btn.pack(side='left', padx=(10, 0))

            close_btn = tk.Button(action_buttons_frame, text="Close", font=('Arial', 10),
                                  bg='#dc3545', fg='white', width=10,
                                  command=transfer_window.destroy)
            close_btn.pack(side='right')

            # Help function
            def show_transfer_guide():
                guide_window = tk.Toplevel(transfer_window)
                guide_window.title("Product Transfer Guide")
                guide_window.geometry("600x500")
                guide_window.configure(bg='#f8f9fa')
                guide_window.grab_set()
                guide_window.transient(transfer_window)

                guide_frame = tk.Frame(guide_window, bg='#f8f9fa', padx=30, pady=20)
                guide_frame.pack(fill='both', expand=True)

                tk.Label(guide_frame, text="Product Transfer Guide",
                         font=('Arial', 16, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))

                guide_content = """
    HOW TO TRANSFER PRODUCTS BETWEEN STORES:

    1. SELECT STORES
       • Choose source store (where products are coming from)
       • Choose destination store (where products are going to)
       • Both stores must be owned or managed by you

    2. SELECT PRODUCTS
       • Browse available inventory in source store
       • Use search and category filters to find items
       • Click on items to see details and stock levels

    3. ADD TO TRANSFER
       • Enter transfer quantity (cannot exceed available stock)
       • Select transfer reason from dropdown
       • Add optional notes for additional context
       • Click "Add to Transfer List"

    4. REVIEW & EXECUTE
       • Review all items in transfer list
       • Check total value and item count
       • Use "Preview Transfer" to see full details
       • Click "Execute Transfer" to complete

    TRANSFER REASONS:
    • Stock Rebalancing: Distribute inventory evenly
    • Store Restocking: Supply low-stock locations
    • Customer Request: Move items closer to customers
    • Seasonal Adjustment: Prepare for busy periods
    • Emergency Supply: Urgent restocking needs

    IMPORTANT NOTES:
    • Transfers update inventory in real-time
    • Source store stock decreases immediately
    • Destination store stock increases immediately
    • All transfers are logged in history
    • Managers can approve/reject incoming transfers

    PERMISSIONS:
    • Store owners can transfer between their stores
    • Store managers can receive transfers
    • All transfers require proper authorization
                """

                guide_text = tk.Text(guide_frame, height=20, width=70, font=('Arial', 9),
                                     wrap='word', state='normal', bg='white')
                guide_text.pack(fill='both', expand=True, pady=(0, 15))
                guide_text.insert('1.0', guide_content)
                guide_text.config(state='disabled')

                tk.Button(guide_frame, text="Close", font=('Arial', 11, 'bold'),
                          bg='#6c757d', fg='white', width=15,
                          command=guide_window.destroy).pack()

            help_btn.config(command=show_transfer_guide)

            # Keyboard shortcuts
            transfer_window.bind('<F5>', lambda e: [load_stores(), load_inventory(), load_transfer_history(),
                                                    load_pending_transfers()])
            transfer_window.bind('<Escape>', lambda e: transfer_window.destroy())

            # Initial data loading
            store_info = load_stores()
            load_transfer_history()
            load_pending_transfers()

            # Log the action
            self.log_audit_action(
                self.current_user['id'],
                "Access Product Transfer",
                "Opened product transfer management interface"
            )
            
            # ========== post job detail ============        
            # Note: The full implementation of show_post_job is defined earlier in this class.
            # The previous placeholder stub here has been removed to avoid overriding the functional version.
            # Removed old placeholder for show_manage_applications; see full implementation later in class.

#=============== view contract functions ==========================
    def show_view_contracts(self):
        # View Contracts window for contractors
        contracts_window = tk.Toplevel(self.root)
        contracts_window.title("View Contracts - Contractor Dashboard")
        contracts_window.geometry("1300x750")
        contracts_window.configure(bg='white')
        contracts_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(contracts_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="Contract Dashboard - Contractor View", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Filter frame
        filter_frame = tk.Frame(header_frame, bg='white')
        filter_frame.pack(side='right')

        # Status filter
        tk.Label(filter_frame, text="Status:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        status_filter_var = tk.StringVar()
        status_filter = ttk.Combobox(filter_frame, textvariable=status_filter_var, width=12, state='readonly')
        status_filter['values'] = ['All', 'Available', 'Assigned to Me', 'Active', 'Completed', 'On Hold']
        status_filter.set('All')
        status_filter.pack(side='left', padx=(0, 10))

        # Date filter
        tk.Label(filter_frame, text="Period:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        date_filter_var = tk.StringVar()
        date_filter = ttk.Combobox(filter_frame, textvariable=date_filter_var, width=12, state='readonly')
        date_filter['values'] = ['All Time', 'This Year', 'Last 6 Months', 'This Month']
        date_filter.set('All Time')
        date_filter.pack(side='left', padx=(0, 10))

        # Search entry
        tk.Label(filter_frame, text="Search:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        search_var = tk.StringVar()
        search_entry = tk.Entry(filter_frame, textvariable=search_var, font=('Arial', 10), width=15)
        search_entry.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(filter_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left')

        # Statistics frame
        stats_frame = tk.Frame(main_frame, bg='#ecf0f1', relief='raised', bd=1)
        stats_frame.pack(fill='x', pady=(0, 10))

        stats_inner = tk.Frame(stats_frame, bg='#ecf0f1')
        stats_inner.pack(pady=10)

        # Statistics labels
        available_label = tk.Label(stats_inner, text="Available: 0", font=('Arial', 10, 'bold'),
                                   bg='#ecf0f1', fg='#3498db')
        available_label.pack(side='left', padx=20)

        my_contracts_label = tk.Label(stats_inner, text="My Contracts: 0", font=('Arial', 10, 'bold'),
                                      bg='#ecf0f1', fg='#27ae60')
        my_contracts_label.pack(side='left', padx=20)

        active_label = tk.Label(stats_inner, text="Active: 0", font=('Arial', 10, 'bold'),
                                bg='#ecf0f1', fg='#e67e22')
        active_label.pack(side='left', padx=20)

        total_value_label = tk.Label(stats_inner, text="Total Value: 0 FCFA", font=('Arial', 10, 'bold'),
                                     bg='#ecf0f1', fg='#9b59b6')
        total_value_label.pack(side='left', padx=20)

        # Contracts treeview frame
        tree_frame = tk.Frame(main_frame, bg='white')
        tree_frame.pack(fill='both', expand=True, pady=(0, 20))

        # Treeview with scrollbars
        tree_scroll_y = ttk.Scrollbar(tree_frame)
        tree_scroll_y.pack(side='right', fill='y')

        tree_scroll_x = ttk.Scrollbar(tree_frame, orient='horizontal')
        tree_scroll_x.pack(side='bottom', fill='x')

        contracts_tree = ttk.Treeview(tree_frame,
                                      columns=('ID', 'Title', 'Owner', 'Budget', 'Start Date', 'End Date', 'Status',
                                               'Assignment'),
                                      show='headings',
                                      yscrollcommand=tree_scroll_y.set,
                                      xscrollcommand=tree_scroll_x.set)
        contracts_tree.pack(fill='both', expand=True)

        tree_scroll_y.config(command=contracts_tree.yview)
        tree_scroll_x.config(command=contracts_tree.xview)

        # Configure columns
        columns_config = [
            ('ID', 60, 'center'),
            ('Title', 220, 'w'),
            ('Owner', 150, 'w'),
            ('Budget', 120, 'e'),
            ('Start Date', 100, 'center'),
            ('End Date', 100, 'center'),
            ('Status', 100, 'center'),
            ('Assignment', 120, 'center')
        ]

        for col, width, anchor in columns_config:
            contracts_tree.heading(col, text=col)
            contracts_tree.column(col, width=width, anchor=anchor)

        # Configure row colors based on assignment and status
        contracts_tree.tag_configure('available', background='#e8f4fd')
        contracts_tree.tag_configure('assigned_to_me', background='#e8f5e8')
        contracts_tree.tag_configure('active', background='#fff3e0')
        contracts_tree.tag_configure('completed', background='#f3e5f5')
        contracts_tree.tag_configure('on_hold', background='#ffebee')
        contracts_tree.tag_configure('overdue', background='#ffcdd2', foreground='#d32f2f')

        # Action buttons frame
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(0, 10))

        # Left side buttons (contract actions)
        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')

        apply_btn = tk.Button(left_buttons, text="Apply for Contract", font=('Arial', 10, 'bold'),
                              bg='#28a745', fg='white', width=15)
        apply_btn.pack(side='left', padx=(0, 5))

        view_details_btn = tk.Button(left_buttons, text="View Details", font=('Arial', 10, 'bold'),
                                     bg='#17a2b8', fg='white', width=12)
        view_details_btn.pack(side='left', padx=(0, 5))

        submit_proposal_btn = tk.Button(left_buttons, text="Submit Proposal", font=('Arial', 10),
                                        bg='#fd7e14', fg='white', width=14)
        submit_proposal_btn.pack(side='left', padx=(0, 5))

        update_progress_btn = tk.Button(left_buttons, text="Update Progress", font=('Arial', 10),
                                        bg='#6f42c1', fg='white', width=14)
        update_progress_btn.pack(side='left', padx=(0, 5))

        # Right side buttons
        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')

        export_btn = tk.Button(right_buttons, text="Export My Contracts", font=('Arial', 10),
                               bg='#6c757d', fg='white', width=16)
        export_btn.pack(side='left', padx=(0, 5))

        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10),
                              bg='#dc3545', fg='white', width=10,
                              command=contracts_window.destroy)
        close_btn.pack(side='left')

        # Load and display contracts
        def load_contracts():
            # Clear existing items
            for item in contracts_tree.get_children():
                contracts_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Build query based on filters
                search_text = search_var.get().strip()
                status_filter_text = status_filter_var.get()
                date_filter_text = date_filter_var.get()

                query = '''
                        SELECT c.id,
                               c.title,
                               owner.full_name as owner_name,
                               c.budget,
                               c.start_date,
                               c.end_date,
                               c.status,
                               c.contractor_id,
                               c.created_date,
                               c.description
                        FROM contracts c
                                 JOIN users owner ON c.contract_owner_id = owner.id
                        WHERE 1 = 1
                        '''
                params = []

                # Apply status-based filters
                if status_filter_text == 'Available':
                    query += ' AND c.contractor_id IS NULL AND c.status IN ("Draft", "Pending Review")'
                elif status_filter_text == 'Assigned to Me':
                    query += ' AND c.contractor_id = ?'
                    params.append(self.current_user['id'])
                elif status_filter_text != 'All':
                    query += ' AND c.status = ?'
                    params.append(status_filter_text)

                # Apply search filter
                if search_text:
                    query += ' AND (c.title LIKE ? OR c.description LIKE ? OR owner.full_name LIKE ?)'
                    search_pattern = f'%{search_text}%'
                    params.extend([search_pattern, search_pattern, search_pattern])

                # Apply date filter
                if date_filter_text == 'This Year':
                    query += ' AND strftime("%Y", c.created_date) = strftime("%Y", "now")'
                elif date_filter_text == 'Last 6 Months':
                    query += ' AND c.created_date >= date("now", "-6 months")'
                elif date_filter_text == 'This Month':
                    query += ' AND strftime("%Y-%m", c.created_date) = strftime("%Y-%m", "now")'

                query += ' ORDER BY c.created_date DESC'

                cursor.execute(query, params)
                contracts = cursor.fetchall()

                # Statistics counters
                available_count = 0
                my_contracts_count = 0
                active_count = 0
                total_my_value = 0

                # Process each contract
                from datetime import datetime as dt, date as dt_date
                today = dt_date.today()

                for contract in contracts:
                    contract_id, title, owner, budget, start_date, end_date, status, contractor_id, created_date, description = contract

                    # Determine assignment status
                    if contractor_id == self.current_user['id']:
                        assignment_status = "Assigned to Me"
                        my_contracts_count += 1
                        if budget:
                            total_my_value += budget
                        if status == 'Active':
                            active_count += 1
                    elif contractor_id is None:
                        assignment_status = "Available"
                        available_count += 1
                    else:
                        assignment_status = "Assigned to Other"

                    # Determine row styling
                    tags = []
                    if contractor_id == self.current_user['id']:
                        tags.append('assigned_to_me')
                        if status == 'Active':
                            tags.append('active')
                        elif status == 'Completed':
                            tags.append('completed')
                        elif status == 'On Hold':
                            tags.append('on_hold')
                    elif contractor_id is None:
                        tags.append('available')

                    # Check if overdue
                    if end_date and status == 'Active' and contractor_id == self.current_user['id']:
                        try:
                            end_dt = dt.strptime(end_date, '%Y-%m-%d').date()
                            if today > end_dt:
                                tags.append('overdue')
                        except:
                            pass

                    # Format budget
                    budget_display = f"{budget:,.0f}" if budget else "0"

                    contracts_tree.insert('', 'end', values=(
                        contract_id,
                        title[:35] + '...' if len(title) > 35 else title,
                        owner,
                        budget_display,
                        start_date or 'N/A',
                        end_date or 'N/A',
                        status,
                        assignment_status
                    ), tags=tags)

                # Update statistics
                available_label.config(text=f"Available: {available_count}")
                my_contracts_label.config(text=f"My Contracts: {my_contracts_count}")
                active_label.config(text=f"Active: {active_count}")
                total_value_label.config(text=f"Total Value: {total_my_value:,.0f} FCFA")

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contracts: {str(e)}")

        # Apply for contract function
        def apply_for_contract():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to apply for")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]
            assignment_status = contracts_tree.item(selected[0])['values'][7]

            if assignment_status != "Available":
                messagebox.showwarning("Warning", "This contract is not available for application")
                return

            # Application dialog
            app_window = tk.Toplevel(contracts_window)
            app_window.title("Apply for Contract")
            app_window.geometry("600x500")
            app_window.configure(bg='#34495e')
            app_window.grab_set()
            app_window.transient(contracts_window)

            # Application form
            form_frame = tk.Frame(app_window, bg='#34495e', padx=30, pady=30)
            form_frame.pack(fill='both', expand=True)

            tk.Label(form_frame, text=f"Apply for Contract ID: {contract_id}",
                     font=('Arial', 16, 'bold'), bg='#34495e', fg='white').pack(pady=(0, 20))

            # Get contract details
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('SELECT title, budget FROM contracts WHERE id = ?', (contract_id,))
                contract_info = cursor.fetchone()
                conn.close()

                if contract_info:
                    tk.Label(form_frame, text=f"Contract: {contract_info[0]}",
                             font=('Arial', 12), bg='#34495e', fg='#ecf0f1').pack(pady=(0, 10))
                    tk.Label(form_frame, text=f"Budget: {contract_info[1]:,.0f} FCFA" if contract_info[
                        1] else "Budget: Not specified",
                             font=('Arial', 12), bg='#34495e', fg='#ecf0f1').pack(pady=(0, 20))

            except Exception as e:
                tk.Label(form_frame, text="Error loading contract details",
                         font=('Arial', 12), bg='#34495e', fg='#e74c3c').pack(pady=(0, 20))

            # Application details
            tk.Label(form_frame, text="Why are you suitable for this contract?",
                     font=('Arial', 11, 'bold'), bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            suitability_text = tk.Text(form_frame, height=4, width=60, font=('Arial', 10))
            suitability_text.pack(pady=(0, 15))

            # Experience
            tk.Label(form_frame, text="Relevant Experience:",
                     font=('Arial', 11, 'bold'), bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            experience_text = tk.Text(form_frame, height=3, width=60, font=('Arial', 10))
            experience_text.pack(pady=(0, 15))

            # Proposed timeline
            timeline_frame = tk.Frame(form_frame, bg='#34495e')
            timeline_frame.pack(fill='x', pady=(0, 15))

            tk.Label(timeline_frame, text="Proposed Completion Timeline (days):",
                     font=('Arial', 11, 'bold'), bg='#34495e', fg='white').pack(side='left')

            timeline_entry = tk.Entry(timeline_frame, font=('Arial', 11), width=10)
            timeline_entry.pack(side='right')

            def submit_application():
                suitability = suitability_text.get('1.0', 'end-1c').strip()
                experience = experience_text.get('1.0', 'end-1c').strip()
                timeline = timeline_entry.get().strip()

                if not suitability or not experience:
                    messagebox.showerror("Error", "Please fill in all required fields")
                    return

                try:
                    # In a real implementation, you might have a separate applications table
                    # For now, we'll directly assign the contractor
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    # Check if contract is still available
                    cursor.execute('SELECT contractor_id FROM contracts WHERE id = ?', (contract_id,))
                    current_contractor = cursor.fetchone()[0]

                    if current_contractor is not None:
                        messagebox.showwarning("Warning", "This contract has already been assigned")
                        conn.close()
                        app_window.destroy()
                        return

                    # Assign contract to current user
                    cursor.execute('''
                                   UPDATE contracts
                                   SET contractor_id = ?,
                                       status        = 'Active'
                                   WHERE id = ?
                                   ''', (self.current_user['id'], contract_id))

                    conn.commit()
                    conn.close()

                    # Log the action
                    self.log_audit_action(
                        self.current_user['id'],
                        "Apply for Contract",
                        f"Applied for and was assigned contract {contract_id}"
                    )

                    messagebox.showinfo("Success", "Application successful! Contract has been assigned to you.")
                    app_window.destroy()
                    load_contracts()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to submit application: {str(e)}")

            # Buttons
            btn_frame = tk.Frame(form_frame, bg='#34495e')
            btn_frame.pack(pady=(20, 0))

            tk.Button(btn_frame, text="Submit Application", font=('Arial', 11, 'bold'),
                      bg='#27ae60', fg='white', width=15,
                      command=submit_application).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Cancel", font=('Arial', 11),
                      bg='#e74c3c', fg='white', width=15,
                      command=app_window.destroy).pack(side='left')

        # View contract details function
        def view_contract_details():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to view details")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]

            # Create details window
            details_window = tk.Toplevel(contracts_window)
            details_window.title("Contract Details")
            details_window.geometry("800x650")
            details_window.configure(bg='#f8f9fa')
            details_window.grab_set()
            details_window.transient(contracts_window)

            # Load contract details
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT c.title,
                                      c.description,
                                      c.start_date,
                                      c.end_date,
                                      c.budget,
                                      c.status,
                                      c.created_date,
                                      owner.full_name as owner_name,
                                      owner.email     as owner_email,
                                      owner.phone     as owner_phone,
                                      c.contractor_id
                               FROM contracts c
                                        JOIN users owner ON c.contract_owner_id = owner.id
                               WHERE c.id = ?
                               ''', (contract_id,))

                contract_details = cursor.fetchone()
                conn.close()

                if not contract_details:
                    messagebox.showerror("Error", "Contract not found")
                    details_window.destroy()
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contract details: {str(e)}")
                details_window.destroy()
                return

            # Display contract information
            main_frame = tk.Frame(details_window, bg='#f8f9fa', padx=30, pady=20)
            main_frame.pack(fill='both', expand=True)

            # Title
            tk.Label(main_frame, text=f"Contract Details - ID: {contract_id}",
                     font=('Arial', 18, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))

            # Contract information frame
            info_frame = tk.Frame(main_frame, bg='white', relief='raised', bd=1, padx=20, pady=20)
            info_frame.pack(fill='both', expand=True, pady=(0, 20))

            # Basic information
            basic_info = [
                ("Title:", contract_details[0]),
                ("Status:", contract_details[5]),
                ("Budget:", f"{contract_details[4]:,.0f} FCFA" if contract_details[4] else "Not specified"),
                ("Start Date:", contract_details[2] or "Not specified"),
                ("End Date:", contract_details[3] or "Not specified"),
                ("Created:", contract_details[6]),
                ("Contract Owner:", contract_details[7]),
                ("Owner Email:", contract_details[8] or "Not provided"),
                ("Owner Phone:", contract_details[9] or "Not provided"),
                ("Assignment:", "Assigned to You" if contract_details[10] == self.current_user['id'] else
                "Available" if contract_details[10] is None else "Assigned to Another")
            ]

            for i, (label_text, value) in enumerate(basic_info):
                info_row = tk.Frame(info_frame, bg='white')
                info_row.pack(fill='x', pady=3)

                tk.Label(info_row, text=label_text, font=('Arial', 11, 'bold'),
                         bg='white', fg='#2c3e50', width=20, anchor='w').pack(side='left')

                tk.Label(info_row, text=str(value), font=('Arial', 11),
                         bg='white', fg='#34495e', wraplength=500, justify='left').pack(side='left', padx=(10, 0))

            # Description section
            tk.Label(info_frame, text="Project Description:", font=('Arial', 12, 'bold'),
                     bg='white', fg='#2c3e50').pack(anchor='w', pady=(20, 5))

            desc_text = tk.Text(info_frame, height=8, width=70, font=('Arial', 10),
                                wrap='word', state='normal', bg='#f8f9fa')
            desc_text.pack(fill='both', expand=True, pady=(0, 10))
            desc_text.insert('1.0', contract_details[1] or "No description provided")
            desc_text.config(state='disabled')

            # Action buttons for the contract
            btn_frame = tk.Frame(main_frame, bg='#f8f9fa')
            btn_frame.pack(pady=10)

            if contract_details[10] == self.current_user['id']:  # Assigned to current user
                tk.Button(btn_frame, text="Update Progress", font=('Arial', 11, 'bold'),
                          bg='#28a745', fg='white', width=15,
                          command=lambda: update_progress_dialog(contract_id)).pack(side='left', padx=(0, 10))

            elif contract_details[10] is None:  # Available contract
                tk.Button(btn_frame, text="Apply for Contract", font=('Arial', 11, 'bold'),
                          bg='#007bff', fg='white', width=15,
                          command=lambda: [details_window.destroy(), apply_for_contract()]).pack(side='left',
                                                                                                 padx=(0, 10))

            tk.Button(btn_frame, text="Close", font=('Arial', 11),
                      bg='#6c757d', fg='white', width=15,
                      command=details_window.destroy).pack(side='left')

        # Update progress function
        def update_progress_dialog(contract_id):
            progress_window = tk.Toplevel(contracts_window)
            progress_window.title("Update Contract Progress")
            progress_window.geometry("500x400")
            progress_window.configure(bg='#34495e')
            progress_window.grab_set()
            progress_window.transient(contracts_window)

            form_frame = tk.Frame(progress_window, bg='#34495e', padx=30, pady=30)
            form_frame.pack(fill='both', expand=True)

            tk.Label(form_frame, text=f"Update Progress - Contract {contract_id}",
                     font=('Arial', 16, 'bold'), bg='#34495e', fg='white').pack(pady=(0, 20))

            # Progress percentage
            tk.Label(form_frame, text="Completion Percentage:",
                     font=('Arial', 11, 'bold'), bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            progress_var = tk.StringVar()
            progress_entry = tk.Entry(form_frame, textvariable=progress_var, font=('Arial', 11), width=10)
            progress_entry.pack(anchor='w', pady=(0, 15))

            # Progress description
            tk.Label(form_frame, text="Progress Description:",
                     font=('Arial', 11, 'bold'), bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            progress_text = tk.Text(form_frame, height=6, width=50, font=('Arial', 10))
            progress_text.pack(pady=(0, 15))

            # Issues or challenges
            tk.Label(form_frame, text="Issues/Challenges (if any):",
                     font=('Arial', 11, 'bold'), bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            issues_text = tk.Text(form_frame, height=4, width=50, font=('Arial', 10))
            issues_text.pack(pady=(0, 20))

            def save_progress():
                try:
                    progress_pct = progress_var.get()
                    if not progress_pct:
                        messagebox.showerror("Error", "Please enter completion percentage")
                        return

                    progress_value = float(progress_pct)
                    if progress_value < 0 or progress_value > 100:
                        messagebox.showerror("Error", "Progress must be between 0 and 100")
                        return

                    progress_desc = progress_text.get('1.0', 'end-1c').strip()
                    issues = issues_text.get('1.0', 'end-1c').strip()

                    # Log progress update (in real implementation, might store in separate progress table)
                    progress_info = {
                        'progress_percentage': progress_value,
                        'description': progress_desc,
                        'issues': issues,
                        'update_date': datetime.now().isoformat()
                    }

                    self.log_audit_action(
                        self.current_user['id'],
                        "Update Contract Progress",
                        f"Updated progress for contract {contract_id}: {progress_value}% - {progress_desc[:100]}"
                    )

                    # Update contract status if completed
                    if progress_value >= 100:
                        if messagebox.askyesno("Contract Complete",
                                               "Progress is 100%. Mark contract as completed?"):
                            conn = self.db_manager.create_connection()
                            cursor = conn.cursor()
                            cursor.execute('UPDATE contracts SET status = ? WHERE id = ?',
                                           ('Completed', contract_id))
                            conn.commit()
                            conn.close()

                    messagebox.showinfo("Success", "Progress updated successfully!")
                    progress_window.destroy()
                    load_contracts()

                except ValueError:
                    messagebox.showerror("Error", "Please enter a valid percentage number")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to update progress: {str(e)}")

            # Buttons
            btn_frame = tk.Frame(form_frame, bg='#34495e')
            btn_frame.pack()

            tk.Button(btn_frame, text="Save Progress", font=('Arial', 11, 'bold'),
                      bg='#28a745', fg='white', width=15,
                      command=save_progress).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Cancel", font=('Arial', 11),
                      bg='#dc3545', fg='white', width=15,
                      command=progress_window.destroy).pack(side='left')

        # Export my contracts function
        def export_my_contracts():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".csv",
                    filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                    title="Export My Contracts"
                )

                if filename:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('''
                                   SELECT c.id,
                                          c.title,
                                          c.description,
                                          owner.full_name,
                                          c.budget,
                                          c.start_date,
                                          c.end_date,
                                          c.status,
                                          c.created_date
                                   FROM contracts c
                                            JOIN users owner ON c.contract_owner_id = owner.id
                                   WHERE c.contractor_id = ?
                                   ORDER BY c.created_date DESC
                                   ''', (self.current_user['id'],))

                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerow(
                            ['Contract ID', 'Title', 'Description', 'Owner', 'Budget', 'Start Date', 'End Date',
                             'Status', 'Created Date'])
                        writer.writerows(cursor.fetchall())

                    conn.close()
                    messagebox.showinfo("Success", f"My contracts exported to {filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to export contracts: {str(e)}")

        # Bind button commands
        apply_btn.config(command=apply_for_contract)
        view_details_btn.config(command=view_contract_details)
        update_progress_btn.config(command=lambda: update_progress_dialog(None))
        export_btn.config(command=export_my_contracts)
        refresh_btn.config(command=load_contracts)

        # Bind filter events
        def on_filter_change(*args):
            load_contracts()

        status_filter_var.trace('w', on_filter_change)
        date_filter_var.trace('w', on_filter_change)
        search_var.trace('w', on_filter_change)

        # Double-click to view details
        contracts_tree.bind('<Double-1>', lambda e: view_contract_details())

        # Right-click context menu
        def show_context_menu(event):
            selection = contracts_tree.selection()
            if selection:
                assignment_status = contracts_tree.item(selection[0])['values'][7]

                context_menu = tk.Menu(contracts_window, tearoff=0)
                context_menu.add_command(label="View Details", command=view_contract_details)

                if assignment_status == "Available":
                    context_menu.add_command(label="Apply for Contract", command=apply_for_contract)
                elif assignment_status == "Assigned to Me":
                    context_menu.add_command(label="Update Progress",
                                             command=lambda: update_progress_dialog(
                                                 contracts_tree.item(selection[0])['values'][0]))

                try:
                    context_menu.tk_popup(event.x_root, event.y_root)
                finally:
                    context_menu.grab_release()

        contracts_tree.bind("<Button-3>", show_context_menu)  # Right-click

        # Keyboard shortcuts
        contracts_window.bind('<F5>', lambda e: load_contracts())
        contracts_window.bind('<Escape>', lambda e: contracts_window.destroy())

        # Initial load
        load_contracts()

        # Log the action
        self.log_audit_action(
            self.current_user['id'],
            "View Contracts",
            "Opened contractor contract dashboard"
        )

# ================ sign contract detail ====================
    def show_sign_contracts(self):
        # Sign Contracts window for contractors
        sign_window = tk.Toplevel(self.root)
        sign_window.title("Sign Contracts - Contractor Dashboard")
        sign_window.geometry("1300x750")
        sign_window.configure(bg='white')
        sign_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(sign_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="Digital Contract Signing - Contractor", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Filter frame
        filter_frame = tk.Frame(header_frame, bg='white')
        filter_frame.pack(side='right')

        # Signature status filter
        tk.Label(filter_frame, text="Signature Status:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        signature_filter_var = tk.StringVar()
        signature_filter = ttk.Combobox(filter_frame, textvariable=signature_filter_var, width=15, state='readonly')
        signature_filter['values'] = ['All', 'Unsigned by Me', 'Signed by Me', 'Pending Owner Signature',
                                      'Fully Signed']
        signature_filter.set('All')
        signature_filter.pack(side='left', padx=(0, 10))

        # Contract status filter
        tk.Label(filter_frame, text="Status:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        status_filter_var = tk.StringVar()
        status_filter = ttk.Combobox(filter_frame, textvariable=status_filter_var, width=12, state='readonly')
        status_filter['values'] = ['All', 'Active', 'Pending Review', 'On Hold', 'Completed']
        status_filter.set('All')
        status_filter.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(filter_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left')

        # Statistics frame
        stats_frame = tk.Frame(main_frame, bg='#ecf0f1', relief='raised', bd=1)
        stats_frame.pack(fill='x', pady=(0, 10))

        stats_inner = tk.Frame(stats_frame, bg='#ecf0f1')
        stats_inner.pack(pady=10)

        # Statistics labels
        total_contracts_label = tk.Label(stats_inner, text="My Contracts: 0", font=('Arial', 10, 'bold'),
                                         bg='#ecf0f1', fg='#2c3e50')
        total_contracts_label.pack(side='left', padx=20)

        unsigned_label = tk.Label(stats_inner, text="Unsigned by Me: 0", font=('Arial', 10, 'bold'),
                                  bg='#ecf0f1', fg='#e74c3c')
        unsigned_label.pack(side='left', padx=20)

        signed_label = tk.Label(stats_inner, text="Signed by Me: 0", font=('Arial', 10, 'bold'),
                                bg='#ecf0f1', fg='#27ae60')
        signed_label.pack(side='left', padx=20)

        fully_signed_label = tk.Label(stats_inner, text="Fully Signed: 0", font=('Arial', 10, 'bold'),
                                      bg='#ecf0f1', fg='#9b59b6')
        fully_signed_label.pack(side='left', padx=20)

        # Contracts treeview frame
        tree_frame = tk.Frame(main_frame, bg='white')
        tree_frame.pack(fill='both', expand=True, pady=(0, 20))

        # Treeview with scrollbars
        tree_scroll_y = ttk.Scrollbar(tree_frame)
        tree_scroll_y.pack(side='right', fill='y')

        tree_scroll_x = ttk.Scrollbar(tree_frame, orient='horizontal')
        tree_scroll_x.pack(side='bottom', fill='x')

        contracts_tree = ttk.Treeview(tree_frame,
                                      columns=('ID', 'Title', 'Owner', 'Budget', 'Owner Signed', 'My Signature',
                                               'Status', 'Action Required'),
                                      show='headings',
                                      yscrollcommand=tree_scroll_y.set,
                                      xscrollcommand=tree_scroll_x.set)
        contracts_tree.pack(fill='both', expand=True)

        tree_scroll_y.config(command=contracts_tree.yview)
        tree_scroll_x.config(command=contracts_tree.xview)

        # Configure columns
        columns_config = [
            ('ID', 60, 'center'),
            ('Title', 220, 'w'),
            ('Owner', 150, 'w'),
            ('Budget', 120, 'e'),
            ('Owner Signed', 100, 'center'),
            ('My Signature', 100, 'center'),
            ('Status', 100, 'center'),
            ('Action Required', 120, 'center')
        ]

        for col, width, anchor in columns_config:
            contracts_tree.heading(col, text=col)
            contracts_tree.column(col, width=width, anchor=anchor)

        # Configure row colors based on signature status
        contracts_tree.tag_configure('unsigned', background='#ffebee')
        contracts_tree.tag_configure('signed_by_me', background='#e8f5e8')
        contracts_tree.tag_configure('fully_signed', background='#e3f2fd')
        contracts_tree.tag_configure('pending_owner', background='#fff3e0')
        contracts_tree.tag_configure('ready_to_sign', background='#f3e5f5')

        # Action buttons frame
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(0, 10))

        # Left side buttons (signature actions)
        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')

        sign_contract_btn = tk.Button(left_buttons, text="Sign Contract", font=('Arial', 10, 'bold'),
                                      bg='#28a745', fg='white', width=12)
        sign_contract_btn.pack(side='left', padx=(0, 5))

        view_contract_btn = tk.Button(left_buttons, text="View Contract", font=('Arial', 10, 'bold'),
                                      bg='#17a2b8', fg='white', width=12)
        view_contract_btn.pack(side='left', padx=(0, 5))

        view_signatures_btn = tk.Button(left_buttons, text="View Signatures", font=('Arial', 10),
                                        bg='#6f42c1', fg='white', width=12)
        view_signatures_btn.pack(side='left', padx=(0, 5))

        download_contract_btn = tk.Button(left_buttons, text="Download PDF", font=('Arial', 10),
                                          bg='#fd7e14', fg='white', width=12)
        download_contract_btn.pack(side='left', padx=(0, 5))

        # Right side buttons
        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')

        export_btn = tk.Button(right_buttons, text="Export Report", font=('Arial', 10),
                               bg='#6c757d', fg='white', width=12)
        export_btn.pack(side='left', padx=(0, 5))

        help_btn = tk.Button(right_buttons, text="Signing Help", font=('Arial', 10),
                             bg='#17a2b8', fg='white', width=12)
        help_btn.pack(side='left', padx=(0, 5))

        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10),
                              bg='#dc3545', fg='white', width=10,
                              command=sign_window.destroy)
        close_btn.pack(side='left')

        # Load and display contracts
        def load_contracts():
            # Clear existing items
            for item in contracts_tree.get_children():
                contracts_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Get contracts assigned to current contractor
                signature_filter_text = signature_filter_var.get()
                status_filter_text = status_filter_var.get()

                query = '''
                        SELECT c.id,
                               c.title,
                               owner.full_name as owner_name,
                               c.budget,
                               c.start_date,
                               c.end_date,
                               c.status,
                               c.digital_signature_owner,
                               c.digital_signature_contractor,
                               c.created_date
                        FROM contracts c
                                 JOIN users owner ON c.contract_owner_id = owner.id
                        WHERE c.contractor_id = ?
                        '''
                params = [self.current_user['id']]

                # Apply status filter
                if status_filter_text and status_filter_text != 'All':
                    query += ' AND c.status = ?'
                    params.append(status_filter_text)

                query += ' ORDER BY c.created_date DESC'

                cursor.execute(query, params)
                contracts = cursor.fetchall()

                # Statistics counters
                total_count = len(contracts)
                unsigned_count = 0
                signed_count = 0
                fully_signed_count = 0

                # Process each contract
                for contract in contracts:
                    contract_id, title, owner, budget, start_date, end_date, status, owner_sig, contractor_sig, created_date = contract

                    # Determine signature status
                    owner_signed = "✓ Yes" if owner_sig else "✗ No"
                    contractor_signed = "✓ Yes" if contractor_sig else "✗ No"

                    # Determine action required and overall status
                    if not contractor_sig and not owner_sig:
                        action_required = "Wait for Owner"
                        tags = ['unsigned']
                        unsigned_count += 1
                    elif not contractor_sig and owner_sig:
                        action_required = "Ready to Sign"
                        tags = ['ready_to_sign']
                        unsigned_count += 1
                    elif contractor_sig and not owner_sig:
                        action_required = "Owner to Sign"
                        tags = ['pending_owner']
                        signed_count += 1
                    else:
                        action_required = "Complete"
                        tags = ['fully_signed']
                        signed_count += 1
                        fully_signed_count += 1

                    # Apply signature status filter
                    if signature_filter_text != 'All':
                        if signature_filter_text == 'Unsigned by Me' and contractor_sig:
                            continue
                        elif signature_filter_text == 'Signed by Me' and not contractor_sig:
                            continue
                        elif signature_filter_text == 'Pending Owner Signature' and (not contractor_sig or owner_sig):
                            continue
                        elif signature_filter_text == 'Fully Signed' and (not contractor_sig or not owner_sig):
                            continue

                    # Format budget
                    budget_display = f"{budget:,.0f}" if budget else "0"

                    contracts_tree.insert('', 'end', values=(
                        contract_id,
                        title[:35] + '...' if len(title) > 35 else title,
                        owner,
                        budget_display,
                        owner_signed,
                        contractor_signed,
                        status,
                        action_required
                    ), tags=tags)

                # Update statistics
                total_contracts_label.config(text=f"My Contracts: {total_count}")
                unsigned_label.config(text=f"Unsigned by Me: {unsigned_count}")
                signed_label.config(text=f"Signed by Me: {signed_count}")
                fully_signed_label.config(text=f"Fully Signed: {fully_signed_count}")

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contracts: {str(e)}")

        # Sign contract function
        def sign_contract():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to sign")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]
            action_required = contracts_tree.item(selected[0])['values'][7]

            if action_required != "Ready to Sign":
                if action_required == "Complete":
                    messagebox.showinfo("Info", "This contract is already fully signed")
                elif action_required == "Wait for Owner":
                    messagebox.showinfo("Info", "Please wait for the contract owner to sign first")
                elif action_required == "Owner to Sign":
                    messagebox.showinfo("Info", "You have already signed this contract. Waiting for owner signature.")
                return

            # Load contract details for signing confirmation
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT c.title,
                                      c.budget,
                                      c.start_date,
                                      c.end_date,
                                      c.description,
                                      owner.full_name,
                                      c.digital_signature_contractor
                               FROM contracts c
                                        JOIN users owner ON c.contract_owner_id = owner.id
                               WHERE c.id = ?
                                 AND c.contractor_id = ?
                               ''', (contract_id, self.current_user['id']))

                contract_info = cursor.fetchone()
                conn.close()

                if not contract_info or contract_info[6]:  # Already signed
                    messagebox.showinfo("Info", "Contract not found or already signed")
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contract details: {str(e)}")
                return

            # Digital signature dialog
            sign_dialog = tk.Toplevel(sign_window)
            sign_dialog.title("Digital Contract Signature")
            sign_dialog.geometry("700x600")
            sign_dialog.configure(bg='#34495e')
            sign_dialog.grab_set()
            sign_dialog.transient(sign_window)

            # Signature form
            form_frame = tk.Frame(sign_dialog, bg='#34495e', padx=30, pady=30)
            form_frame.pack(fill='both', expand=True)

            tk.Label(form_frame, text="Digital Contract Signature",
                     font=('Arial', 18, 'bold'), bg='#34495e', fg='white').pack(pady=(0, 20))

            # Contract summary
            summary_frame = tk.LabelFrame(form_frame, text="Contract Summary",
                                          font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
            summary_frame.pack(fill='x', pady=(0, 20), padx=5)

            summary_details = [
                ("Contract ID:", str(contract_id)),
                ("Title:", contract_info[0]),
                ("Owner:", contract_info[5]),
                ("Budget:", f"{contract_info[1]:,.0f} FCFA" if contract_info[1] else "Not specified"),
                ("Duration:", f"{contract_info[2]} to {contract_info[3]}" if contract_info[2] and contract_info[
                    3] else "Not specified")
            ]

            for label_text, value in summary_details:
                detail_frame = tk.Frame(summary_frame, bg='#34495e')
                detail_frame.pack(fill='x', padx=10, pady=2)

                tk.Label(detail_frame, text=label_text, font=('Arial', 10, 'bold'),
                         bg='#34495e', fg='white', width=15, anchor='w').pack(side='left')
                tk.Label(detail_frame, text=value, font=('Arial', 10),
                         bg='#34495e', fg='#ecf0f1', wraplength=400).pack(side='left', padx=(10, 0))

            # Signature authentication
            auth_frame = tk.LabelFrame(form_frame, text="Authentication",
                                       font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
            auth_frame.pack(fill='x', pady=(0, 20), padx=5)

            # Signature method
            tk.Label(auth_frame, text="Signature Method:", font=('Arial', 11, 'bold'),
                     bg='#34495e', fg='white').pack(anchor='w', padx=10, pady=(10, 5))

            method_var = tk.StringVar(value='password')

            password_radio = tk.Radiobutton(auth_frame, text="Password Authentication",
                                            variable=method_var, value='password',
                                            bg='#34495e', fg='white', selectcolor='#2c3e50',
                                            activebackground='#34495e', font=('Arial', 10))
            password_radio.pack(anchor='w', padx=20, pady=2)

            biometric_radio = tk.Radiobutton(auth_frame, text="Biometric Verification (Future)",
                                             variable=method_var, value='biometric', state='disabled',
                                             bg='#34495e', fg='#7f8c8d', selectcolor='#2c3e50',
                                             activebackground='#34495e', font=('Arial', 10))
            biometric_radio.pack(anchor='w', padx=20, pady=2)

            # Password field
            tk.Label(auth_frame, text="Enter your account password to authenticate signature:",
                     font=('Arial', 11), bg='#34495e', fg='white').pack(anchor='w', padx=10, pady=(15, 5))

            password_entry = tk.Entry(auth_frame, show="*", font=('Arial', 11), width=40)
            password_entry.pack(padx=10, pady=(0, 10))

            # Signature terms and agreement
            terms_frame = tk.LabelFrame(form_frame, text="Terms and Agreement",
                                        font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
            terms_frame.pack(fill='x', pady=(0, 20), padx=5)

            # Agreement checkboxes
            terms_var = tk.BooleanVar()
            terms_check = tk.Checkbutton(terms_frame,
                                         text="I have read and agree to the terms and conditions of this contract",
                                         variable=terms_var, bg='#34495e', fg='white',
                                         selectcolor='#2c3e50', activebackground='#34495e',
                                         font=('Arial', 10), wraplength=600)
            terms_check.pack(anchor='w', padx=10, pady=5)

            responsibility_var = tk.BooleanVar()
            responsibility_check = tk.Checkbutton(terms_frame,
                                                  text="I understand my responsibilities and obligations under this contract",
                                                  variable=responsibility_var, bg='#34495e', fg='white',
                                                  selectcolor='#2c3e50', activebackground='#34495e',
                                                  font=('Arial', 10), wraplength=600)
            responsibility_check.pack(anchor='w', padx=10, pady=5)

            digital_consent_var = tk.BooleanVar()
            digital_consent_check = tk.Checkbutton(terms_frame,
                                                   text="I consent to using digital signatures with the same legal effect as handwritten signatures",
                                                   variable=digital_consent_var, bg='#34495e', fg='white',
                                                   selectcolor='#2c3e50', activebackground='#34495e',
                                                   font=('Arial', 10), wraplength=600)
            digital_consent_check.pack(anchor='w', padx=10, pady=5)

            # Signature comment
            tk.Label(terms_frame, text="Signature Comment (Optional):",
                     font=('Arial', 11), bg='#34495e', fg='white').pack(anchor='w', padx=10, pady=(10, 5))

            comment_text = tk.Text(terms_frame, height=3, width=60, font=('Arial', 10))
            comment_text.pack(padx=10, pady=(0, 10))

            def create_contractor_signature():
                # Validation
                password = password_entry.get()
                if not password:
                    messagebox.showerror("Error", "Password is required for signature authentication")
                    return

                if not all([terms_var.get(), responsibility_var.get(), digital_consent_var.get()]):
                    messagebox.showerror("Error", "You must agree to all terms before signing")
                    return

                # Verify password
                password_hash = self.security_manager.hash_password(password)

                try:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('SELECT password_hash FROM users WHERE id = ?', (self.current_user['id'],))
                    stored_hash = cursor.fetchone()[0]

                    if password_hash != stored_hash:
                        messagebox.showerror("Error", "Invalid password. Please try again.")
                        conn.close()
                        return

                    # Check if contract is still available for signing
                    cursor.execute(
                        'SELECT digital_signature_contractor FROM contracts WHERE id = ? AND contractor_id = ?',
                        (contract_id, self.current_user['id']))
                    current_signature = cursor.fetchone()

                    if not current_signature:
                        messagebox.showerror("Error", "Contract not found or access denied")
                        conn.close()
                        return

                    if current_signature[0]:
                        messagebox.showinfo("Info", "You have already signed this contract")
                        conn.close()
                        sign_dialog.destroy()
                        return

                    # Create digital signature
                    from datetime import datetime
                    signature_data = {
                        'signer_id': self.current_user['id'],
                        'signer_name': self.current_user['full_name'],
                        'signer_role': 'contractor',
                        'timestamp': datetime.now().isoformat(),
                        'method': method_var.get(),
                        'comment': comment_text.get('1.0', 'end-1c').strip(),
                        'ip_address': 'localhost',  # In real implementation, get actual IP
                        'contract_id': contract_id,
                        'terms_agreed': True,
                        'responsibility_accepted': True,
                        'digital_consent': True
                    }

                    # Encrypt signature data
                    signature_json = json.dumps(signature_data)
                    encrypted_signature = self.security_manager.encrypt_data(signature_json)

                    # Update contract with contractor signature
                    cursor.execute('''
                                   UPDATE contracts
                                   SET digital_signature_contractor = ?
                                   WHERE id = ?
                                     AND contractor_id = ?
                                   ''', (encrypted_signature, contract_id, self.current_user['id']))

                    conn.commit()
                    try:
                        self.ensure_contract_active_if_fully_signed(contract_id)
                    except Exception:
                        pass
                    conn.close()

                    # Log the signature action
                    self.log_audit_action(
                        self.current_user['id'],
                        "Digital Signature - Contractor",
                        f"Signed contract '{contract_info[0]}' (ID: {contract_id}) as contractor"
                    )

                    # Success message with next steps
                    success_message = (
                        f"Contract signed successfully!\n\n"
                        f"Contract: {contract_info[0]}\n"
                        f"Signed by: {self.current_user['full_name']}\n"
                        f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                        f"The contract is now digitally signed by you. "
                        f"Both parties will be notified once all signatures are complete."
                    )

                    messagebox.showinfo("Signature Complete", success_message)
                    sign_dialog.destroy()
                    load_contracts()

                    # Send notification to contract owner (in real implementation)
                    try:
                        # This would send email/SMS notification to contract owner
                        pass
                    except:
                        pass

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to create signature: {str(e)}")

            # Buttons
            btn_frame = tk.Frame(form_frame, bg='#34495e')
            btn_frame.pack(pady=(20, 0))

            tk.Button(btn_frame, text="Sign Contract", font=('Arial', 12, 'bold'),
                      bg='#28a745', fg='white', width=15, height=2,
                      command=create_contractor_signature).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Cancel", font=('Arial', 12),
                      bg='#dc3545', fg='white', width=15, height=2,
                      command=sign_dialog.destroy).pack(side='left')

            # Set focus to password entry
            password_entry.focus()

        # View contract function
        def view_contract():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to view")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]

            # Create contract view window
            view_window = tk.Toplevel(sign_window)
            view_window.title(f"Contract Details - ID: {contract_id}")
            view_window.geometry("900x700")
            view_window.configure(bg='#f8f9fa')
            view_window.grab_set()
            view_window.transient(sign_window)

            # Load full contract details
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT c.title,
                                      c.description,
                                      c.start_date,
                                      c.end_date,
                                      c.budget,
                                      c.status,
                                      c.created_date,
                                      c.digital_signature_owner,
                                      c.digital_signature_contractor,
                                      owner.full_name,
                                      owner.email,
                                      owner.phone
                               FROM contracts c
                                        JOIN users owner ON c.contract_owner_id = owner.id
                               WHERE c.id = ?
                                 AND c.contractor_id = ?
                               ''', (contract_id, self.current_user['id']))

                contract_data = cursor.fetchone()
                conn.close()

                if not contract_data:
                    messagebox.showerror("Error", "Contract not found or access denied")
                    view_window.destroy()
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load contract: {str(e)}")
                view_window.destroy()
                return

            # Display contract content
            main_frame = tk.Frame(view_window, bg='#f8f9fa', padx=30, pady=20)
            main_frame.pack(fill='both', expand=True)

            # Title
            tk.Label(main_frame, text=f"Contract Details - ID: {contract_id}",
                     font=('Arial', 18, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))

            # Contract information in scrollable frame
            canvas = tk.Canvas(main_frame, bg='#f8f9fa')
            scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg='#f8f9fa')

            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )

            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)

            # Basic information
            basic_frame = tk.LabelFrame(scrollable_frame, text="Basic Information",
                                        font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            basic_frame.pack(fill='x', pady=(0, 15), padx=10)

            basic_info = [
                ("Contract Title:", contract_data[0]),
                ("Status:", contract_data[5]),
                ("Budget:", f"{contract_data[4]:,.0f} FCFA" if contract_data[4] else "Not specified"),
                ("Start Date:", contract_data[2] or "Not specified"),
                ("End Date:", contract_data[3] or "Not specified"),
                ("Created Date:", contract_data[6]),
                ("Contract Owner:", contract_data[9]),
                ("Owner Email:", contract_data[10] or "Not provided"),
                ("Owner Phone:", contract_data[11] or "Not provided")
            ]

            for label_text, value in basic_info:
                info_frame = tk.Frame(basic_frame, bg='#f8f9fa')
                info_frame.pack(fill='x', padx=10, pady=3)

                tk.Label(info_frame, text=label_text, font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#2c3e50', width=18, anchor='w').pack(side='left')
                tk.Label(info_frame, text=str(value), font=('Arial', 11),
                         bg='#f8f9fa', fg='#34495e', wraplength=500).pack(side='left', padx=(10, 0))

            # Description section
            desc_frame = tk.LabelFrame(scrollable_frame, text="Project Description",
                                       font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            desc_frame.pack(fill='both', expand=True, pady=(0, 15), padx=10)

            desc_text = tk.Text(desc_frame, height=8, width=80, font=('Arial', 10),
                                wrap='word', state='normal', bg='white')
            desc_text.pack(fill='both', expand=True, padx=10, pady=10)
            desc_text.insert('1.0', contract_data[1] or "No description provided")
            desc_text.config(state='disabled')

            # Signature status section
            sig_frame = tk.LabelFrame(scrollable_frame, text="Digital Signature Status",
                                      font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            sig_frame.pack(fill='x', pady=(0, 15), padx=10)

            # Owner signature status
            owner_sig_frame = tk.Frame(sig_frame, bg='#f8f9fa')
            owner_sig_frame.pack(fill='x', padx=10, pady=5)

            if contract_data[7]:  # Owner signature exists
                tk.Label(owner_sig_frame, text="✓ Contract Owner:", font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#27ae60').pack(side='left')
                tk.Label(owner_sig_frame, text="Digitally Signed", font=('Arial', 11),
                         bg='#f8f9fa', fg='#27ae60').pack(side='left', padx=(10, 0))
            else:
                tk.Label(owner_sig_frame, text="✗ Contract Owner:", font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#e74c3c').pack(side='left')
                tk.Label(owner_sig_frame, text="Not Signed", font=('Arial', 11),
                         bg='#f8f9fa', fg='#e74c3c').pack(side='left', padx=(10, 0))

            # Contractor signature status
            contractor_sig_frame = tk.Frame(sig_frame, bg='#f8f9fa')
            contractor_sig_frame.pack(fill='x', padx=10, pady=5)

            if contract_data[8]:  # Contractor signature exists
                tk.Label(contractor_sig_frame, text="✓ Contractor (You):", font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#27ae60').pack(side='left')
                tk.Label(contractor_sig_frame, text="Digitally Signed", font=('Arial', 11),
                         bg='#f8f9fa', fg='#27ae60').pack(side='left', padx=(10, 0))
            else:
                tk.Label(contractor_sig_frame, text="✗ Contractor (You):", font=('Arial', 11, 'bold'),
                         bg='#f8f9fa', fg='#e74c3c').pack(side='left')
                tk.Label(contractor_sig_frame, text="Not Signed", font=('Arial', 11),
                         bg='#f8f9fa', fg='#e74c3c').pack(side='left', padx=(10, 0))

            # Pack canvas and scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")

            # Close button
            tk.Button(main_frame, text="Close", font=('Arial', 12, 'bold'),
                      bg='#6c757d', fg='white', width=15,
                      command=view_window.destroy).pack(pady=20)

            # Mouse wheel scrolling
            def on_mousewheel(event):
                canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

            canvas.bind("<MouseWheel>", on_mousewheel)

        # View signatures function
        def view_signatures():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to view signatures")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]

            # Load signature data
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT c.title,
                                      c.digital_signature_owner,
                                      c.digital_signature_contractor,
                                      owner.full_name
                               FROM contracts c
                                        JOIN users owner ON c.contract_owner_id = owner.id
                               WHERE c.id = ?
                                 AND c.contractor_id = ?
                               ''', (contract_id, self.current_user['id']))

                signature_data = cursor.fetchone()
                conn.close()

                if not signature_data:
                    messagebox.showerror("Error", "Contract not found")
                    return

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load signature data: {str(e)}")
                return

            # Create signatures view window
            sig_view_window = tk.Toplevel(sign_window)
            sig_view_window.title("Digital Signatures Details")
            sig_view_window.geometry("800x600")
            sig_view_window.configure(bg='#f8f9fa')
            sig_view_window.grab_set()
            sig_view_window.transient(sign_window)

            # Main content
            main_frame = tk.Frame(sig_view_window, bg='#f8f9fa', padx=30, pady=20)
            main_frame.pack(fill='both', expand=True)

            # Title
            tk.Label(main_frame, text=f"Digital Signatures - Contract ID: {contract_id}",
                     font=('Arial', 16, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 10))

            tk.Label(main_frame, text=f"Contract: {signature_data[0]}",
                     font=('Arial', 12), bg='#f8f9fa', fg='#34495e').pack(pady=(0, 20))

            # Owner signature section
            owner_frame = tk.LabelFrame(main_frame, text="Contract Owner Signature",
                                        font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            owner_frame.pack(fill='x', pady=(0, 20), padx=10, ipady=10)

            if signature_data[1]:  # Owner signature exists
                try:
                    decrypted_data = self.security_manager.decrypt_data(signature_data[1])
                    owner_sig_info = json.loads(decrypted_data)

                    tk.Label(owner_frame, text=f"✓ Signed by: {owner_sig_info['signer_name']}",
                             font=('Arial', 11, 'bold'), bg='#f8f9fa', fg='#27ae60').pack(anchor='w', padx=10)

                    tk.Label(owner_frame, text=f"Timestamp: {owner_sig_info['timestamp']}",
                             font=('Arial', 10), bg='#f8f9fa', fg='#34495e').pack(anchor='w', padx=10)

                    tk.Label(owner_frame, text=f"Method: {owner_sig_info['method'].title()}",
                             font=('Arial', 10), bg='#f8f9fa', fg='#34495e').pack(anchor='w', padx=10)

                    if owner_sig_info.get('comment'):
                        tk.Label(owner_frame, text=f"Comment: {owner_sig_info['comment']}",
                                 font=('Arial', 10), bg='#f8f9fa', fg='#34495e',
                                 wraplength=600).pack(anchor='w', padx=10, pady=(5, 0))

                except Exception as e:
                    tk.Label(owner_frame, text="✗ Error reading signature data",
                             font=('Arial', 11), bg='#f8f9fa', fg='#e74c3c').pack(anchor='w', padx=10)
            else:
                tk.Label(owner_frame, text="✗ Not signed",
                         font=('Arial', 11), bg='#f8f9fa', fg='#e74c3c').pack(anchor='w', padx=10)

            # Contractor signature section
            contractor_frame = tk.LabelFrame(main_frame, text="Contractor Signature (You)",
                                             font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            contractor_frame.pack(fill='x', pady=(0, 20), padx=10, ipady=10)

            if signature_data[2]:  # Contractor signature exists
                try:
                    decrypted_data = self.security_manager.decrypt_data(signature_data[2])
                    contractor_sig_info = json.loads(decrypted_data)

                    tk.Label(contractor_frame, text=f"✓ Signed by: {contractor_sig_info['signer_name']}",
                             font=('Arial', 11, 'bold'), bg='#f8f9fa', fg='#27ae60').pack(anchor='w', padx=10)

                    tk.Label(contractor_frame, text=f"Timestamp: {contractor_sig_info['timestamp']}",
                             font=('Arial', 10), bg='#f8f9fa', fg='#34495e').pack(anchor='w', padx=10)

                    tk.Label(contractor_frame, text=f"Method: {contractor_sig_info['method'].title()}",
                             font=('Arial', 10), bg='#f8f9fa', fg='#34495e').pack(anchor='w', padx=10)

                    if contractor_sig_info.get('comment'):
                        tk.Label(contractor_frame, text=f"Comment: {contractor_sig_info['comment']}",
                                 font=('Arial', 10), bg='#f8f9fa', fg='#34495e',
                                 wraplength=600).pack(anchor='w', padx=10, pady=(5, 0))

                except Exception as e:
                    tk.Label(contractor_frame, text="✗ Error reading signature data",
                             font=('Arial', 11), bg='#f8f9fa', fg='#e74c3c').pack(anchor='w', padx=10)
            else:
                tk.Label(contractor_frame, text="✗ Not signed",
                         font=('Arial', 11), bg='#f8f9fa', fg='#e74c3c').pack(anchor='w', padx=10)

            # Verification status
            verification_frame = tk.LabelFrame(main_frame, text="Signature Verification",
                                               font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            verification_frame.pack(fill='x', pady=(0, 20), padx=10, ipady=10)

            if signature_data[1] and signature_data[2]:
                tk.Label(verification_frame, text="✓ Contract is fully signed and legally binding",
                         font=('Arial', 11, 'bold'), bg='#f8f9fa', fg='#27ae60').pack(anchor='w', padx=10)
            elif signature_data[1] or signature_data[2]:
                tk.Label(verification_frame, text="⚠ Contract is partially signed - awaiting remaining signature",
                         font=('Arial', 11, 'bold'), bg='#f8f9fa', fg='#f39c12').pack(anchor='w', padx=10)
            else:
                tk.Label(verification_frame, text="✗ Contract is not signed by either party",
                         font=('Arial', 11, 'bold'), bg='#f8f9fa', fg='#e74c3c').pack(anchor='w', padx=10)

            # Close button
            tk.Button(main_frame, text="Close", font=('Arial', 11, 'bold'),
                      bg='#6c757d', fg='white', width=15,
                      command=sig_view_window.destroy).pack(pady=20)

        # Download contract as PDF function
        def download_contract():
            selected = contracts_tree.selection()
            if not selected:
                messagebox.showwarning("Warning", "Please select a contract to download")
                return

            contract_id = contracts_tree.item(selected[0])['values'][0]

            try:
                # Get contract details
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT c.title,
                                      c.description,
                                      c.start_date,
                                      c.end_date,
                                      c.budget,
                                      c.status,
                                      c.digital_signature_owner,
                                      c.digital_signature_contractor,
                                      owner.full_name,
                                      owner.email
                               FROM contracts c
                                        JOIN users owner ON c.contract_owner_id = owner.id
                               WHERE c.id = ?
                                 AND c.contractor_id = ?
                               ''', (contract_id, self.current_user['id']))

                contract_details = cursor.fetchone()
                conn.close()

                if not contract_details:
                    messagebox.showerror("Error", "Contract not found")
                    return

                # Save as text file (in real implementation, would generate PDF)
                filename = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("Text files", "*.txt"), ("PDF files", "*.pdf"), ("All files", "*.*")],
                    title="Save Contract",
                    initialname=f"Contract_{contract_id}_{contract_details[0].replace(' ', '_')}"
                )

                if filename:
                    from datetime import datetime

                    # Create contract content
                    contract_content = f"""
    BUILDING PROJECT CONTRACT

    Contract ID: {contract_id}
    Contract Title: {contract_details[0]}
    Status: {contract_details[5]}

    PARTIES:
    Contract Owner: {contract_details[8]}
    Owner Email: {contract_details[9]}
    Contractor: {self.current_user['full_name']}

    PROJECT DETAILS:
    Budget: {contract_details[4]:,.0f} FCFA
    Start Date: {contract_details[2]}
    End Date: {contract_details[3]}

    PROJECT DESCRIPTION:
    {contract_details[1]}

    DIGITAL SIGNATURES:
    Owner Signature: {'✓ SIGNED' if contract_details[6] else '✗ NOT SIGNED'}
    Contractor Signature: {'✓ SIGNED' if contract_details[7] else '✗ NOT SIGNED'}

    Contract Status: {'FULLY EXECUTED' if contract_details[6] and contract_details[7] else 'PENDING SIGNATURES'}

    ---
    This contract was generated from the Cameroon Building Project Management System.
    Document generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    Generated by: {self.current_user['full_name']}
    """

                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(contract_content)

                    messagebox.showinfo("Success", f"Contract saved to {filename}")

                    # Log the action
                    self.log_audit_action(
                        self.current_user['id'],
                        "Download Contract",
                        f"Downloaded contract {contract_id} as {filename}"
                    )

            except Exception as e:
                messagebox.showerror("Error", f"Failed to download contract: {str(e)}")

        # Export report function
        def export_report():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".csv",
                    filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                    title="Export Signature Report"
                )

                if filename:
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()
                    cursor.execute('''
                                   SELECT c.id,
                                          c.title,
                                          owner.full_name,
                                          CASE
                                              WHEN c.digital_signature_owner IS NOT NULL THEN 'Signed'
                                              ELSE 'Not Signed' END,
                                          CASE
                                              WHEN c.digital_signature_contractor IS NOT NULL THEN 'Signed'
                                              ELSE 'Not Signed' END,
                                          c.budget,
                                          c.status,
                                          c.start_date,
                                          c.end_date
                                   FROM contracts c
                                            JOIN users owner ON c.contract_owner_id = owner.id
                                   WHERE c.contractor_id = ?
                                   ORDER BY c.created_date DESC
                                   ''', (self.current_user['id'],))

                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerow(['Contract ID', 'Title', 'Owner', 'Owner Signature', 'My Signature',
                                         'Budget', 'Status', 'Start Date', 'End Date'])
                        writer.writerows(cursor.fetchall())

                    conn.close()
                    messagebox.showinfo("Success", f"Signature report exported to {filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to export report: {str(e)}")

        # Show signing help function
        def show_signing_help():
            help_window = tk.Toplevel(sign_window)
            help_window.title("Digital Signing Help")
            help_window.geometry("600x500")
            help_window.configure(bg='#f8f9fa')
            help_window.grab_set()
            help_window.transient(sign_window)

            main_frame = tk.Frame(help_window, bg='#f8f9fa', padx=30, pady=20)
            main_frame.pack(fill='both', expand=True)

            tk.Label(main_frame, text="Digital Contract Signing Help",
                     font=('Arial', 16, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))

            help_content = """
    How to Sign Contracts Digitally:

    1. REVIEW THE CONTRACT
       • Read the contract details carefully
       • Check project description, timeline, and budget
       • Verify owner contact information

    2. SIGNATURE PROCESS
       • Select a contract marked "Ready to Sign"
       • Click "Sign Contract" button
       • Review the contract summary
       • Enter your account password for authentication
       • Check all agreement boxes
       • Add optional signature comment
       • Click "Sign Contract" to complete

    3. SIGNATURE STATUS
       • Red (✗): Not signed by you
       • Green (✓): Already signed by you
       • "Ready to Sign": Owner signed, waiting for you
       • "Wait for Owner": Owner must sign first

    4. LEGAL VALIDITY
       • Digital signatures have the same legal effect as handwritten signatures
       • Your signature is encrypted and securely stored
       • Timestamps provide proof of when you signed
       • Both parties receive notifications when fully signed

    5. SECURITY FEATURES
       • Password authentication required
       • Encrypted signature storage
       • Audit trail maintenance
       • IP address logging

    6. AFTER SIGNING
       • Contract becomes legally binding once both parties sign
       • You can download a copy for your records
       • Track project progress through your dashboard
       • Receive notifications for important updates

    Need more help? Contact system administrator.
    """

            help_text = tk.Text(main_frame, height=20, width=70, font=('Arial', 10),
                                wrap='word', state='normal', bg='white')
            help_text.pack(fill='both', expand=True, pady=(0, 20))
            help_text.insert('1.0', help_content)
            help_text.config(state='disabled')

            tk.Button(main_frame, text="Close", font=('Arial', 11, 'bold'),
                      bg='#6c757d', fg='white', width=15,
                      command=help_window.destroy).pack()

        # Bind button commands
        sign_contract_btn.config(command=sign_contract)
        view_contract_btn.config(command=view_contract)
        view_signatures_btn.config(command=view_signatures)
        download_contract_btn.config(command=download_contract)
        export_btn.config(command=export_report)
        help_btn.config(command=show_signing_help)
        refresh_btn.config(command=load_contracts)

        # Bind filter events
        def on_filter_change(*args):
            load_contracts()

        signature_filter_var.trace('w', on_filter_change)
        status_filter_var.trace('w', on_filter_change)

        # Double-click to view contract
        contracts_tree.bind('<Double-1>', lambda e: view_contract())

        # Right-click context menu
        def show_context_menu(event):
            selection = contracts_tree.selection()
            if selection:
                action_required = contracts_tree.item(selection[0])['values'][7]

                context_menu = tk.Menu(sign_window, tearoff=0)
                context_menu.add_command(label="View Contract", command=view_contract)
                context_menu.add_command(label="View Signatures", command=view_signatures)

                if action_required == "Ready to Sign":
                    context_menu.add_separator()
                    context_menu.add_command(label="Sign Contract", command=sign_contract)

                context_menu.add_separator()
                context_menu.add_command(label="Download Contract", command=download_contract)

                try:
                    context_menu.tk_popup(event.x_root, event.y_root)
                finally:
                    context_menu.grab_release()

        contracts_tree.bind("<Button-3>", show_context_menu)  # Right-click

        # Keyboard shortcuts
        sign_window.bind('<F5>', lambda e: load_contracts())
        sign_window.bind('<Escape>', lambda e: sign_window.destroy())

        # Initial load
        load_contracts()

        # Log the action
        self.log_audit_action(
            self.current_user['id'],
            "Access Contract Signing",
            "Opened contract signing interface"
        )

#===================== show material reports functions ===================
    def _impl_show_material_reports(self):
        # Material Reports window for contractors
        try:
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Access Denied", "You must be logged in to view material reports.")
                return
            if self.current_user.get('role') not in ("contractor", "administrator", "contract_owner"):
                messagebox.showwarning("Access Denied", "Only contractors (or admins/owners) can access Material Reports.")
                return
        except Exception:
            pass
        reports_window = tk.Toplevel(self.root)
        reports_window.title("Material Reports - Contractor Dashboard")
        reports_window.geometry("1400x800")
        reports_window.configure(bg='white')
        reports_window.grab_set()  # Make modal

        # Main container
        main_frame = tk.Frame(reports_window, bg='white', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)

        # Title and controls frame
        header_frame = tk.Frame(main_frame, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))

        # Title
        tk.Label(header_frame, text="Material Reports & Analysis", font=('Arial', 18, 'bold'),
                 bg='white', fg='#2c3e50').pack(side='left')

        # Filter and control frame
        filter_frame = tk.Frame(header_frame, bg='white')
        filter_frame.pack(side='right')

        # Contract filter
        tk.Label(filter_frame, text="Contract:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        contract_filter_var = tk.StringVar()
        contract_filter = ttk.Combobox(filter_frame, textvariable=contract_filter_var, width=25, state='readonly')
        contract_filter.pack(side='left', padx=(0, 10))

        # Report type filter
        tk.Label(filter_frame, text="Report Type:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        report_type_var = tk.StringVar()
        report_type = ttk.Combobox(filter_frame, textvariable=report_type_var, width=15, state='readonly')
        report_type['values'] = ['All Reports', 'Material Usage', 'Cost Analysis', 'Requirements', 'Inventory Status']
        report_type.set('All Reports')
        report_type.pack(side='left', padx=(0, 10))

        # Date range filter
        tk.Label(filter_frame, text="Period:", font=('Arial', 10),
                 bg='white').pack(side='left', padx=(0, 5))
        date_filter_var = tk.StringVar()
        date_filter = ttk.Combobox(filter_frame, textvariable=date_filter_var, width=12, state='readonly')
        date_filter['values'] = ['All Time', 'This Month', 'Last 3 Months', 'Last 6 Months', 'This Year']
        date_filter.set('This Month')
        date_filter.pack(side='left', padx=(0, 10))

        # Refresh button
        refresh_btn = tk.Button(filter_frame, text="Refresh", font=('Arial', 10),
                                bg='#3498db', fg='white', width=8)
        refresh_btn.pack(side='left')

        # Create notebook for different report sections
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill='both', expand=True, pady=(0, 10))

        # Tab 1: Material Usage Overview
        usage_frame = tk.Frame(notebook, bg='white')
        notebook.add(usage_frame, text="Material Usage")

        # Tab 2: Cost Analysis
        cost_frame = tk.Frame(notebook, bg='white')
        notebook.add(cost_frame, text="Cost Analysis")

        # Tab 3: Material Requirements
        requirements_frame = tk.Frame(notebook, bg='white')
        notebook.add(requirements_frame, text="Requirements")

        # Tab 4: Supplier Information
        suppliers_frame = tk.Frame(notebook, bg='white')
        notebook.add(suppliers_frame, text="Suppliers")

        # =================== TAB 1: MATERIAL USAGE OVERVIEW ===================
        usage_main = tk.Frame(usage_frame, bg='white', padx=10, pady=10)
        usage_main.pack(fill='both', expand=True)

        # Usage statistics frame
        usage_stats_frame = tk.Frame(usage_main, bg='#ecf0f1', relief='raised', bd=1)
        usage_stats_frame.pack(fill='x', pady=(0, 10))

        usage_stats_inner = tk.Frame(usage_stats_frame, bg='#ecf0f1')
        usage_stats_inner.pack(pady=10)

        # Statistics labels
        total_materials_label = tk.Label(usage_stats_inner, text="Total Materials: 0", font=('Arial', 10, 'bold'),
                                         bg='#ecf0f1', fg='#2c3e50')
        total_materials_label.pack(side='left', padx=20)

        total_value_label = tk.Label(usage_stats_inner, text="Total Value: 0 FCFA", font=('Arial', 10, 'bold'),
                                     bg='#ecf0f1', fg='#27ae60')
        total_value_label.pack(side='left', padx=20)

        categories_label = tk.Label(usage_stats_inner, text="Categories: 0", font=('Arial', 10, 'bold'),
                                    bg='#ecf0f1', fg='#3498db')
        categories_label.pack(side='left', padx=20)

        avg_cost_label = tk.Label(usage_stats_inner, text="Avg Cost/Item: 0 FCFA", font=('Arial', 10, 'bold'),
                                  bg='#ecf0f1', fg='#e67e22')
        avg_cost_label.pack(side='left', padx=20)

        # Material usage treeview
        usage_tree_frame = tk.Frame(usage_main, bg='white')
        usage_tree_frame.pack(fill='both', expand=True)

        usage_scroll_y = ttk.Scrollbar(usage_tree_frame)
        usage_scroll_y.pack(side='right', fill='y')

        usage_scroll_x = ttk.Scrollbar(usage_tree_frame, orient='horizontal')
        usage_scroll_x.pack(side='bottom', fill='x')

        usage_tree = ttk.Treeview(usage_tree_frame,
                                  columns=('Material', 'Category', 'Unit', 'Quantity', 'Unit Price', 'Total Cost',
                                           'Supplier'),
                                  show='headings',
                                  yscrollcommand=usage_scroll_y.set,
                                  xscrollcommand=usage_scroll_x.set)
        usage_tree.pack(fill='both', expand=True)

        usage_scroll_y.config(command=usage_tree.yview)
        usage_scroll_x.config(command=usage_tree.xview)

        # Configure usage tree columns
        usage_columns_config = [
            ('Material', 200, 'w'),
            ('Category', 120, 'center'),
            ('Unit', 80, 'center'),
            ('Quantity', 100, 'e'),
            ('Unit Price', 120, 'e'),
            ('Total Cost', 120, 'e'),
            ('Supplier', 150, 'w')
        ]

        for col, width, anchor in usage_columns_config:
            usage_tree.heading(col, text=col)
            usage_tree.column(col, width=width, anchor=anchor)

        # =================== TAB 2: COST ANALYSIS ===================
        cost_main = tk.Frame(cost_frame, bg='white', padx=10, pady=10)
        cost_main.pack(fill='both', expand=True)

        # Cost breakdown by category
        cost_category_frame = tk.LabelFrame(cost_main, text="Cost Breakdown by Category",
                                            font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
        cost_category_frame.pack(fill='both', expand=True, pady=(0, 10))

        cost_tree_frame = tk.Frame(cost_category_frame, bg='white')
        cost_tree_frame.pack(fill='both', expand=True, padx=10, pady=10)

        cost_scroll_y = ttk.Scrollbar(cost_tree_frame)
        cost_scroll_y.pack(side='right', fill='y')

        cost_tree = ttk.Treeview(cost_tree_frame,
                                 columns=('Category', 'Materials', 'Total Quantity', 'Total Cost', 'Percentage',
                                          'Avg Unit Cost'),
                                 show='headings',
                                 yscrollcommand=cost_scroll_y.set)
        cost_tree.pack(fill='both', expand=True)

        cost_scroll_y.config(command=cost_tree.yview)

        # Configure cost tree columns
        cost_columns_config = [
            ('Category', 150, 'w'),
            ('Materials', 100, 'center'),
            ('Total Quantity', 120, 'e'),
            ('Total Cost', 150, 'e'),
            ('Percentage', 100, 'center'),
            ('Avg Unit Cost', 120, 'e')
        ]

        for col, width, anchor in cost_columns_config:
            cost_tree.heading(col, text=col)
            cost_tree.column(col, width=width, anchor=anchor)

        # Cost summary section
        cost_summary_frame = tk.LabelFrame(cost_main, text="Cost Summary",
                                           font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
        cost_summary_frame.pack(fill='x', pady=(0, 10))

        cost_summary_inner = tk.Frame(cost_summary_frame, bg='white')
        cost_summary_inner.pack(pady=10, padx=10)

        # Cost summary labels (will be updated dynamically)
        highest_cost_label = tk.Label(cost_summary_inner, text="Highest Cost Category: N/A",
                                      font=('Arial', 10), bg='white', fg='#e74c3c')
        highest_cost_label.pack(anchor='w')

        lowest_cost_label = tk.Label(cost_summary_inner, text="Lowest Cost Category: N/A",
                                     font=('Arial', 10), bg='white', fg='#27ae60')
        lowest_cost_label.pack(anchor='w')

        budget_status_label = tk.Label(cost_summary_inner, text="Budget Status: N/A",
                                       font=('Arial', 10, 'bold'), bg='white', fg='#3498db')
        budget_status_label.pack(anchor='w')

        # =================== TAB 3: MATERIAL REQUIREMENTS ===================
        req_main = tk.Frame(requirements_frame, bg='white', padx=10, pady=10)
        req_main.pack(fill='both', expand=True)

        # Requirements by contract
        req_contract_frame = tk.LabelFrame(req_main, text="Material Requirements by Contract",
                                           font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
        req_contract_frame.pack(fill='both', expand=True, pady=(0, 10))

        req_tree_frame = tk.Frame(req_contract_frame, bg='white')
        req_tree_frame.pack(fill='both', expand=True, padx=10, pady=10)

        req_scroll_y = ttk.Scrollbar(req_tree_frame)
        req_scroll_y.pack(side='right', fill='y')

        req_scroll_x = ttk.Scrollbar(req_tree_frame, orient='horizontal')
        req_scroll_x.pack(side='bottom', fill='x')

        req_tree = ttk.Treeview(req_tree_frame,
                                columns=('Contract', 'Material', 'Required Qty', 'Unit', 'Status', 'Estimated Cost',
                                         'Deadline'),
                                show='headings',
                                yscrollcommand=req_scroll_y.set,
                                xscrollcommand=req_scroll_x.set)
        req_tree.pack(fill='both', expand=True)

        req_scroll_y.config(command=req_tree.yview)
        req_scroll_x.config(command=req_tree.xview)

        # Configure requirements tree columns
        req_columns_config = [
            ('Contract', 150, 'w'),
            ('Material', 200, 'w'),
            ('Required Qty', 100, 'e'),
            ('Unit', 80, 'center'),
            ('Status', 100, 'center'),
            ('Estimated Cost', 120, 'e'),
            ('Deadline', 100, 'center')
        ]

        for col, width, anchor in req_columns_config:
            req_tree.heading(col, text=col)
            req_tree.column(col, width=width, anchor=anchor)

        # =================== TAB 4: SUPPLIER INFORMATION ===================
        suppliers_main = tk.Frame(suppliers_frame, bg='white', padx=10, pady=10)
        suppliers_main.pack(fill='both', expand=True)

        # Supplier performance
        supplier_perf_frame = tk.LabelFrame(suppliers_main, text="Supplier Performance Analysis",
                                            font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
        supplier_perf_frame.pack(fill='both', expand=True, pady=(0, 10))

        supplier_tree_frame = tk.Frame(supplier_perf_frame, bg='white')
        supplier_tree_frame.pack(fill='both', expand=True, padx=10, pady=10)

        supplier_scroll_y = ttk.Scrollbar(supplier_tree_frame)
        supplier_scroll_y.pack(side='right', fill='y')

        supplier_tree = ttk.Treeview(supplier_tree_frame,
                                     columns=('Supplier', 'Materials Supplied', 'Total Orders', 'Total Value',
                                              'Avg Price', 'Rating'),
                                     show='headings',
                                     yscrollcommand=supplier_scroll_y.set)
        supplier_tree.pack(fill='both', expand=True)

        supplier_scroll_y.config(command=supplier_tree.yview)

        # Configure supplier tree columns
        supplier_columns_config = [
            ('Supplier', 180, 'w'),
            ('Materials Supplied', 120, 'center'),
            ('Total Orders', 100, 'center'),
            ('Total Value', 150, 'e'),
            ('Avg Price', 120, 'e'),
            ('Rating', 80, 'center')
        ]

        for col, width, anchor in supplier_columns_config:
            supplier_tree.heading(col, text=col)
            supplier_tree.column(col, width=width, anchor=anchor)

        # Action buttons frame
        buttons_frame = tk.Frame(main_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(10, 0))

        # Left side buttons
        left_buttons = tk.Frame(buttons_frame, bg='white')
        left_buttons.pack(side='left')

        generate_report_btn = tk.Button(left_buttons, text="Generate Full Report", font=('Arial', 10, 'bold'),
                                        bg='#28a745', fg='white', width=16)
        generate_report_btn.pack(side='left', padx=(0, 5))

        export_csv_btn = tk.Button(left_buttons, text="Export to CSV", font=('Arial', 10),
                                   bg='#17a2b8', fg='white', width=12)
        export_csv_btn.pack(side='left', padx=(0, 5))

        print_report_btn = tk.Button(left_buttons, text="Print Report", font=('Arial', 10),
                                     bg='#6f42c1', fg='white', width=12)
        print_report_btn.pack(side='left', padx=(0, 5))

        add_requirement_btn = tk.Button(left_buttons, text="Add Requirement", font=('Arial', 10),
                                        bg='#fd7e14', fg='white', width=14)
        add_requirement_btn.pack(side='left', padx=(0, 5))

        # Right side buttons
        right_buttons = tk.Frame(buttons_frame, bg='white')
        right_buttons.pack(side='right')

        material_calculator_btn = tk.Button(right_buttons, text="Material Calculator", font=('Arial', 10),
                                            bg='#20c997', fg='white', width=16)
        material_calculator_btn.pack(side='left', padx=(0, 5))

        close_btn = tk.Button(right_buttons, text="Close", font=('Arial', 10),
                              bg='#dc3545', fg='white', width=10,
                              command=reports_window.destroy)
        close_btn.pack(side='left')

        # Load contracts for filter
        def load_contract_filter():
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('''
                               SELECT id, title
                               FROM contracts
                               WHERE contractor_id = ?
                               ORDER BY created_date DESC
                               ''', (self.current_user['id'],))
                contracts = cursor.fetchall()

                contract_options = ['All Contracts'] + [
                    f"{c[0]} - {c[1][:30]}..." if len(c[1]) > 30 else f"{c[0]} - {c[1]}" for c in contracts]
                contract_filter['values'] = contract_options
                contract_filter.set('All Contracts')

                conn.close()
            except Exception as e:
                contract_filter['values'] = ['All Contracts']
                contract_filter.set('All Contracts')

        # Load material usage data
        def load_material_usage():
            # Clear existing items
            for item in usage_tree.get_children():
                usage_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Get building materials data (simulated usage data)
                cursor.execute('''
                               SELECT bm.name,
                                      bm.category,
                                      bm.unit,
                                      bm.standard_price,
                                      bm.supplier,
                                      bm.local_name
                               FROM building_materials bm
                               ORDER BY bm.category, bm.name
                               ''')
                materials = cursor.fetchall()

                total_materials = 0
                total_value = 0
                categories = set()

                # Simulate usage data based on available materials
                import random
                for material in materials:
                    name, category, unit, price, supplier, local_name = material

                    # Simulate random usage quantities for demonstration
                    if random.random() > 0.7:  # Only show ~30% of materials as "used"
                        quantity = random.randint(1, 50)
                        unit_price = price
                        total_cost = quantity * unit_price

                        usage_tree.insert('', 'end', values=(
                            name,
                            category,
                            unit,
                            f"{quantity:,.1f}",
                            f"{unit_price:,.0f}",
                            f"{total_cost:,.0f}",
                            supplier
                        ))

                        total_materials += quantity
                        total_value += total_cost
                        categories.add(category)

                # Update statistics
                avg_cost = total_value / max(len(usage_tree.get_children()), 1)
                total_materials_label.config(text=f"Total Materials: {len(usage_tree.get_children())}")
                total_value_label.config(text=f"Total Value: {total_value:,.0f} FCFA")
                categories_label.config(text=f"Categories: {len(categories)}")
                avg_cost_label.config(text=f"Avg Cost/Item: {avg_cost:,.0f} FCFA")

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load material usage: {str(e)}")

        # Load cost analysis data
        def load_cost_analysis():
            # Clear existing items
            for item in cost_tree.get_children():
                cost_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Get materials grouped by category
                cursor.execute('''
                               SELECT category, COUNT(*) as material_count, AVG(standard_price) as avg_price
                               FROM building_materials
                               GROUP BY category
                               ORDER BY avg_price DESC
                               ''')
                categories = cursor.fetchall()

                total_cost = 0
                category_costs = []

                # Calculate costs for each category
                for category, count, avg_price in categories:
                    # Simulate usage quantities and costs
                    import random
                    simulated_quantity = random.randint(10, 100)
                    simulated_total_cost = count * avg_price * random.uniform(0.5, 2.0)
                    total_cost += simulated_total_cost

                    category_costs.append((category, count, simulated_quantity, simulated_total_cost, avg_price))

                # Insert data with percentages
                highest_cost = 0
                highest_category = ""
                lowest_cost = float('inf')
                lowest_category = ""

                for category, count, quantity, cost, avg_price in category_costs:
                    percentage = (cost / total_cost) * 100 if total_cost > 0 else 0

                    cost_tree.insert('', 'end', values=(
                        category,
                        count,
                        f"{quantity:,.0f}",
                        f"{cost:,.0f} FCFA",
                        f"{percentage:.1f}%",
                        f"{avg_price:,.0f} FCFA"
                    ))

                    # Track highest and lowest
                    if cost > highest_cost:
                        highest_cost = cost
                        highest_category = category
                    if cost < lowest_cost:
                        lowest_cost = cost
                        lowest_category = category

                # Update cost summary
                highest_cost_label.config(text=f"Highest Cost Category: {highest_category} ({highest_cost:,.0f} FCFA)")
                lowest_cost_label.config(text=f"Lowest Cost Category: {lowest_category} ({lowest_cost:,.0f} FCFA)")
                budget_status_label.config(text=f"Total Material Cost: {total_cost:,.0f} FCFA")

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load cost analysis: {str(e)}")

        # Load requirements data
        def load_requirements():
            # Clear existing items
            for item in req_tree.get_children():
                req_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Get contracts and simulate material requirements
                cursor.execute('''
                               SELECT c.id, c.title, c.end_date, c.budget
                               FROM contracts c
                               WHERE c.contractor_id = ?
                               ORDER BY c.start_date DESC
                               ''', (self.current_user['id'],))
                contracts = cursor.fetchall()

                cursor.execute('SELECT name, unit, standard_price FROM building_materials LIMIT 20')
                materials = cursor.fetchall()

                # Generate simulated requirements
                import random
                from datetime import datetime, timedelta

                for contract in contracts:
                    contract_id, title, end_date, budget = contract

                    # Add 3-5 random materials per contract
                    for _ in range(random.randint(3, 5)):
                        material = random.choice(materials)
                        name, unit, price = material

                        required_qty = random.randint(10, 100)
                        estimated_cost = required_qty * price

                        # Random status
                        status = random.choice(['Pending', 'Ordered', 'Delivered', 'In Use'])

                        req_tree.insert('', 'end', values=(
                            f"{contract_id} - {title[:20]}...",
                            name,
                            f"{required_qty:,.0f}",
                            unit,
                            status,
                            f"{estimated_cost:,.0f} FCFA",
                            end_date or 'TBD'
                        ))

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load requirements: {str(e)}")

        # Load supplier data
        def load_suppliers():
            # Clear existing items
            for item in supplier_tree.get_children():
                supplier_tree.delete(item)

            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()

                # Get unique suppliers
                cursor.execute('SELECT DISTINCT supplier FROM building_materials WHERE supplier IS NOT NULL')
                suppliers = cursor.fetchall()

                # Generate supplier performance data
                import random

                for supplier_row in suppliers:
                    supplier = supplier_row[0]

                    # Get materials from this supplier
                    cursor.execute('SELECT COUNT(*), AVG(standard_price) FROM building_materials WHERE supplier = ?',
                                   (supplier,))
                    supplier_data = cursor.fetchone()

                    material_count, avg_price = supplier_data
                    if material_count and avg_price:
                        # Simulate performance metrics
                        total_orders = random.randint(5, 50)
                        total_value = total_orders * avg_price * random.uniform(0.8, 1.5)
                        rating = random.uniform(3.5, 5.0)

                        supplier_tree.insert('', 'end', values=(
                            supplier,
                            material_count,
                            total_orders,
                            f"{total_value:,.0f} FCFA",
                            f"{avg_price:,.0f} FCFA",
                            f"{rating:.1f}/5.0"
                        ))

                conn.close()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load supplier data: {str(e)}")

        # Generate full report
        def generate_full_report():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
                    title="Save Material Report"
                )

                if filename:
                    from datetime import datetime

                    report_content = f"""
    MATERIAL REPORT - CONTRACTOR DASHBOARD

    Generated by: {self.current_user['full_name']}
    Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    Report Period: {date_filter_var.get()}

    === MATERIAL USAGE SUMMARY ===
    Total Materials Used: {total_materials_label.cget('text')}
    {total_value_label.cget('text')}
    {categories_label.cget('text')}
    {avg_cost_label.cget('text')}

    === COST ANALYSIS ===
    {highest_cost_label.cget('text')}
    {lowest_cost_label.cget('text')}
    {budget_status_label.cget('text')}

    === DETAILED MATERIAL USAGE ===
    """
                    # Add detailed data from trees
                    report_content += "Material Name | Category | Unit | Quantity | Unit Price | Total Cost | Supplier\n"
                    report_content += "-" * 80 + "\n"

                    for item in usage_tree.get_children():
                        values = usage_tree.item(item)['values']
                        report_content += " | ".join(str(v) for v in values) + "\n"

                    report_content += f"""

    === COST BREAKDOWN BY CATEGORY ===
    Category | Materials | Total Quantity | Total Cost | Percentage | Avg Unit Cost
    {"-" * 80}
    """
                    for item in cost_tree.get_children():
                        values = cost_tree.item(item)['values']
                        report_content += " | ".join(str(v) for v in values) + "\n"

                    report_content += """

    === RECOMMENDATIONS ===
    1. Monitor high-cost categories for potential savings
    2. Consider bulk purchasing for frequently used materials
    3. Establish relationships with reliable suppliers
    4. Track material waste to improve efficiency
    5. Regular price comparison across suppliers

    ---
    This report was generated by the Cameroon Building Project Management System.
    """

                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(report_content)

                    messagebox.showinfo("Success", f"Full report saved to {filename}")

                    # Log the action
                    self.log_audit_action(
                        self.current_user['id'],
                        "Generate Material Report",
                        f"Generated comprehensive material report: {filename}"
                    )

            except Exception as e:
                messagebox.showerror("Error", f"Failed to generate report: {str(e)}")

        # Export to CSV
        def export_to_csv():
            try:
                filename = filedialog.asksaveasfilename(
                    defaultextension=".csv",
                    filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                    title="Export Material Data"
                )

                if filename:
                    import csv

                    current_tab = notebook.index(notebook.select())

                    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.writer(csvfile)

                        if current_tab == 0:  # Material Usage tab
                            writer.writerow(
                                ['Material', 'Category', 'Unit', 'Quantity', 'Unit Price', 'Total Cost', 'Supplier'])
                            for item in usage_tree.get_children():
                                writer.writerow(usage_tree.item(item)['values'])
                        elif current_tab == 1:  # Cost Analysis tab
                            writer.writerow(['Category', 'Materials', 'Total Quantity', 'Total Cost', 'Percentage',
                                             'Avg Unit Cost'])
                            for item in cost_tree.get_children():
                                writer.writerow(cost_tree.item(item)['values'])
                        elif current_tab == 2:  # Requirements tab
                            writer.writerow(['Contract', 'Material', 'Required Qty', 'Unit', 'Status', 'Estimated Cost',
                                             'Deadline'])
                            for item in req_tree.get_children():
                                writer.writerow(req_tree.item(item)['values'])
                        elif current_tab == 3:  # Suppliers tab
                            writer.writerow(
                                ['Supplier', 'Materials Supplied', 'Total Orders', 'Total Value', 'Avg Price',
                                 'Rating'])
                            for item in supplier_tree.get_children():
                                writer.writerow(supplier_tree.item(item)['values'])

                    messagebox.showinfo("Success", f"Data exported to {filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to export data: {str(e)}")

        # Material calculator
        def show_material_calculator():
            calc_window = tk.Toplevel(reports_window)
            calc_window.title("Material Calculator")
            calc_window.geometry("500x600")
            calc_window.configure(bg='#f8f9fa')
            calc_window.grab_set()
            calc_window.transient(reports_window)

            main_frame = tk.Frame(calc_window, bg='#f8f9fa', padx=30, pady=20)
            main_frame.pack(fill='both', expand=True)

            tk.Label(main_frame, text="Building Material Calculator",
                     font=('Arial', 16, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))

            # Project type
            tk.Label(main_frame, text="Project Type:", font=('Arial', 11, 'bold'),
                     bg='#f8f9fa', fg='#2c3e50').pack(anchor='w', pady=(0, 5))

            project_type_var = tk.StringVar()
            project_type_combo = ttk.Combobox(main_frame, textvariable=project_type_var, width=40, state='readonly')
            project_type_combo['values'] = [
                'Single Story House', 'Two Story House', 'Apartment Building',
                'Commercial Building', 'Warehouse', 'Custom Project'
            ]
            project_type_combo.pack(anchor='w', pady=(0, 15))

            # Dimensions
            dimensions_frame = tk.LabelFrame(main_frame, text="Project Dimensions",
                                             font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            dimensions_frame.pack(fill='x', pady=(0, 15))

            # Length
            tk.Label(dimensions_frame, text="Length (meters):", font=('Arial', 10),
                     bg='#f8f9fa').pack(anchor='w', padx=10, pady=(10, 0))
            length_var = tk.StringVar()
            length_entry = tk.Entry(dimensions_frame, textvariable=length_var, font=('Arial', 10), width=20)
            length_entry.pack(anchor='w', padx=10, pady=(0, 5))

            # Width
            tk.Label(dimensions_frame, text="Width (meters):", font=('Arial', 10),
                     bg='#f8f9fa').pack(anchor='w', padx=10, pady=(5, 0))
            width_var = tk.StringVar()
            width_entry = tk.Entry(dimensions_frame, textvariable=width_var, font=('Arial', 10), width=20)
            width_entry.pack(anchor='w', padx=10, pady=(0, 5))

            # Height
            tk.Label(dimensions_frame, text="Height (meters):", font=('Arial', 10),
                     bg='#f8f9fa').pack(anchor='w', padx=10, pady=(5, 0))
            height_var = tk.StringVar()
            height_entry = tk.Entry(dimensions_frame, textvariable=height_var, font=('Arial', 10), width=20)
            height_entry.pack(anchor='w', padx=10, pady=(0, 10))

            # Results frame
            results_frame = tk.LabelFrame(main_frame, text="Estimated Material Requirements",
                                          font=('Arial', 12, 'bold'), bg='#f8f9fa', fg='#2c3e50')
            results_frame.pack(fill='both', expand=True, pady=(0, 15))

            results_text = tk.Text(results_frame, height=12, width=60, font=('Arial', 9),
                                   wrap='word', state='disabled', bg='white')
            results_text.pack(fill='both', expand=True, padx=10, pady=10)

            def calculate_materials():
                try:
                    length = float(length_var.get() or 0)
                    width = float(width_var.get() or 0)
                    height = float(height_var.get() or 0)

                    if length <= 0 or width <= 0 or height <= 0:
                        messagebox.showerror("Error", "Please enter valid dimensions")
                        return

                    # Basic calculations (simplified)
                    floor_area = length * width
                    wall_area = 2 * (length + width) * height
                    volume = length * width * height

                    # Estimated materials (basic formulas)
                    cement_bags = int((floor_area * 0.5) + (wall_area * 0.3))  # Rough estimate
                    sand_cubic_meters = floor_area * 0.15
                    gravel_cubic_meters = floor_area * 0.2
                    blocks = int(wall_area * 8)  # Rough estimate for blocks
                    roofing_sheets = int(floor_area * 1.2 / 1.8)  # Assuming 1.8 sqm per sheet

                    # Calculate costs (get from database)
                    conn = self.db_manager.create_connection()
                    cursor = conn.cursor()

                    cursor.execute('SELECT standard_price FROM building_materials WHERE name LIKE "%Cement%" LIMIT 1')
                    cement_price = cursor.fetchone()[0] if cursor.fetchone() else 6500

                    cursor.execute('SELECT standard_price FROM building_materials WHERE name LIKE "%Sand%" LIMIT 1')
                    sand_price = cursor.fetchone()[0] if cursor.fetchone() else 15000

                    cursor.execute('SELECT standard_price FROM building_materials WHERE name LIKE "%Gravel%" LIMIT 1')
                    gravel_price = cursor.fetchone()[0] if cursor.fetchone() else 20000

                    cursor.execute('SELECT standard_price FROM building_materials WHERE name LIKE "%Block%" LIMIT 1')
                    block_price = cursor.fetchone()[0] if cursor.fetchone() else 350

                    conn.close()

                    # Calculate total costs
                    cement_cost = cement_bags * cement_price
                    sand_cost = sand_cubic_meters * sand_price
                    gravel_cost = gravel_cubic_meters * gravel_price
                    blocks_cost = blocks * block_price
                    total_cost = cement_cost + sand_cost + gravel_cost + blocks_cost

                    # Display results
                    results_text.config(state='normal')
                    results_text.delete('1.0', 'end')

                    results = f"""
    PROJECT CALCULATIONS
    Project Type: {project_type_var.get() or 'Custom Project'}
    Dimensions: {length}m x {width}m x {height}m
    Floor Area: {floor_area:.2f} sq meters
    Wall Area: {wall_area:.2f} sq meters

    ESTIMATED MATERIAL REQUIREMENTS:

    CEMENT & BINDING:
    • Cement Portland: {cement_bags} bags
      Cost: {cement_cost:,.0f} FCFA

    AGGREGATES:
    • Sand (River): {sand_cubic_meters:.2f} cubic meters
      Cost: {sand_cost:,.0f} FCFA
    • Gravel: {gravel_cubic_meters:.2f} cubic meters
      Cost: {gravel_cost:,.0f} FCFA

    MASONRY:
    • Concrete Blocks: {blocks} pieces
      Cost: {blocks_cost:,.0f} FCFA

    ESTIMATED TOTAL COST: {total_cost:,.0f} FCFA

    NOTE: These are rough estimates for basic construction.
    Actual requirements may vary based on:
    - Construction method
    - Design specifications
    - Local building codes
    - Quality requirements
    - Weather conditions

    Consult with construction professionals for detailed planning.
    """
                    results_text.insert('1.0', results)
                    results_text.config(state='disabled')

                except ValueError:
                    messagebox.showerror("Error", "Please enter valid numeric dimensions")
                except Exception as e:
                    messagebox.showerror("Error", f"Calculation failed: {str(e)}")

            # Buttons
            btn_frame = tk.Frame(main_frame, bg='#f8f9fa')
            btn_frame.pack(pady=10)

            tk.Button(btn_frame, text="Calculate", font=('Arial', 11, 'bold'),
                      bg='#28a745', fg='white', width=15,
                      command=calculate_materials).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Clear", font=('Arial', 11),
                      bg='#6c757d', fg='white', width=15,
                      command=lambda: [length_var.set(''), width_var.set(''), height_var.set(''),
                                       results_text.config(state='normal'),
                                       results_text.delete('1.0', 'end'),
                                       results_text.config(state='disabled')]).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Close", font=('Arial', 11),
                      bg='#dc3545', fg='white', width=15,
                      command=calc_window.destroy).pack(side='left')

        # Add requirement function
        def add_requirement():
            add_window = tk.Toplevel(reports_window)
            add_window.title("Add Material Requirement")
            add_window.geometry("500x400")
            add_window.configure(bg='#34495e')
            add_window.grab_set()
            add_window.transient(reports_window)

            form_frame = tk.Frame(add_window, bg='#34495e', padx=30, pady=30)
            form_frame.pack(fill='both', expand=True)

            tk.Label(form_frame, text="Add Material Requirement",
                     font=('Arial', 16, 'bold'), bg='#34495e', fg='white').pack(pady=(0, 20))

            # Contract selection
            tk.Label(form_frame, text="Contract:", font=('Arial', 11, 'bold'),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            contract_var = tk.StringVar()
            contract_combo = ttk.Combobox(form_frame, textvariable=contract_var, width=50, state='readonly')

            # Load user's contracts
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('SELECT id, title FROM contracts WHERE contractor_id = ?', (self.current_user['id'],))
                contracts = cursor.fetchall()
                contract_combo['values'] = [f"{c[0]} - {c[1]}" for c in contracts]
                conn.close()
            except:
                pass

            contract_combo.pack(anchor='w', pady=(0, 15))

            # Material selection
            tk.Label(form_frame, text="Material:", font=('Arial', 11, 'bold'),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))

            material_var = tk.StringVar()
            material_combo = ttk.Combobox(form_frame, textvariable=material_var, width=50, state='readonly')

            # Load materials
            try:
                conn = self.db_manager.create_connection()
                cursor = conn.cursor()
                cursor.execute('SELECT name, unit FROM building_materials ORDER BY name')
                materials = cursor.fetchall()
                material_combo['values'] = [f"{m[0]} ({m[1]})" for m in materials]
                conn.close()
            except:
                pass

            material_combo.pack(anchor='w', pady=(0, 15))

            # Quantity
            tk.Label(form_frame, text="Required Quantity:", font=('Arial', 11, 'bold'),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))
            quantity_entry = tk.Entry(form_frame, font=('Arial', 11), width=20)
            quantity_entry.pack(anchor='w', pady=(0, 15))

            # Priority
            tk.Label(form_frame, text="Priority:", font=('Arial', 11, 'bold'),
                     bg='#34495e', fg='white').pack(anchor='w', pady=(0, 5))
            priority_var = tk.StringVar()
            priority_combo = ttk.Combobox(form_frame, textvariable=priority_var, width=20, state='readonly')
            priority_combo['values'] = ['Low', 'Medium', 'High', 'Urgent']
            priority_combo.set('Medium')
            priority_combo.pack(anchor='w', pady=(0, 15))

            def save_requirement():
                if not all([contract_var.get(), material_var.get(), quantity_entry.get()]):
                    messagebox.showerror("Error", "Please fill all fields")
                    return

                # In real implementation, save to database
                messagebox.showinfo("Success", "Material requirement added successfully!")
                add_window.destroy()
                load_requirements()

            # Buttons
            btn_frame = tk.Frame(form_frame, bg='#34495e')
            btn_frame.pack(pady=(20, 0))

            tk.Button(btn_frame, text="Save Requirement", font=('Arial', 11, 'bold'),
                      bg='#28a745', fg='white', width=15,
                      command=save_requirement).pack(side='left', padx=(0, 10))

            tk.Button(btn_frame, text="Cancel", font=('Arial', 11),
                      bg='#dc3545', fg='white', width=15,
                      command=add_window.destroy).pack(side='left')

        # Bind button commands
        generate_report_btn.config(command=generate_full_report)
        export_csv_btn.config(command=export_to_csv)
        add_requirement_btn.config(command=add_requirement)
        material_calculator_btn.config(command=show_material_calculator)
        refresh_btn.config(
            command=lambda: [load_material_usage(), load_cost_analysis(), load_requirements(), load_suppliers()])

        # Bind filter events
        def on_filter_change(*args):
            load_material_usage()
            load_cost_analysis()
            load_requirements()
            load_suppliers()

        contract_filter_var.trace('w', on_filter_change)
        report_type_var.trace('w', on_filter_change)
        date_filter_var.trace('w', on_filter_change)

        # Keyboard shortcuts
        reports_window.bind('<F5>', lambda e: [load_material_usage(), load_cost_analysis(), load_requirements(),
                                               load_suppliers()])
        reports_window.bind('<Escape>', lambda e: reports_window.destroy())

        # Initial data loading
        load_contract_filter()
        load_material_usage()
        load_cost_analysis()
        load_requirements()
        load_suppliers()

        # Log the action
        self.log_audit_action(
            self.current_user['id'],
            "Access Material Reports",
            "Opened material reports and analysis dashboard"
        )
        # ================== create workers =========================

    def show_create_worker(self):
        # Create Worker Profile window
        create_worker_window = tk.Toplevel(self.root)
        create_worker_window.title("Create Worker Profile")
        create_worker_window.geometry("800x900")
        create_worker_window.configure(bg='#34495e')
        create_worker_window.grab_set()  # Make modal
        create_worker_window.resizable(False, False)

        # Center the window
        create_worker_window.transient(self.root)

        # Main container
        main_frame = tk.Frame(create_worker_window, bg='#34495e', padx=30, pady=20)
        main_frame.pack(fill='both', expand=True)

        # Title
        title_label = tk.Label(main_frame, text="Create New Worker Profile",
                               font=('Arial', 18, 'bold'), bg='#34495e', fg='white')
        title_label.pack(pady=(0, 30))

        # Form frame with scrollbar support
        canvas = tk.Canvas(main_frame, bg='#34495e', highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#34495e')

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Form entries dictionary
        form_entries = {}

        # Personal Information Section
        personal_section = tk.LabelFrame(scrollable_frame, text="Personal Information",
                                         font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        personal_section.pack(fill='x', pady=(0, 20), padx=5)

        # Full Name
        name_frame = tk.Frame(personal_section, bg='#34495e')
        name_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(name_frame, text="Full Name *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        name_entry = tk.Entry(name_frame, font=('Arial', 11), width=35)
        name_entry.pack(side='left', padx=(10, 0))
        form_entries['full_name'] = name_entry

        # Date of Birth
        dob_frame = tk.Frame(personal_section, bg='#34495e')
        dob_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(dob_frame, text="Date of Birth", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        dob_entry = tk.Entry(dob_frame, font=('Arial', 11), width=35)
        dob_entry.insert(0, "YYYY-MM-DD")
        dob_entry.pack(side='left', padx=(10, 0))
        form_entries['date_of_birth'] = dob_entry

        # Gender
        gender_frame = tk.Frame(personal_section, bg='#34495e')
        gender_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(gender_frame, text="Gender", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        gender_var = tk.StringVar()
        gender_combo = ttk.Combobox(gender_frame, textvariable=gender_var,
                                    font=('Arial', 11), width=32, state='readonly')
        gender_combo['values'] = ['Male', 'Female', 'Other', 'Prefer not to say']
        gender_combo.pack(side='left', padx=(10, 0))
        form_entries['gender'] = gender_combo

        # National ID
        id_frame = tk.Frame(personal_section, bg='#34495e')
        id_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(id_frame, text="National ID Number", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        id_entry = tk.Entry(id_frame, font=('Arial', 11), width=35)
        id_entry.pack(side='left', padx=(10, 0))
        form_entries['national_id'] = id_entry

        # Contact Information Section
        contact_section = tk.LabelFrame(scrollable_frame, text="Contact Information",
                                        font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        contact_section.pack(fill='x', pady=(0, 20), padx=5)

        # Phone Number
        phone_frame = tk.Frame(contact_section, bg='#34495e')
        phone_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(phone_frame, text="Phone Number *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        phone_entry = tk.Entry(phone_frame, font=('Arial', 11), width=35)
        phone_entry.insert(0, "+237 ")
        phone_entry.pack(side='left', padx=(10, 0))
        form_entries['phone'] = phone_entry

        # Emergency Contact
        emergency_frame = tk.Frame(contact_section, bg='#34495e')
        emergency_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(emergency_frame, text="Emergency Contact", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        emergency_entry = tk.Entry(emergency_frame, font=('Arial', 11), width=35)
        emergency_entry.pack(side='left', padx=(10, 0))
        form_entries['emergency_contact'] = emergency_entry

        # Address
        address_frame = tk.Frame(contact_section, bg='#34495e')
        address_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(address_frame, text="Address *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        address_text = tk.Text(address_frame, font=('Arial', 11), width=35, height=3)
        address_text.pack(side='left', padx=(10, 0))
        form_entries['address'] = address_text

        # Region/City
        location_frame = tk.Frame(contact_section, bg='#34495e')
        location_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(location_frame, text="Region/City *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        region_var = tk.StringVar()
        region_combo = ttk.Combobox(location_frame, textvariable=region_var,
                                    font=('Arial', 11), width=32, state='readonly')
        region_combo['values'] = [
            'Adamawa', 'Centre', 'East', 'Far North', 'Littoral',
            'North', 'Northwest', 'South', 'Southwest', 'West'
        ]
        region_combo.pack(side='left', padx=(10, 0))
        form_entries['region'] = region_combo

        # Professional Information Section
        professional_section = tk.LabelFrame(scrollable_frame, text="Professional Information",
                                             font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        professional_section.pack(fill='x', pady=(0, 20), padx=5)

        # Job Title/Position
        position_frame = tk.Frame(professional_section, bg='#34495e')
        position_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(position_frame, text="Job Title/Position *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        position_var = tk.StringVar()
        position_combo = ttk.Combobox(position_frame, textvariable=position_var,
                                      font=('Arial', 11), width=32, state='readonly')
        position_combo['values'] = [
            'Mason', 'Carpenter', 'Electrician', 'Plumber', 'Roofer',
            'Tile Setter', 'Painter', 'Welder', 'Heavy Equipment Operator',
            'Construction Laborer', 'Site Supervisor', 'Foreman',
            'Construction Engineer', 'Architect', 'Quantity Surveyor',
            'Safety Officer', 'Other'
        ]
        position_combo.pack(side='left', padx=(10, 0))
        form_entries['position'] = position_combo

        # Experience Level
        experience_frame = tk.Frame(professional_section, bg='#34495e')
        experience_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(experience_frame, text="Experience Level *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        experience_var = tk.StringVar()
        experience_combo = ttk.Combobox(experience_frame, textvariable=experience_var,
                                        font=('Arial', 11), width=32, state='readonly')
        experience_combo['values'] = [
            'Entry Level (0-2 years)', 'Junior (2-5 years)',
            'Mid-Level (5-10 years)', 'Senior (10-15 years)',
            'Expert (15+ years)'
        ]
        experience_combo.pack(side='left', padx=(10, 0))
        form_entries['experience_level'] = experience_combo

        # Years of Experience
        years_exp_frame = tk.Frame(professional_section, bg='#34495e')
        years_exp_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(years_exp_frame, text="Years of Experience", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        years_exp_entry = tk.Entry(years_exp_frame, font=('Arial', 11), width=35)
        years_exp_entry.pack(side='left', padx=(10, 0))
        form_entries['years_experience'] = years_exp_entry

        # Hourly Rate
        rate_frame = tk.Frame(professional_section, bg='#34495e')
        rate_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(rate_frame, text="Hourly Rate (FCFA)", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        rate_entry = tk.Entry(rate_frame, font=('Arial', 11), width=35)
        rate_entry.pack(side='left', padx=(10, 0))
        form_entries['hourly_rate'] = rate_entry

        # Skills and Specializations Section
        skills_section = tk.LabelFrame(scrollable_frame, text="Skills and Specializations",
                                       font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        skills_section.pack(fill='x', pady=(0, 20), padx=5)

        # Primary Skills
        primary_skills_frame = tk.Frame(skills_section, bg='#34495e')
        primary_skills_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(primary_skills_frame, text="Primary Skills *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')

        # Skills checkboxes frame
        skills_checkboxes_frame = tk.Frame(primary_skills_frame, bg='#34495e')
        skills_checkboxes_frame.pack(side='left', padx=(10, 0))

        # Define available skills
        available_skills = [
            'Masonry', 'Carpentry', 'Electrical Work', 'Plumbing', 'Roofing',
            'Tile Work', 'Painting', 'Welding', 'Concrete Work', 'Steel Work',
            'HVAC', 'Flooring', 'Drywall', 'Landscaping', 'Heavy Machinery'
        ]

        skills_vars = {}
        for i, skill in enumerate(available_skills):
            row = i // 3
            col = i % 3

            var = tk.BooleanVar()
            skills_vars[skill] = var
            check = tk.Checkbutton(skills_checkboxes_frame, text=skill, variable=var,
                                   bg='#34495e', fg='white', selectcolor='#2c3e50',
                                   activebackground='#34495e', font=('Arial', 9))
            check.grid(row=row, column=col, sticky='w', padx=5, pady=2)

        form_entries['skills'] = skills_vars

        # Specialized Equipment
        equipment_frame = tk.Frame(skills_section, bg='#34495e')
        equipment_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(equipment_frame, text="Specialized Equipment", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        equipment_text = tk.Text(equipment_frame, font=('Arial', 11), width=35, height=2)
        equipment_text.pack(side='left', padx=(10, 0))
        form_entries['equipment'] = equipment_text

        # Certifications and Licenses Section
        cert_section = tk.LabelFrame(scrollable_frame, text="Certifications and Licenses",
                                     font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        cert_section.pack(fill='x', pady=(0, 20), padx=5)

        # Certifications
        cert_frame = tk.Frame(cert_section, bg='#34495e')
        cert_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(cert_frame, text="Certifications", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        cert_text = tk.Text(cert_frame, font=('Arial', 11), width=35, height=3)
        cert_text.insert('1.0',
                         "List certifications (one per line):\ne.g., Safety Training Certificate\nElectrical License")
        cert_text.pack(side='left', padx=(10, 0))
        form_entries['certifications'] = cert_text

        # Safety Training
        safety_frame = tk.Frame(cert_section, bg='#34495e')
        safety_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(safety_frame, text="Safety Training", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')

        safety_var = tk.BooleanVar()
        safety_check = tk.Checkbutton(safety_frame, text="Has completed safety training",
                                      variable=safety_var, bg='#34495e', fg='white',
                                      selectcolor='#2c3e50', activebackground='#34495e')
        safety_check.pack(side='left', padx=(10, 0))
        form_entries['safety_training'] = safety_var

        # Work Status Section
        status_section = tk.LabelFrame(scrollable_frame, text="Work Status and Availability",
                                       font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        status_section.pack(fill='x', pady=(0, 20), padx=5)

        # Employment Status
        employment_frame = tk.Frame(status_section, bg='#34495e')
        employment_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(employment_frame, text="Employment Status *", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        employment_var = tk.StringVar()
        employment_combo = ttk.Combobox(employment_frame, textvariable=employment_var,
                                        font=('Arial', 11), width=32, state='readonly')
        employment_combo['values'] = [
            'Full-time Employee', 'Part-time Employee', 'Contract Worker',
            'Freelancer', 'Apprentice', 'Intern'
        ]
        employment_combo.pack(side='left', padx=(10, 0))
        form_entries['employment_status'] = employment_combo

        # Availability
        availability_frame = tk.Frame(status_section, bg='#34495e')
        availability_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(availability_frame, text="Availability", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        availability_var = tk.StringVar()
        availability_combo = ttk.Combobox(availability_frame, textvariable=availability_var,
                                          font=('Arial', 11), width=32, state='readonly')
        availability_combo['values'] = [
            'Immediately Available', 'Available in 1 week',
            'Available in 2 weeks', 'Available in 1 month',
            'Currently Busy', 'Project-based'
        ]
        availability_combo.pack(side='left', padx=(10, 0))
        form_entries['availability'] = availability_combo

        # Start Date
        start_date_frame = tk.Frame(status_section, bg='#34495e')
        start_date_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(start_date_frame, text="Start Date", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        start_date_entry = tk.Entry(start_date_frame, font=('Arial', 11), width=35)
        start_date_entry.insert(0, date.today().strftime('%Y-%m-%d'))
        start_date_entry.pack(side='left', padx=(10, 0))
        form_entries['start_date'] = start_date_entry

        # Additional Information Section
        additional_section = tk.LabelFrame(scrollable_frame, text="Additional Information",
                                           font=('Arial', 12, 'bold'), bg='#34495e', fg='white')
        additional_section.pack(fill='x', pady=(0, 20), padx=5)

        # Notes/Comments
        notes_frame = tk.Frame(additional_section, bg='#34495e')
        notes_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(notes_frame, text="Notes/Comments", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')
        notes_text = tk.Text(notes_frame, font=('Arial', 11), width=35, height=3)
        notes_text.pack(side='left', padx=(10, 0))
        form_entries['notes'] = notes_text

        # Photo/Document Upload placeholder
        docs_frame = tk.Frame(additional_section, bg='#34495e')
        docs_frame.pack(fill='x', padx=10, pady=8)
        tk.Label(docs_frame, text="Documents", font=('Arial', 11),
                 bg='#34495e', fg='white', width=20, anchor='w').pack(side='left')

        docs_info_frame = tk.Frame(docs_frame, bg='#34495e')
        docs_info_frame.pack(side='left', padx=(10, 0))

        tk.Label(docs_info_frame, text="Upload worker photo and documents:",
                 font=('Arial', 9), bg='#34495e', fg='#bdc3c7').pack(anchor='w')

        upload_photo_btn = tk.Button(docs_info_frame, text="Upload Photo",
                                     font=('Arial', 9), bg='#3498db', fg='white', width=12)
        upload_photo_btn.pack(side='left', pady=5)

        upload_docs_btn = tk.Button(docs_info_frame, text="Upload Documents",
                                    font=('Arial', 9), bg='#3498db', fg='white', width=15)
        upload_docs_btn.pack(side='left', padx=(5, 0), pady=5)

        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Validation functions
        def validate_phone(phone):
            if not phone or phone == "+237 ":
                return False, "Phone number is required"
            import re
            pattern = r'^(\+237|237)?[6-9]\d{8}$'
            if not re.match(pattern, phone.replace(' ', '').replace('-', '')):
                return False, "Please enter a valid Cameroon phone number"
            return True, "Valid"

        def validate_date(date_str):
            if not date_str or date_str == "YYYY-MM-DD":
                return True, "Valid"  # Date of birth is optional
            try:
                from datetime import datetime as dt
                dt.strptime(date_str, '%Y-%m-%d')
                return True, "Valid"
            except ValueError:
                return False, "Please use YYYY-MM-DD format"

        # Create worker function
        def create_new_worker():
            try:
                # Get all form data
                form_data = {}

                # Get text entries
                text_fields = ['full_name', 'date_of_birth', 'national_id', 'phone',
                               'emergency_contact', 'years_experience', 'hourly_rate', 'start_date']
                for field in text_fields:
                    widget = form_entries[field]
                    form_data[field] = widget.get().strip()

                # Get text widgets
                text_widget_fields = ['address', 'equipment', 'certifications', 'notes']
                for field in text_widget_fields:
                    widget = form_entries[field]
                    form_data[field] = widget.get('1.0', 'end-1c').strip()

                # Get combo boxes
                combo_fields = ['gender', 'region', 'position', 'experience_level',
                                'employment_status', 'availability']
                for field in combo_fields:
                    form_data[field] = form_entries[field].get()

                # Get boolean fields
                bool_fields = ['safety_training']
                for field in bool_fields:
                    form_data[field] = form_entries[field].get()

                # Get skills
                selected_skills = []
                for skill, var in form_entries['skills'].items():
                    if var.get():
                        selected_skills.append(skill)
                form_data['skills'] = selected_skills

                # Validation
                errors = []

                # Required fields
                required_fields = ['full_name', 'phone', 'address', 'region', 'position',
                                   'experience_level', 'employment_status']
                for field in required_fields:
                    if not form_data.get(field):
                        field_display = field.replace('_', ' ').title()
                        errors.append(f"{field_display} is required")

                # Phone validation
                if form_data.get('phone'):
                    is_valid, message = validate_phone(form_data['phone'])
                    if not is_valid:
                        errors.append(f"Phone: {message}")

                # Date validation
                if form_data.get('date_of_birth'):
                    is_valid, message = validate_date(form_data['date_of_birth'])
                    if not is_valid:
                        errors.append(f"Date of birth: {message}")

                # Skills validation
                if not selected_skills:
                    errors.append("Please select at least one skill")

                # Hourly rate validation
                if form_data.get('hourly_rate'):
                    try:
                        rate = float(form_data['hourly_rate'])
                        if rate < 0:
                            errors.append("Hourly rate must be positive")
                    except ValueError:
                        errors.append("Please enter a valid hourly rate")

                # Show validation errors
                if errors:
                    error_message = "Please fix the following errors:\n\n" + "\n".join(f"• {error}" for error in errors)
                    messagebox.showerror("Validation Error", error_message)
                    return

                # Prepare worker profile data
                worker_profile = {
                    'personal_info': {
                        'full_name': form_data['full_name'],
                        'date_of_birth': form_data['date_of_birth'] if form_data[
                                                                           'date_of_birth'] != "YYYY-MM-DD" else None,
                        'gender': form_data['gender'],
                        'national_id': form_data['national_id'],
                        'phone': form_data['phone'],
                        'emergency_contact': form_data['emergency_contact'],
                        'address': form_data['address'],
                        'region': form_data['region']
                    },
                    'professional_info': {
                        'position': form_data['position'],
                        'experience_level': form_data['experience_level'],
                        'years_experience': int(form_data['years_experience']) if form_data[
                            'years_experience'].isdigit() else 0,
                        'hourly_rate': float(form_data['hourly_rate']) if form_data['hourly_rate'] else 0.0,
                        'skills': selected_skills,
                        'equipment': form_data['equipment'],
                        'certifications': form_data['certifications'],
                        'safety_training': form_data['safety_training']
                    },
                    'work_status': {
                        'employment_status': form_data['employment_status'],
                        'availability': form_data['availability'],
                        'start_date': form_data['start_date']
                    },
                    'additional_info': {
                        'notes': form_data['notes']
                    }
                }

                # In a real implementation, you would have a workers table
                # For now, we'll log this as an audit action with the worker details
                worker_summary = (
                    f"Name: {form_data['full_name']}, "
                    f"Position: {form_data['position']}, "
                    f"Experience: {form_data['experience_level']}, "
                    f"Skills: {', '.join(selected_skills[:3])}{'...' if len(selected_skills) > 3 else ''}, "
                    f"Status: {form_data['employment_status']}, "
                    f"Region: {form_data['region']}"
                )

                # Log the action
                self.log_audit_action(
                    self.current_user['id'],
                    "Create Worker Profile",
                    f"Created worker profile - {worker_summary}"
                )

                # Show success message
                success_message = (
                    f"Worker profile created successfully!\n\n"
                    f"Worker: {form_data['full_name']}\n"
                    f"Position: {form_data['position']}\n"
                    f"Experience: {form_data['experience_level']}\n"
                    f"Skills: {', '.join(selected_skills)}\n"
                    f"Employment Status: {form_data['employment_status']}\n"
                    f"Availability: {form_data['availability']}\n"
                    f"Location: {form_data['region']}"
                )

                messagebox.showinfo("Success", success_message)

                # Ask if user wants to create another worker profile
                if messagebox.askyesno("Continue",
                                       "Would you like to create another worker profile?"):
                    clear_form()
                else:
                    create_worker_window.destroy()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to create worker profile: {str(e)}")

        # Clear form function
        def clear_form():
            for field_name, widget in form_entries.items():
                if field_name == 'skills':
                    # Reset all skill checkboxes
                    for var in widget.values():
                        var.set(False)
                elif isinstance(widget, tk.BooleanVar):
                    widget.set(False)
                elif hasattr(widget, 'delete'):
                    if isinstance(widget, tk.Text):
                        widget.delete('1.0', 'end')
                        # Add placeholder text for specific fields
                        if field_name == 'certifications':
                            widget.insert('1.0',
                                          "List certifications (one per line):\ne.g., Safety Training Certificate\nElectrical License")
                    else:
                        widget.delete(0, 'end')
                        # Reset default values
                        if field_name == 'phone':
                            widget.insert(0, "+237 ")
                        elif field_name == 'date_of_birth':
                            widget.insert(0, "YYYY-MM-DD")
                        elif field_name == 'start_date':
                            widget.insert(0, date.today().strftime('%Y-%m-%d'))
                elif hasattr(widget, 'set'):
                    widget.set('')

        # Upload photo function placeholder
        def upload_photo():
            filename = filedialog.askopenfilename(
                title="Select Worker Photo",
                filetypes=[("Image files", "*.jpg *.jpeg *.png *.bmp *.gif"), ("All files", "*.*")]
            )
            if filename:
                messagebox.showinfo("Info",
                                    f"Photo selected: {filename}\n\nPhoto upload functionality will be implemented in future versions.")

        # Upload documents function placeholder
        def upload_documents():
            filename = filedialog.askopenfilename(
                title="Select Worker Documents",
                filetypes=[("PDF files", "*.pdf"), ("Word documents", "*.doc *.docx"), ("All files", "*.*")]
            )
            if filename:
                messagebox.showinfo("Info",
                                    f"Document selected: {filename}\n\nDocument upload functionality will be implemented in future versions.")

        # Bind upload buttons
        upload_photo_btn.config(command=upload_photo)
        upload_docs_btn.config(command=upload_documents)

        # Button frame
        button_frame = tk.Frame(main_frame, bg='#34495e')
        button_frame.pack(fill='x', pady=(20, 0))

        # Buttons
        tk.Button(button_frame, text="Create Worker Profile", font=('Arial', 12, 'bold'),
                  bg='#27ae60', fg='white', width=18, height=2,
                  command=create_new_worker).pack(side='left', padx=(0, 10))

        tk.Button(button_frame, text="Clear Form", font=('Arial', 12),
                  bg='#f39c12', fg='white', width=15, height=2,
                  command=clear_form).pack(side='left', padx=(0, 10))

        tk.Button(button_frame, text="Cancel", font=('Arial', 12),
                  bg='#e74c3c', fg='white', width=15, height=2,
                  command=create_worker_window.destroy).pack(side='right')

        # Help frame
        help_frame = tk.Frame(main_frame, bg='#34495e')
        help_frame.pack(fill='x', pady=(10, 0))

        help_text = (
            "Tips for creating worker profiles:\n"
            "• Fields marked with * are required\n"
            "• Select all relevant skills for better project matching\n"
            "• Include certifications to showcase qualifications\n"
            "• Set realistic hourly rates based on experience and skills\n"
            "• Keep contact information current for quick communication\n"
            "• Use notes section for additional important information"
        )

        tk.Label(help_frame, text=help_text, font=('Arial', 9),
                 bg='#34495e', fg='#bdc3c7', justify='left').pack(anchor='w')

        # Set focus to first field
        form_entries['full_name'].focus()

        # Keyboard shortcuts
        create_worker_window.bind('<Escape>', lambda e: create_worker_window.destroy())

        # Mouse wheel scrolling
        def on_mousewheel(event):
            canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

        canvas.bind("<MouseWheel>", on_mousewheel)



# ===================== manager workers =======================
    def show_manage_workers(self):
        try:
            win = tk.Toplevel(self.root)
            win.title("Manage Workers")
            win.geometry("1000x620")
            win.configure(bg='white')
            win.grab_set()

            # Header
            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Manage Workers", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Top actions and search
            top = tk.Frame(win, bg='white')
            top.pack(fill='x', padx=10)
            tk.Label(top, text="Search:", bg='white').pack(side='left')
            search_var = tk.StringVar()
            tk.Entry(top, textvariable=search_var, width=40).pack(side='left', padx=6)
            tk.Button(top, text="Add Worker", bg="#27ae60", fg="white", command=lambda: add_edit_worker()).pack(side='right')

            # Table
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Full Name","Phone","Email","Trade","Experience","Status","Created")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=130)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Buttons
            btns = tk.Frame(win, bg='white')
            btns.pack(fill='x', padx=10, pady=(0,10))
            tk.Button(btns, text="Edit", bg="#2980b9", fg="white", command=lambda: add_edit_worker(edit=True)).pack(side='left')
            tk.Button(btns, text="Delete", bg="#c0392b", fg="white", command=lambda: delete_worker()).pack(side='left', padx=6)
            tk.Button(btns, text="Export CSV", command=lambda: export_csv()).pack(side='left')
            tk.Button(btns, text="Refresh", command=lambda: load_workers()).pack(side='right')

            # Ensure workers table exists (minimal schema)
            def ensure_workers_table():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute('''
                        CREATE TABLE IF NOT EXISTS workers (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            full_name TEXT NOT NULL,
                            phone TEXT,
                            email TEXT,
                            trade TEXT,
                            experience_years INTEGER DEFAULT 0,
                            status TEXT DEFAULT 'Active',
                            created_date DATE NOT NULL,
                            owner_id INTEGER,
                            FOREIGN KEY(owner_id) REFERENCES users(id)
                        )
                    ''')
                    conn.commit()
                    conn.close()
                except Exception:
                    pass

            ensure_workers_table()

            def load_workers():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    q = search_var.get().strip()
                    role = self.current_user['role']
                    params = []
                    query = "SELECT id, full_name, phone, email, trade, COALESCE(experience_years,0), COALESCE(status,'Active'), created_date FROM workers"
                    where = []
                    if role not in ['administrator','contract_owner']:
                        where.append("owner_id = ?")
                        params.append(self.current_user['id'])
                    if q:
                        where.append("(full_name LIKE ? OR phone LIKE ? OR email LIKE ? OR trade LIKE ?)")
                        like = f"%{q}%"
                        params.extend([like, like, like, like])
                    if where:
                        query += " WHERE " + " AND ".join(where)
                    query += " ORDER BY created_date DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                    for item in tree.get_children():
                        tree.delete(item)
                    for r in rows:
                        tree.insert('', 'end', values=r)
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to load workers: {str(e)}")
                    except Exception:
                        pass

            def add_edit_worker(edit=False):
                try:
                    itm = None
                    if edit:
                        sel = tree.selection()
                        if not sel:
                            messagebox.showwarning("Edit", "Select a worker to edit.")
                            return
                        itm = tree.item(sel[0], 'values')
                    dlg = tk.Toplevel(win)
                    dlg.title("Edit Worker" if edit else "Add Worker")
                    dlg.geometry("480x380")
                    dlg.configure(bg='white')
                    dlg.grab_set()

                    form = tk.Frame(dlg, bg='white')
                    form.pack(fill='both', expand=True, padx=12, pady=12)
                    tk.Label(form, text="Full Name*:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
                    name_var = tk.StringVar(value=itm[1] if itm else '')
                    tk.Entry(form, textvariable=name_var, width=34).grid(row=0, column=1, sticky='w')
                    tk.Label(form, text="Phone:", bg='white').grid(row=1, column=0, sticky='e', padx=5, pady=6)
                    phone_var = tk.StringVar(value=itm[2] if itm else '')
                    tk.Entry(form, textvariable=phone_var, width=34).grid(row=1, column=1, sticky='w')
                    tk.Label(form, text="Email:", bg='white').grid(row=2, column=0, sticky='e', padx=5, pady=6)
                    email_var = tk.StringVar(value=itm[3] if itm else '')
                    tk.Entry(form, textvariable=email_var, width=34).grid(row=2, column=1, sticky='w')
                    tk.Label(form, text="Trade:", bg='white').grid(row=3, column=0, sticky='e', padx=5, pady=6)
                    trade_var = tk.StringVar(value=itm[4] if itm else '')
                    tk.Entry(form, textvariable=trade_var, width=34).grid(row=3, column=1, sticky='w')
                    tk.Label(form, text="Experience (years):", bg='white').grid(row=4, column=0, sticky='e', padx=5, pady=6)
                    exp_var = tk.StringVar(value=str(itm[5]) if itm else '0')
                    tk.Entry(form, textvariable=exp_var, width=12).grid(row=4, column=1, sticky='w')
                    tk.Label(form, text="Status:", bg='white').grid(row=5, column=0, sticky='e', padx=5, pady=6)
                    status_var = tk.StringVar(value=itm[6] if itm else 'Active')
                    status_cb = ttk.Combobox(form, textvariable=status_var, state='readonly', width=16)
                    status_cb['values'] = ['Active','Inactive','On Leave']
                    status_cb.grid(row=5, column=1, sticky='w')

                    def save():
                        try:
                            name = name_var.get().strip()
                            if not name:
                                messagebox.showwarning("Validation", "Full Name is required.")
                                return
                            phone = phone_var.get().strip()
                            email = email_var.get().strip()
                            trade = trade_var.get().strip()
                            try:
                                exp = int(exp_var.get().strip() or '0')
                            except Exception:
                                messagebox.showwarning("Validation", "Experience must be an integer.")
                                return
                            status = status_var.get().strip() or 'Active'
                            conn = self.db_manager.create_connection()
                            cur = conn.cursor()
                            if edit:
                                wid = int(itm[0])
                                cur.execute(
                                    """
                                    UPDATE workers
                                    SET full_name=?, phone=?, email=?, trade=?, experience_years=?, status=?
                                    WHERE id=?
                                    """,
                                    (name, phone, email, trade, exp, status, wid)
                                )
                            else:
                                cur.execute(
                                    """
                                    INSERT INTO workers (full_name, phone, email, trade, experience_years, status, created_date, owner_id)
                                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                                    """,
                                    (name, phone, email, trade, exp, status, date.today().isoformat(), self.current_user['id'])
                                )
                            conn.commit()
                            conn.close()
                            try:
                                self.log_audit_action(self.current_user['id'], "Save Worker", name)
                            except Exception:
                                pass
                            messagebox.showinfo("Success", "Worker saved.")
                            dlg.destroy()
                            load_workers()
                        except Exception as e:
                            try:
                                messagebox.showerror("Error", f"Failed to save: {str(e)}")
                            except Exception:
                                pass

                    btn_row = tk.Frame(dlg, bg='white')
                    btn_row.pack(fill='x', padx=12, pady=(0, 12))
                    tk.Button(btn_row, text="Save", bg="#27ae60", fg="white", command=save).pack(side='left')
                    tk.Button(btn_row, text="Cancel", bg="#e74c3c", fg="white", command=dlg.destroy).pack(side='right')
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to open form: {str(e)}")
                    except Exception:
                        pass

            def delete_worker():
                try:
                    sel = tree.selection()
                    if not sel:
                        messagebox.showwarning("Delete", "Select a worker to delete.")
                        return
                    item = tree.item(sel[0], 'values')
                    wid, name = item[0], item[1]
                    if not messagebox.askyesno("Confirm", f"Delete worker '{name}'?"):
                        return
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("DELETE FROM workers WHERE id=?", (wid,))
                    conn.commit()
                    conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Delete Worker", name)
                    except Exception:
                        pass
                    load_workers()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to delete: {str(e)}")
                    except Exception:
                        pass

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"workers_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Workers", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"),("All files","*.*")])
                    if not filename:
                        return
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT id, full_name, phone, email, trade, COALESCE(experience_years,0), COALESCE(status,'Active'), created_date FROM workers ORDER BY created_date DESC")
                    rows = cur.fetchall()
                    conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(["ID","Full Name","Phone","Email","Trade","Experience","Status","Created Date"])
                        for r in rows:
                            writer.writerow(r)
                    messagebox.showinfo("Export", "Workers exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            # Bind search
            search_var.trace('w', lambda *a: load_workers())

            # Context menu
            def context_menu(event):
                selection = tree.selection()
                menu = tk.Menu(win, tearoff=0)
                menu.add_command(label="Add Worker", command=lambda: add_edit_worker())
                if selection:
                    menu.add_command(label="Edit", command=lambda: add_edit_worker(edit=True))
                    menu.add_command(label="Delete", command=lambda: delete_worker())
                try:
                    menu.tk_popup(event.x_root, event.y_root)
                finally:
                    menu.grab_release()
            tree.bind("<Button-3>", context_menu)
            tree.bind('<Double-1>', lambda e: add_edit_worker(edit=True))

            # Shortcuts
            win.bind('<F5>', lambda e: load_workers())
            win.bind('<Escape>', lambda e: win.destroy())

            # Initial load
            load_workers()

            # Audit
            try:
                self.log_audit_action(self.current_user['id'], "Access Workers", "Opened worker management")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Manage Workers: {str(e)}")
            except Exception:
                pass


# ================= view applications ===================

    def show_view_inventory(self, preselected_store_id=None):
        try:
            win = tk.Toplevel(self.root)
            win.title("View Inventory")
            win.geometry("1050x650")
            win.configure(bg='white')
            win.grab_set()
            _preselect_store_id = preselected_store_id

            # Header
            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Inventory Overview", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filt = tk.LabelFrame(win, text="Filters", bg='white')
            filt.pack(fill='x', padx=10, pady=(0,10))

            tk.Label(filt, text="Store:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            store_var = tk.StringVar()
            store_cb = ttk.Combobox(filt, textvariable=store_var, state='readonly', width=30)
            store_cb.grid(row=0, column=1, sticky='w', padx=5, pady=6)

            # Header badge to display the current store selection
            store_display_var = tk.StringVar(value="Store:")
            try:
                store_badge = tk.Label(header, textvariable=store_display_var,
                                       bg='white', fg='#2c3e50', font=('Arial', 11, 'bold'))
                store_badge.pack(side='right')
            except Exception:
                pass

            def _update_store_display():
                try:
                    sel = (store_var.get() or '').strip()
                    store_display_var.set(f"Store: {sel if sel else '(none selected)'}")
                except Exception:
                    try:
                        store_display_var.set("Store: (none selected)")
                    except Exception:
                        pass

            # Update the header badge when store changes
            try:
                store_var.trace('w', lambda *a: _update_store_display())
            except Exception:
                pass

            tk.Label(filt, text="Category:", bg='white').grid(row=0, column=2, sticky='e', padx=5, pady=6)
            cat_var = tk.StringVar(value='All')
            cat_cb = ttk.Combobox(filt, textvariable=cat_var, state='readonly', width=28)
            cat_cb.grid(row=0, column=3, sticky='w', padx=5, pady=6)

            tk.Label(filt, text="Search:", bg='white').grid(row=0, column=4, sticky='e', padx=5, pady=6)
            q_var = tk.StringVar()
            tk.Entry(filt, textvariable=q_var, width=28).grid(row=0, column=5, sticky='w', padx=5, pady=6)

            tk.Label(filt, text="Stock:", bg='white').grid(row=0, column=6, sticky='e', padx=5, pady=6)
            stock_var = tk.StringVar(value='All')
            stock_cb = ttk.Combobox(filt, textvariable=stock_var, state='readonly', width=14)
            stock_cb['values'] = ['All','Low (<= Reorder)','OK (> Reorder)']
            stock_cb.grid(row=0, column=7, sticky='w', padx=5, pady=6)

            act = tk.Frame(filt, bg='white')
            act.grid(row=0, column=8, padx=5, pady=6, sticky='w')
            refresh_btn = tk.Button(act, text="Refresh", bg="#3498db", fg="white")
            refresh_btn.pack(side='left')
            export_btn = tk.Button(act, text="Export CSV")
            export_btn.pack(side='left', padx=6)

            # Summary cards
            cards = tk.Frame(win, bg='white')
            cards.pack(fill='x', padx=10, pady=(0,5))
            items_var = tk.StringVar(value='0')
            qty_var = tk.StringVar(value='0')
            value_var = tk.StringVar(value='0')
            low_var = tk.StringVar(value='0')

            def make_card(parent, title, var, color):
                f = tk.Frame(parent, bg=color, width=200, height=70)
                f.pack(side='left', padx=8, pady=5)
                f.pack_propagate(False)
                tk.Label(f, textvariable=var, font=('Arial', 20, 'bold'), bg=color, fg='white').pack(expand=True)
                tk.Label(f, text=title, font=('Arial', 10), bg=color, fg='white').pack()
                return f

            make_card(cards, "Distinct Items", items_var, "#9b59b6")
            make_card(cards, "Total Quantity", qty_var, "#2ecc71")
            make_card(cards, "Total Value (FCFA)", value_var, "#3498db")
            make_card(cards, "Low Stock Items", low_var, "#e67e22")

            # Table
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Store","Material","Category","Qty","Unit","Unit Price","Reorder","Total Value","Last Updated")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=120 if c not in ("Material","Store") else 180)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Actions
            actions = tk.Frame(win, bg='white')
            actions.pack(fill='x', padx=10)
            transfer_btn = tk.Button(actions, text="Transfer Material", bg="#2ecc71", fg="white")
            transfer_btn.pack(side='left', padx=(0,6), pady=4)
            reorder_btn = tk.Button(actions, text="Set Reorder Level", bg="#f39c12", fg="white")
            reorder_btn.pack(side='left', padx=6, pady=4)
            history_btn = tk.Button(actions, text="Movement History", bg="#17a2b8", fg="white")
            history_btn.pack(side='left', padx=6, pady=4)
            pdf_btn = tk.Button(actions, text="Export PDF Report", bg="#9b59b6", fg="white")
            pdf_btn.pack(side='left', padx=6, pady=4)

            # Manager-only: Consume material (for contract/non-retail stores)
            try:
                _role_for_consume = self.current_user.get('role') if getattr(self, 'current_user', None) else None
            except Exception:
                _role_for_consume = None
            consume_btn = None
            if _role_for_consume == 'manager':
                consume_btn = tk.Button(actions, text="Consume", bg="#8e44ad", fg="white")
                consume_btn.pack(side='left', padx=6, pady=4)

            def _get_selected_context():
                sel = tree.selection()
                if not sel:
                    messagebox.showwarning("Selection", "Please select an inventory row first.")
                    return None
                try:
                    inv_id = int(tree.item(sel[0])['values'][0])
                except Exception:
                    messagebox.showwarning("Selection", "Invalid selection.")
                    return None
                meta = inv_meta.get(inv_id)
                # Fallback if meta not populated
                if not meta:
                    try:
                        conn = self.db_manager.create_connection(); cur = conn.cursor()
                        cur.execute("SELECT store_id, material_id FROM inventory WHERE id=?", (inv_id,))
                        r = cur.fetchone(); conn.close()
                        if r:
                            meta = {'store_id': int(r[0]), 'material_id': int(r[1]), 'store_name': tree.item(sel[0])['values'][1], 'material_name': tree.item(sel[0])['values'][2]}
                    except Exception:
                        meta = None
                if not meta:
                    messagebox.showerror("Inventory", "Failed to resolve selected inventory record.")
                    return None
                meta['inv_id'] = inv_id
                # Capture reorder for defaults
                try:
                    meta['reorder'] = tree.item(sel[0])['values'][7]
                except Exception:
                    pass
                return meta

            def _has_inventory_permission(store_id: int) -> bool:
                try:
                    role = self.current_user.get('role') if getattr(self, 'current_user', None) else None
                    if role == 'administrator':
                        return True
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT owner_id, manager_id FROM stores WHERE id=?", (store_id,))
                    row = cur.fetchone(); conn.close()
                    if not row:
                        return False
                    owner_id, manager_id = row
                    uid = self.current_user.get('id') if getattr(self, 'current_user', None) else None
                    if uid is None:
                        return False
                    if owner_id == uid:
                        return True
                    if manager_id == uid and self.current_user.get('role') in ('manager','retail_store'):
                        return True
                    return False
                except Exception:
                    return False

            def do_set_reorder():
                ctx = _get_selected_context()
                if not ctx:
                    return
                if not _has_inventory_permission(ctx['store_id']):
                    messagebox.showwarning("Access Denied", "You don't have permission to change this store's inventory.")
                    return
                try:
                    current_val = None
                    try:
                        current_val = float(str(ctx.get('reorder', '')).replace(',', '')) if ctx.get('reorder') not in (None, '') else None
                    except Exception:
                        current_val = None
                    from tkinter import simpledialog as _sd
                    new_val = _sd.askfloat("Set Reorder Level",
                                           f"Set new reorder level for {ctx['material_name']} at {ctx['store_name']}:",
                                           initialvalue=current_val if current_val is not None else 0.0,
                                           minvalue=0.0)
                    if new_val is None:
                        return
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("UPDATE inventory SET reorder_level = ?, last_updated = ? WHERE id = ?",
                                (float(new_val), datetime.now().isoformat(sep=' '), ctx['inv_id']))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Set Reorder Level", json.dumps({"inventory_id": ctx['inv_id'], "reorder_level": new_val}))
                    except Exception:
                        pass
                    refresh()
                    messagebox.showinfo("Reorder Level", "Reorder level updated.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to update reorder level: {str(e)}")
                    except Exception:
                        pass

            def do_transfer():
                ctx = _get_selected_context()
                if not ctx:
                    return
                if not _has_inventory_permission(ctx['store_id']):
                    messagebox.showwarning("Access Denied", "You don't have permission to transfer from this store.")
                    return
                try:
                    # Open transfer UI; preselection not supported yet, show context tip
                    self.show_transfer_products()
                    try:
                        messagebox.showinfo("Transfer",
                                             f"Hint: You selected {ctx['material_name']} from {ctx['store_name']}.\n"
                                             f"Use these in the New Transfer tab.")
                    except Exception:
                        pass
                except Exception as e:
                    try:
                        messagebox.showerror("Transfer", f"Failed to open transfer UI: {str(e)}")
                    except Exception:
                        pass

            def do_history():
                ctx = _get_selected_context()
                if not ctx:
                    return
                try:
                    win2 = tk.Toplevel(win); win2.title(f"Movement History - {ctx['material_name']} @ {ctx['store_name']}"); win2.geometry("900x520"); win2.configure(bg='white'); win2.grab_set()
                    header = tk.Frame(win2, bg='white'); header.pack(fill='x', padx=10, pady=8)
                    tk.Label(header, text=f"Movement History - {ctx['material_name']} @ {ctx['store_name']}", font=('Arial',14,'bold'), bg='white').pack(side='left')
                    act = tk.Frame(header, bg='white'); act.pack(side='right')
                    export_btn2 = tk.Button(act, text="Export CSV", bg="#6c757d", fg="white"); export_btn2.pack(side='left', padx=6)
                    close_btn2 = tk.Button(act, text="Close", command=win2.destroy, bg="#dc3545", fg="white"); close_btn2.pack(side='left')
                    frame2 = tk.Frame(win2, bg='white'); frame2.pack(fill='both', expand=True, padx=10, pady=10)
                    cols2 = ("Date","Type","Qty","Unit Price","Total","Customer","User")
                    tree2 = ttk.Treeview(frame2, columns=cols2, show='headings')
                    for c in cols2:
                        tree2.heading(c, text=c); tree2.column(c, width=120 if c not in ("Customer","User") else 160)
                    tree2.pack(fill='both', expand=True, side='left')
                    sy2 = ttk.Scrollbar(frame2, orient='vertical', command=tree2.yview); tree2.configure(yscrollcommand=sy2.set); sy2.pack(side='right', fill='y')
                    def load_hist():
                        try:
                            conn = self.db_manager.create_connection(); cur = conn.cursor()
                            cur.execute(
                                """
                                SELECT t.transaction_date, t.transaction_type, t.quantity, t.unit_price, t.total_amount, COALESCE(t.customer_name,''), COALESCE(u.full_name,u.username)
                                FROM transactions t LEFT JOIN users u ON u.id = t.user_id
                                WHERE t.store_id = ? AND t.material_id = ?
                                ORDER BY t.transaction_date DESC
                                """, (ctx['store_id'], ctx['material_id']))
                            rows = cur.fetchall(); conn.close()
                        except Exception as e:
                            try:
                                messagebox.showerror("History", f"Failed to load: {str(e)}")
                            except Exception:
                                pass
                            rows = []
                        for it in tree2.get_children():
                            tree2.delete(it)
                        for r in rows:
                            d, typ, q, up, tot, cust, usr = r
                            try:
                                upf = f"{float(up):,.0f}" if up is not None else ''
                            except Exception:
                                upf = up
                            try:
                                totf = f"{float(tot):,.0f}" if tot is not None else ''
                            except Exception:
                                totf = tot
                            tree2.insert('', 'end', values=(d, typ, q, upf, totf, cust, usr))
                    def export_hist():
                        try:
                            from tkinter import filedialog as fd
                            default_name = f"movement_{ctx['store_id']}_{ctx['material_id']}.csv"
                            filename = fd.asksaveasfilename(title="Export Movement", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"),("All files","*.*")])
                            if not filename:
                                return
                            conn = self.db_manager.create_connection(); cur = conn.cursor()
                            cur.execute(
                                """
                                SELECT t.transaction_date, t.transaction_type, t.quantity, t.unit_price, t.total_amount, COALESCE(t.customer_name,''), COALESCE(u.full_name,u.username)
                                FROM transactions t LEFT JOIN users u ON u.id = t.user_id
                                WHERE t.store_id = ? AND t.material_id = ?
                                ORDER BY t.transaction_date DESC
                                """, (ctx['store_id'], ctx['material_id']))
                            rows = cur.fetchall(); conn.close()
                            import csv
                            with open(filename, 'w', newline='', encoding='utf-8') as f:
                                w = csv.writer(f); w.writerow(cols2)
                                for r in rows:
                                    w.writerow(r)
                            messagebox.showinfo("Export", "Movement exported successfully.")
                        except Exception as e:
                            try:
                                messagebox.showerror("Export", f"Failed to export: {str(e)}")
                            except Exception:
                                pass
                    export_btn2.config(command=export_hist)
                    load_hist()
                except Exception as e:
                    try:
                        messagebox.showerror("History", f"Failed to open: {str(e)}")
                    except Exception:
                        pass

            def do_pdf():
                try:
                    from tkinter import filedialog as fd
                    filename = fd.asksaveasfilename(title="Export Inventory PDF", defaultextension=".pdf", filetypes=[("PDF files","*.pdf"),("All files","*.*")])
                    if not filename:
                        return
                    # Collect current table data
                    data = [["ID","Store","Material","Category","Qty","Unit","Unit Price","Reorder","Total","Updated"]]
                    for it in tree.get_children():
                        data.append(list(tree.item(it)['values']))
                    total_items = items_var.get(); total_qty_str = qty_var.get(); total_val_str = value_var.get(); low_str = low_var.get()
                    filt_txt = f"Store: {store_var.get()} | Category: {cat_var.get()} | Stock: {stock_var.get()} | Search: {q_var.get()}"
                    summary_txt = f"Distinct Items: {total_items} | Total Qty: {total_qty_str} | Total Value (FCFA): {total_val_str} | Low Stock: {low_str}"
                    # Try reportlab
                    try:
                        from reportlab.lib.pagesizes import A4
                        from reportlab.lib import colors
                        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
                        from reportlab.lib.styles import getSampleStyleSheet
                        doc = SimpleDocTemplate(filename, pagesize=A4)
                        styles = getSampleStyleSheet(); story = []
                        story.append(Paragraph("Inventory Report", styles['Title']))
                        story.append(Paragraph(filt_txt, styles['Normal']))
                        story.append(Spacer(1, 8))
                        story.append(Paragraph(summary_txt, styles['Normal']))
                        story.append(Spacer(1, 12))
                        tbl = Table(data, repeatRows=1)
                        tbl.setStyle(TableStyle([
                            ('BACKGROUND', (0,0), (-1,0), colors.lightgrey),
                            ('GRID', (0,0), (-1,-1), 0.5, colors.grey),
                            ('FONTSIZE', (0,0), (-1,-1), 8),
                            ('ALIGN', (4,1), (8,-1), 'RIGHT')
                        ]))
                        story.append(tbl)
                        doc.build(story)
                        messagebox.showinfo("PDF", f"Inventory report exported to:\n{filename}")
                    except Exception:
                        # Fallback to text
                        alt = filename[:-4] + ".txt" if filename.lower().endswith('.pdf') else filename + ".txt"
                        with open(alt, 'w', encoding='utf-8') as f:
                            from datetime import datetime as _dt
                            f.write(f"Inventory Report\nGenerated: {_dt.now().isoformat(sep=' ')}\n{filt_txt}\n{summary_txt}\n\n")
                            headers = data[0]
                            f.write(" | ".join([str(h) for h in headers]) + "\n")
                            f.write("-"*120 + "\n")
                            for row in data[1:]:
                                f.write(" | ".join([str(x) for x in row]) + "\n")
                        messagebox.showinfo("Export", f"Reportlab not available. Saved TXT report:\n{alt}")
                except Exception as e:
                    try:
                        messagebox.showerror("Export", f"Failed to export PDF: {str(e)}")
                    except Exception:
                        pass

            def do_consume():
                ctx = _get_selected_context()
                if not ctx:
                    return
                # Only managers can use this quick consume in overview
                try:
                    role = self.current_user.get('role') if getattr(self, 'current_user', None) else None
                except Exception:
                    role = None
                if role != 'manager':
                    try:
                        messagebox.showwarning("Consume", "Only managers can consume from this view.")
                    except Exception:
                        pass
                    return
                if not _has_inventory_permission(ctx['store_id']):
                    try:
                        messagebox.showwarning("Access Denied", "You don't have permission to consume from this store.")
                    except Exception:
                        pass
                    return
                # Check that the store is NOT a retail store (manager working on contract/non-retail store)
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute(
                        """
                        SELECT COALESCE(i.quantity, 0.0), LOWER(COALESCE(u.role, ''))
                        FROM inventory i
                        JOIN stores s ON s.id = i.store_id
                        JOIN users u ON u.id = s.owner_id
                        WHERE i.id = ?
                        """,
                        (ctx['inv_id'],)
                    )
                    row = cur.fetchone()
                    if not row:
                        conn.close()
                        messagebox.showerror("Consume", "Inventory item not found.")
                        return
                    current_qty, owner_role = row
                    if owner_role == 'retail_store':
                        conn.close()
                        messagebox.showwarning("Consume Not Allowed", "This is a retail store. Managers can only consume in contract stores (non-retail).")
                        return
                    from tkinter import simpledialog as _sd
                    qty = _sd.askfloat("Consume Quantity", f"Enter quantity to consume for {ctx['material_name']} (available: {current_qty}):", minvalue=0.0)
                    if qty is None:
                        conn.close(); return
                    try:
                        qty_val = float(qty)
                    except Exception:
                        conn.close(); messagebox.showwarning("Validation", "Enter a valid quantity."); return
                    if qty_val <= 0:
                        conn.close(); messagebox.showwarning("Validation", "Quantity must be greater than zero."); return
                    if qty_val > float(current_qty or 0):
                        conn.close(); messagebox.showwarning("Validation", "Cannot consume more than available quantity."); return
                    note = _sd.askstring("Consumption Note", "Where/Why consumed (required):")
                    if note is None or not str(note).strip():
                        conn.close(); messagebox.showwarning("Validation", "Please provide a note explaining the consumption."); return
                    now = datetime.now().isoformat(sep=' ')
                    cur.execute(
                        """
                        UPDATE inventory
                        SET quantity = quantity - ?, last_updated = ?
                        WHERE id = ? AND quantity >= ?
                        """,
                        (qty_val, now, ctx['inv_id'], qty_val)
                    )
                    if cur.rowcount == 0:
                        conn.rollback(); conn.close(); messagebox.showerror("Consume", "Insufficient stock. Could not update."); return
                    conn.commit(); conn.close()
                    details = {
                        'inventory_id': ctx['inv_id'],
                        'store_id': ctx['store_id'],
                        'material_id': ctx['material_id'],
                        'consumed_qty': qty_val,
                        'note': note
                    }
                    try:
                        self.log_audit_action(self.current_user['id'], "Consume Material (Manager)", json.dumps(details))
                    except Exception:
                        pass
                    try:
                        messagebox.showinfo("Consumed", "Material consumption recorded.")
                    except Exception:
                        pass
                    try:
                        refresh()
                    except Exception:
                        pass
                except Exception as e:
                    try:
                        messagebox.showerror("Consume", f"Failed to consume: {str(e)}")
                    except Exception:
                        pass
            # Bind action buttons
            transfer_btn.config(command=do_transfer)
            reorder_btn.config(command=do_set_reorder)
            history_btn.config(command=do_history)
            pdf_btn.config(command=do_pdf)
            try:
                if consume_btn is not None:
                    consume_btn.config(command=do_consume)
            except Exception:
                pass

            # Data maps
            store_map = {}
            cat_list = ["All"]
            inv_meta = {}

            def load_stores_and_categories():
                try:
                    role = self.current_user.get('role') if getattr(self, 'current_user', None) else None
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    # Show all active stores for all roles
                    cur.execute("SELECT id, name FROM stores WHERE is_active=1 ORDER BY name")
                    stores = cur.fetchall()
                    cur.execute("SELECT DISTINCT category FROM building_materials ORDER BY category")
                    cats = [r[0] for r in cur.fetchall()]
                    conn.close()
                    values = []
                    for sid, name in stores:
                        disp = f"{name} (ID:{sid})"
                        store_map[disp] = sid
                        values.append(disp)
                    store_cb['values'] = values
                    # Preselect store if provided
                    pre_disp = None
                    try:
                        if _preselect_store_id is not None:
                            for d, s in store_map.items():
                                if s == _preselect_store_id:
                                    pre_disp = d; break
                    except Exception:
                        pre_disp = None
                    if pre_disp:
                        store_cb.set(pre_disp)
                    elif values:
                        store_cb.set(values[0])
                    else:
                        store_cb.set('')
                    try:
                        _update_store_display()
                    except Exception:
                        pass
                    cat_values = ["All"] + cats
                    cat_cb['values'] = cat_values
                    cat_cb.set("All")
                except Exception:
                    store_cb['values'] = []
                    store_cb.set('')
                    cat_cb['values'] = ["All"]
                    cat_cb.set("All")

            def refresh():
                try:
                    # Build query from filters
                    sid = store_map.get(store_var.get())
                    cat = cat_var.get()
                    q = q_var.get().strip()
                    stock = stock_var.get()
                    role = self.current_user.get('role') if getattr(self, 'current_user', None) else None
                    query = (
                        "SELECT i.id, s.name, bm.name, bm.category, i.quantity, bm.unit, i.unit_price, i.reorder_level, "
                        "(COALESCE(i.quantity,0)*COALESCE(i.unit_price,0)) AS total_value, i.last_updated "
                        "FROM inventory i "
                        "JOIN stores s ON s.id = i.store_id "
                        "JOIN building_materials bm ON bm.id = i.material_id "
                        "JOIN users u ON u.id = s.owner_id WHERE 1=1 AND s.is_active = 1 "
                    )
                    params = []
                    query += "AND i.store_id = ? "
                    params.append(sid if sid is not None else -1)
                    if cat and cat != 'All':
                        query += "AND bm.category = ? "
                        params.append(cat)
                    if q:
                        query += "AND (bm.name LIKE ? OR s.name LIKE ?) "
                        like = f"%{q}%"
                        params.extend([like, like])
                    if stock == 'Low (<= Reorder)':
                        query += "AND COALESCE(i.quantity,0) <= COALESCE(i.reorder_level,0) "
                    elif stock == 'OK (> Reorder)':
                        query += "AND COALESCE(i.quantity,0) > COALESCE(i.reorder_level,0) "
                    query += "ORDER BY s.name, bm.category, bm.name"

                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to load inventory: {str(e)}")
                    except Exception:
                        pass
                    rows = []

                # Populate table and compute summary
                for it in tree.get_children():
                    tree.delete(it)
                total_qty = 0.0
                total_val = 0.0
                low_count = 0
                # Prepare meta fetcher
                inv_meta.clear()
                meta_conn = None
                try:
                    meta_conn = self.db_manager.create_connection()
                    meta_cur = meta_conn.cursor()
                except Exception:
                    meta_conn = None
                    meta_cur = None
                for r in rows:
                    rid, store, mat, catg, qty, unit, price, reorder, tval, updated = r
                    # Fetch store_id and material_id for this inventory row into inv_meta
                    try:
                        if meta_cur is not None:
                            meta_cur.execute("SELECT store_id, material_id FROM inventory WHERE id = ?", (rid,))
                            mr = meta_cur.fetchone()
                            if mr:
                                inv_meta[int(rid)] = {'store_id': int(mr[0]), 'material_id': int(mr[1]), 'store_name': store, 'material_name': mat}
                    except Exception:
                        pass
                    try:
                        qty_fmt = int(qty) if qty is not None and float(qty).is_integer() else qty
                    except Exception:
                        qty_fmt = qty
                    try:
                        price_fmt = f"{float(price):,.0f}" if price is not None else ''
                    except Exception:
                        price_fmt = price
                    try:
                        tval_fmt = f"{float(tval):,.0f}" if tval is not None else ''
                    except Exception:
                        tval_fmt = tval
                    try:
                        reorder_fmt = int(reorder) if reorder is not None and float(reorder).is_integer() else reorder
                    except Exception:
                        reorder_fmt = reorder
                    tree.insert('', 'end', values=(rid, store, mat, catg, qty_fmt, unit, price_fmt, reorder_fmt, tval_fmt, updated), tags=("low",) if (qty is not None and reorder is not None and qty <= reorder) else ())
                    try:
                        total_qty += float(qty or 0)
                        total_val += float(tval or 0)
                        if qty is not None and reorder is not None and qty <= reorder:
                            low_count += 1
                    except Exception:
                        pass
                # Close meta connection
                try:
                    if meta_conn is not None:
                        meta_conn.close()
                except Exception:
                    pass
                items_var.set(str(len(rows)))
                try:
                    qty_disp = int(total_qty) if float(total_qty).is_integer() else total_qty
                except Exception:
                    qty_disp = total_qty
                qty_var.set(str(qty_disp))
                value_var.set(f"{total_val:,.0f}")
                low_var.set(str(low_count))

                # Coloring for low stock
                tree.tag_configure('low', background='#fdebd0')

                # Audit
                try:
                    self.log_audit_action(self.current_user['id'], "View Inventory (Overview)", json.dumps({
                        'store': store_var.get(), 'category': cat_var.get(), 'q': q_var.get(), 'stock': stock_var.get()
                    }))
                except Exception:
                    pass

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"inventory_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Inventory", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"),("All files","*.*")])
                    if not filename:
                        return
                    # Re-run same query as current filters
                    sid = store_map.get(store_var.get())
                    cat = cat_var.get()
                    q = q_var.get().strip()
                    stock = stock_var.get()
                    query = (
                        "SELECT i.id, s.name, bm.name, bm.category, i.quantity, bm.unit, i.unit_price, i.reorder_level, (COALESCE(i.quantity,0)*COALESCE(i.unit_price,0)) AS total_value, i.last_updated "
                        "FROM inventory i JOIN stores s ON s.id = i.store_id JOIN building_materials bm ON bm.id = i.material_id WHERE 1=1 "
                    )
                    params = []
                    query += "AND i.store_id = ? "
                    params.append(sid if sid is not None else -1)
                    if cat and cat != 'All':
                        query += "AND bm.category = ? "
                        params.append(cat)
                    if q:
                        query += "AND (bm.name LIKE ? OR s.name LIKE ?) "
                        like = f"%{q}%"
                        params.extend([like, like])
                    if stock == 'Low (<= Reorder)':
                        query += "AND COALESCE(i.quantity,0) <= COALESCE(i.reorder_level,0) "
                    elif stock == 'OK (> Reorder)':
                        query += "AND COALESCE(i.quantity,0) > COALESCE(i.reorder_level,0) "
                    query += "ORDER BY s.name, bm.category, bm.name"
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        w = csv.writer(f)
                        w.writerow(["ID","Store","Material","Category","Quantity","Unit","Unit Price","Reorder Level","Total Value","Last Updated"])
                        for r in rows:
                            w.writerow(r)
                    messagebox.showinfo("Export", "Inventory exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            # Wiring
            refresh_btn.config(command=refresh)
            export_btn.config(command=export_csv)
            store_var.trace('w', lambda *a: refresh())
            cat_var.trace('w', lambda *a: refresh())
            q_var.trace('w', lambda *a: refresh())
            stock_var.trace('w', lambda *a: refresh())

            # Load initial
            load_stores_and_categories()
            refresh()

            # Shortcuts
            win.bind('<F5>', lambda e: refresh())
            win.bind('<Escape>', lambda e: win.destroy())
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open View Inventory: {str(e)}")
            except Exception:
                pass

    def show_manager_sales(self):
        try:
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Sales", "You must be logged in to view Manager Sales.")
                return
            role = self.current_user.get('role')
            # Allow managers, retail_store owners, and administrators to view
            if role not in ("manager", "retail_store", "administrator"):
                messagebox.showwarning("Access Denied", "Only Managers, Store Owners, or Administrators can view Manager Sales.")
                return

            win = tk.Toplevel(self.root)
            win.title("Manager Sales")
            win.geometry("1000x620")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Sales History (Manager)", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filt = tk.Frame(win, bg='white')
            filt.pack(fill='x', padx=10)
            tk.Label(filt, text="From (YYYY-MM-DD):", bg='white').grid(row=0, column=0, sticky='e', padx=4, pady=6)
            from_var = tk.StringVar()
            tk.Entry(filt, textvariable=from_var, width=16).grid(row=0, column=1, sticky='w')
            tk.Label(filt, text="To (YYYY-MM-DD):", bg='white').grid(row=0, column=2, sticky='e', padx=6)
            to_var = tk.StringVar()
            tk.Entry(filt, textvariable=to_var, width=16).grid(row=0, column=3, sticky='w')
            tk.Label(filt, text="Store:", bg='white').grid(row=0, column=4, sticky='e', padx=6)
            store_var = tk.StringVar()
            store_cb = ttk.Combobox(filt, textvariable=store_var, state='readonly', width=32)
            store_cb.grid(row=0, column=5, sticky='w')
            tk.Label(filt, text="Search:", bg='white').grid(row=0, column=6, sticky='e', padx=6)
            q_var = tk.StringVar()
            tk.Entry(filt, textvariable=q_var, width=22).grid(row=0, column=7, sticky='w')
            refresh_btn = tk.Button(filt, text="Refresh", bg="#3498db", fg="white")
            refresh_btn.grid(row=0, column=8, padx=6)
            export_btn = tk.Button(filt, text="Export CSV")
            export_btn.grid(row=0, column=9)

            # Table
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("Timestamp","Store","Customer","Material","Quantity","Unit Price","Total Amount")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=140 if c in ("Timestamp","Store","Material") else 120)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            store_map = {"All Stores": None}
            def load_stores():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    if role == 'administrator':
                        cur.execute("SELECT id, name FROM stores ORDER BY name")
                        rows = cur.fetchall()
                    else:
                        # Managers see stores where they are manager; retail_store owners see their own stores
                        cur.execute("SELECT id, name FROM stores WHERE (manager_id = ? OR owner_id = ?) ORDER BY name", (self.current_user['id'], self.current_user['id']))
                        rows = cur.fetchall()
                    conn.close()
                    values = ["All Stores"]
                    for sid, name in rows:
                        disp = f"{sid} - {name}"; store_map[disp] = sid; values.append(disp)
                    store_cb['values'] = values; store_cb.set(values[0])
                except Exception:
                    store_cb['values'] = ["All Stores"]; store_cb.set("All Stores")

            def refresh():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    query = (
                        "SELECT t.timestamp, s.name, COALESCE(t.customer_name,''), bm.name, t.quantity, t.unit_price, t.total_amount "
                        "FROM transactions t JOIN stores s ON s.id = t.store_id JOIN building_materials bm ON bm.id = t.material_id WHERE 1=1 "
                    )
                    params = []
                    sid = store_map.get(store_var.get())
                    if role != 'administrator':
                        query += "AND (s.manager_id = ? OR s.owner_id = ?) "; params.extend([self.current_user['id'], self.current_user['id']])
                    if sid:
                        query += "AND t.store_id = ? "; params.append(sid)
                    f = from_var.get().strip()
                    if f:
                        query += "AND date(t.timestamp) >= ? "; params.append(f)
                    tval = to_var.get().strip()
                    if tval:
                        query += "AND date(t.timestamp) <= ? "; params.append(tval)
                    q = q_var.get().strip()
                    if q:
                        query += "AND (bm.name LIKE ? OR s.name LIKE ? OR COALESCE(t.customer_name,'') LIKE ?) "; like = f"%{q}%"; params.extend([like, like, like])
                    query += "ORDER BY t.timestamp DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Sales", f"Failed to load sales: {str(e)}")
                    except Exception:
                        pass
                    rows = []
                for it in tree.get_children():
                    tree.delete(it)
                for r in rows:
                    # Format some values for readability
                    ts, store, customer, material, qty, price, total = r
                    try:
                        qty_disp = int(qty) if qty is not None and float(qty).is_integer() else qty
                    except Exception:
                        qty_disp = qty
                    try:
                        price_disp = f"{float(price):,.0f}" if price is not None else ''
                    except Exception:
                        price_disp = price
                    try:
                        total_disp = f"{float(total):,.0f}" if total is not None else ''
                    except Exception:
                        total_disp = total
                    tree.insert('', 'end', values=(ts, store, customer, material, qty_disp, price_disp, total_disp))

            def export_csv():
                try:
                    from tkinter import filedialog as fd
                    default_name = f"manager_sales_{date.today().isoformat()}.csv"
                    filename = fd.asksaveasfilename(title="Export Sales", defaultextension=".csv", initialfile=default_name, filetypes=[("CSV files","*.csv"),("All files","*.*")])
                    if not filename:
                        return
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    query = (
                        "SELECT t.timestamp, s.name, COALESCE(t.customer_name,''), bm.name, t.quantity, t.unit_price, t.total_amount "
                        "FROM transactions t JOIN stores s ON s.id = t.store_id JOIN building_materials bm ON bm.id = t.material_id WHERE 1=1 "
                    )
                    params = []
                    sid = store_map.get(store_var.get())
                    if role != 'administrator':
                        query += "AND (s.manager_id = ? OR s.owner_id = ?) "; params.extend([self.current_user['id'], self.current_user['id']])
                    if sid:
                        query += "AND t.store_id = ? "; params.append(sid)
                    f = from_var.get().strip()
                    if f:
                        query += "AND date(t.timestamp) >= ? "; params.append(f)
                    tval = to_var.get().strip()
                    if tval:
                        query += "AND date(t.timestamp) <= ? "; params.append(tval)
                    q = q_var.get().strip()
                    if q:
                        query += "AND (bm.name LIKE ? OR s.name LIKE ? OR COALESCE(t.customer_name,'') LIKE ?) "; like = f"%{q}%"; params.extend([like, like, like])
                    query += "ORDER BY t.timestamp DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall(); conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        w = csv.writer(f)
                        w.writerow(["Timestamp","Store","Customer","Material","Quantity","Unit Price","Total Amount"])
                        for r in rows:
                            w.writerow(r)
                    messagebox.showinfo("Export", "Sales exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Export", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            # Wiring
            refresh_btn.config(command=refresh)
            export_btn.config(command=export_csv)
            store_var.trace('w', lambda *a: refresh())
            q_var.trace('w', lambda *a: refresh())

            # Init
            load_stores(); refresh()

            try:
                self.log_audit_action(self.current_user['id'], "Open Manager Sales", "")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Sales", f"Failed to open Manager Sales: {str(e)}")
            except Exception:
                pass

#============= show daily report =======================

    def show_daily_report(self):
        try:
            # Daily sales and inventory movement summary for today
            report_window = tk.Toplevel(self.root)
            report_window.title("Daily Report")
            report_window.geometry("900x600")
            report_window.configure(bg='white')
            report_window.grab_set()

            header = tk.Frame(report_window, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            today_str = datetime.now().strftime("%A, %B %d, %Y")
            tk.Label(header, text=f"Daily Report - {today_str}", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Summary cards
            cards = tk.Frame(report_window, bg='white')
            cards.pack(fill='x', padx=10)

            def make_card(parent, title, value, color):
                frame = tk.Frame(parent, bg=color, width=200, height=80)
                frame.pack(side='left', padx=8, pady=5)
                frame.pack_propagate(False)
                tk.Label(frame, text=str(value), font=('Arial', 22, 'bold'), bg=color, fg='white').pack(expand=True)
                tk.Label(frame, text=title, font=('Arial', 11), bg=color, fg='white').pack()
                return frame

            # Compute metrics
            conn = self.db_manager.create_connection()
            cur = conn.cursor()
            today_date = date.today().isoformat()

            # Total transactions today
            cur.execute("SELECT COUNT(*), COALESCE(SUM(total_amount), 0) FROM transactions WHERE date(transaction_date) = ?", (today_date,))
            tx_count, tx_total = cur.fetchone()

            # Top store by sales today
            cur.execute("""
                SELECT s.name, COALESCE(SUM(t.total_amount),0) AS total
                FROM stores s
                LEFT JOIN transactions t ON t.store_id = s.id AND date(t.timestamp)=?
                GROUP BY s.id
                ORDER BY total DESC
                LIMIT 1
            """, (today_date,))
            row = cur.fetchone()
            top_store = row[0] if row else 'N/A'
            top_store_total = row[1] if row else 0

            # Low stock items (reorder level exceeded)
            cur.execute("""
                SELECT COUNT(*)
                FROM inventory
                WHERE quantity <= reorder_level
            """)
            low_stock_count = cur.fetchone()[0]

            conn.close()

            make_card(cards, "Transactions Today", tx_count, "#3498db")
            make_card(cards, "Sales Total (FCFA)", f"{tx_total:,.0f}", "#2ecc71")
            make_card(cards, "Low Stock Items", low_stock_count, "#e67e22")
            make_card(cards, "Top Store", f"{top_store} ({top_store_total:,.0f})", "#9b59b6")

            # Detailed tables: Transactions today
            body = tk.Frame(report_window, bg='white')
            body.pack(fill='both', expand=True, padx=10, pady=10)

            notebook = ttk.Notebook(body)
            notebook.pack(fill='both', expand=True)

            # Transactions tab
            tx_tab = tk.Frame(notebook, bg='white')
            notebook.add(tx_tab, text='Transactions')

            tx_tree = ttk.Treeview(tx_tab, columns=("Time","Store","Customer","Material","Qty","Unit Price","Total"), show='headings')
            for col in ("Time","Store","Customer","Material","Qty","Unit Price","Total"):
                tx_tree.heading(col, text=col)
                tx_tree.column(col, width=120)
            tx_tree.pack(fill='both', expand=True, side='left', padx=5, pady=5)
            sy = ttk.Scrollbar(tx_tab, orient='vertical', command=tx_tree.yview)
            tx_tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Load transactions
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                cur.execute(
                    """
                    SELECT t.timestamp, s.name, COALESCE(t.customer_name,''), bm.name, t.quantity, t.unit_price, t.total_amount
                    FROM transactions t
                    JOIN stores s ON s.id = t.store_id
                    JOIN building_materials bm ON bm.id = t.material_id
                    WHERE date(t.timestamp)=?
                    ORDER BY t.timestamp DESC
                    """,
                    (today_date,)
                )
                for r in cur.fetchall():
                    # format numeric columns
                    values = list(r)
                    try:
                        values[4] = int(values[4]) if values[4] is not None else ''
                    except Exception:
                        pass
                    try:
                        values[5] = f"{float(values[5]):,.0f}" if values[5] is not None else ''
                    except Exception:
                        pass
                    try:
                        values[6] = f"{float(values[6]):,.0f}" if values[6] is not None else ''
                    except Exception:
                        pass
                    tx_tree.insert('', 'end', values=values)
                conn.close()
            except Exception as e:
                try:
                    messagebox.showerror("Error", f"Failed to load transactions: {str(e)}")
                except Exception:
                    pass

            # Low stock tab
            low_tab = tk.Frame(notebook, bg='white')
            notebook.add(low_tab, text='Low Stock')

            low_tree = ttk.Treeview(low_tab, columns=("Store","Material","Qty","Reorder","Last Updated"), show='headings')
            for col in ("Store","Material","Qty","Reorder","Last Updated"):
                low_tree.heading(col, text=col)
                low_tree.column(col, width=140)
            low_tree.pack(fill='both', expand=True, side='left', padx=5, pady=5)
            sy2 = ttk.Scrollbar(low_tab, orient='vertical', command=low_tree.yview)
            low_tree.configure(yscrollcommand=sy2.set)
            sy2.pack(side='right', fill='y')

            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                cur.execute(
                    """
                    SELECT s.name, bm.name, i.quantity, i.reorder_level, i.last_updated
                    FROM inventory i
                    JOIN stores s ON s.id = i.store_id
                    JOIN building_materials bm ON bm.id = i.material_id
                    WHERE i.quantity <= i.reorder_level
                    ORDER BY i.quantity ASC
                    """
                )
                for r in cur.fetchall():
                    low_tree.insert('', 'end', values=r)
                conn.close()
            except Exception as e:
                try:
                    messagebox.showerror("Error", f"Failed to load low stock list: {str(e)}")
                except Exception:
                    pass

            # Export button
            footer = tk.Frame(report_window, bg='white')
            footer.pack(fill='x', padx=10, pady=10)

            def export_csv():
                try:
                    # Create a simple CSV export for today's transactions
                    default_name = f"daily_report_{date.today().isoformat()}.csv"
                    from tkinter import filedialog as fd
                    filename = fd.asksaveasfilename(title="Export Daily Report",
                                                    defaultextension=".csv",
                                                    initialfile=default_name,
                                                    filetypes=[("CSV files","*.csv"), ("All files","*.*")])
                    if not filename:
                        return
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(
                        """
                        SELECT t.timestamp, s.name AS store, COALESCE(t.customer_name,''), bm.name AS material,
                               t.quantity, t.unit_price, t.total_amount
                        FROM transactions t
                        JOIN stores s ON s.id = t.store_id
                        JOIN building_materials bm ON bm.id = t.material_id
                        WHERE date(t.timestamp)=?
                        ORDER BY t.timestamp DESC
                        """,
                        (today_date,)
                    )
                    rows = cur.fetchall()
                    conn.close()
                    import csv
                    with open(filename, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerow(["Timestamp","Store","Customer","Material","Quantity","Unit Price","Total Amount"])
                        for r in rows:
                            writer.writerow(r)
                    messagebox.showinfo("Export", "Daily report exported successfully.")
                except Exception as e:
                    try:
                        messagebox.showerror("Error", f"Failed to export: {str(e)}")
                    except Exception:
                        pass

            tk.Button(footer, text="Export Transactions (CSV)", command=export_csv, bg="#3498db", fg="white").pack(side='left')

            # Log audit
            try:
                self.log_audit_action(self.current_user['id'], "View Daily Report", f"Date: {today_date}")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to open Daily Report: {str(e)}")
            except Exception:
                pass

    def show_edit_profile(self):
        import traceback
        try:
            print(f"[DEBUG] show_edit_profile called, current_user={getattr(self, 'current_user', None)}")
            # Simple profile editor for current user (job seeker or any role)
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Profile", "You must be logged in to edit your profile.")
                return

            # Fetch current profile data
            conn = self.db_manager.create_connection()
            cur = conn.cursor()
            cur.execute("SELECT username, full_name, email, phone, address FROM users WHERE id = ?", (self.current_user['id'],))
            row = cur.fetchone()
            print(f"[DEBUG] DB row: {row}")
            conn.close()
            if not row:
                messagebox.showerror("Error", f"No profile found for current user (id {self.current_user.get('id')}).")
                return
            username, full_name, email, phone, address = row

            win = tk.Toplevel(self.root)
            win.title("Edit Profile")
            win.geometry("420x420")
            win.configure(bg='#34495e')

            frm = tk.Frame(win, bg='#34495e', padx=20, pady=20)
            frm.pack(fill='both', expand=True)

            def add_row(label_text, initial_value="", show=None):
                rowf = tk.Frame(frm, bg='#34495e')
                rowf.pack(fill='x', pady=6)
                tk.Label(rowf, text=label_text, font=('Arial', 11), bg='#34495e', fg='white', width=14, anchor='w').pack(side='left')
                ent = tk.Entry(rowf, font=('Arial', 11), width=28, show=show)
                ent.insert(0, initial_value or "")
                ent.pack(side='left')
                return ent

            full_name_ent = add_row("Full Name:", full_name)
            email_ent = add_row("Email:", email)
            phone_ent = add_row("Phone:", phone)

            # Address as multiline
            addr_lbl = tk.Label(frm, text="Address:", font=('Arial', 11), bg='#34495e', fg='white')
            addr_lbl.pack(anchor='w')
            addr_txt = tk.Text(frm, height=4, width=38, font=('Arial', 11))
            addr_txt.insert('1.0', address or "")
            addr_txt.pack(pady=(2,8))

            # Optional: password change (current -> new -> confirm)
            tk.Label(frm, text="Change Password (optional)", font=('Arial', 11, 'bold'), bg='#34495e', fg='white').pack(anchor='w', pady=(8,4))
            current_pwd_ent = add_row("Current:", "", show='*')
            new_pwd_ent = add_row("New:", "", show='*')
            confirm_pwd_ent = add_row("Confirm:", "", show='*')

            def valid_email(val):
                if not val:
                    return True
                import re
                return re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', val) is not None

            def valid_phone(val):
                if not val:
                    return True
                import re
                pattern = r'^(\+237|237)?[6-9]\d{8}$'
                return re.match(pattern, val.replace(' ', '').replace('-', '')) is not None

            def save_profile():
                new_full = full_name_ent.get().strip()
                new_email = email_ent.get().strip()
                new_phone = phone_ent.get().strip()
                new_addr = addr_txt.get('1.0', 'end-1c').strip()

                if not new_full:
                    messagebox.showerror("Validation", "Full Name is required.")
                    return
                if not valid_email(new_email):
                    messagebox.showerror("Validation", "Please enter a valid email address.")
                    return
                if not valid_phone(new_phone):
                    messagebox.showerror("Validation", "Please enter a valid Cameroon phone number (+237XXXXXXXXX).")
                    return

                cur_pwd = current_pwd_ent.get()
                new_pwd = new_pwd_ent.get()
                conf_pwd = confirm_pwd_ent.get()

                # Build update statement
                try:
                    conn2 = self.db_manager.create_connection()
                    cur2 = conn2.cursor()

                    # Update basic profile fields
                    cur2.execute(
                        "UPDATE users SET full_name = ?, email = ?, phone = ?, address = ? WHERE id = ?",
                        (new_full, new_email, new_phone, new_addr, self.current_user['id'])
                    )

                    # Update password if provided
                    if new_pwd or conf_pwd or cur_pwd:
                        if not cur_pwd:
                            messagebox.showerror("Validation", "Please enter your current password to change it.")
                            conn2.rollback(); conn2.close(); return
                        if len(new_pwd) < 6:
                            messagebox.showerror("Validation", "New password must be at least 6 characters.")
                            conn2.rollback(); conn2.close(); return
                        if new_pwd != conf_pwd:
                            messagebox.showerror("Validation", "New password and confirmation do not match.")
                            conn2.rollback(); conn2.close(); return
                        # Verify current password
                        cur2.execute("SELECT password_hash FROM users WHERE id = ?", (self.current_user['id'],))
                        ph = cur2.fetchone()
                        if not ph or not self.security_manager.verify_password(cur_pwd, ph[0]):
                            messagebox.showerror("Validation", "Current password is incorrect.")
                            conn2.rollback(); conn2.close(); return
                        # Apply new password
                        cur2.execute("UPDATE users SET password_hash = ? WHERE id = ?",
                                     (self.security_manager.hash_password(new_pwd), self.current_user['id']))

                    conn2.commit()
                    conn2.close()

                    # Update in-memory name for greeting
                    self.current_user['full_name'] = new_full
                    messagebox.showinfo("Profile", "Profile updated successfully.")
                    try:
                        win.destroy()
                    except Exception:
                        pass
                    # Refresh header/menu label by recreating menu
                    self.create_main_menu()
                except sqlite3.IntegrityError:
                    import traceback; traceback.print_exc()
                    messagebox.showerror("Profile", "Email already exists. Please use another.")
                except Exception as e:
                    import traceback; traceback.print_exc()
                    messagebox.showerror("Profile", f"Failed to update profile: {str(e)}")

            # Save/Cancel buttons
            btns = tk.Frame(frm, bg='#34495e')
            btns.pack(fill='x', pady=(10,0))
            tk.Button(btns, text="Save", bg="#27ae60", fg="white", command=save_profile).pack(side='left')
            tk.Button(btns, text="Cancel", bg="#7f8c8d", fg="white", command=win.destroy).pack(side='right')

            # Ensure window is visible and focused
            try:
                win.update_idletasks()
                win.lift()
                win.focus_force()
                w = win.winfo_width(); h = win.winfo_height()
                ws = win.winfo_screenwidth(); hs = win.winfo_screenheight()
                x = (ws // 2) - (w // 2); y = (hs // 2) - (h // 2)
                win.geometry(f"+{x}+{y}")
                win.grab_set()
            except Exception:
                traceback.print_exc()
        except Exception:
            traceback.print_exc()
            try:
                messagebox.showerror("Unhandled error", "An error occurred. See console for details.")
            except Exception:
                pass

#============ upload resume ======================
    def show_upload_resume(self):
        try:
            # Only for logged-in users; ideally job seekers
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Resume", "You must be logged in to upload a resume.")
                return
            # Ensure users table has resume_path column (backward compatible)
            try:
                conn = self.db_manager.create_connection()
                cur = conn.cursor()
                try:
                    cur.execute("ALTER TABLE users ADD COLUMN resume_path TEXT")
                except Exception:
                    pass
                conn.commit(); conn.close()
            except Exception:
                pass

            # Build a small manager window
            win = tk.Toplevel(self.root)
            win.title("Upload Resume")
            win.geometry("520x260")
            win.configure(bg='#34495e')
            win.grab_set()

            frame = tk.Frame(win, bg='#34495e', padx=20, pady=20)
            frame.pack(fill='both', expand=True)

            tk.Label(frame, text="Manage Your Resume", font=('Arial', 14, 'bold'), bg='#34495e', fg='white').pack(anchor='w', pady=(0,10))

            info_var = tk.StringVar(value="Loading current resume info...")
            path_var = tk.StringVar(value="")

            info_lbl = tk.Label(frame, textvariable=info_var, font=('Arial', 10), bg='#34495e', fg='#ecf0f1', justify='left')
            info_lbl.pack(fill='x')

            def load_status():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT resume_path FROM users WHERE id = ?", (self.current_user['id'],))
                    row = cur.fetchone()
                    conn.close()
                    current = row[0] if row else None
                    path_var.set(current or "")
                    if current and os.path.exists(current):
                        size = os.path.getsize(current)
                        info_var.set(f"Current resume: {os.path.basename(current)} (size: {size:,} bytes)\nLocation: {current}")
                    elif current:
                        info_var.set(f"Current resume path is saved, but the file was not found:\n{current}")
                    else:
                        info_var.set("No resume uploaded yet.")
                except Exception as e:
                    info_var.set(f"Failed to load status: {str(e)}")

            def ensure_folder():
                try:
                    base = os.path.join(os.getcwd(), 'uploads')
                    resumes = os.path.join(base, 'resumes')
                    os.makedirs(resumes, exist_ok=True)
                    return resumes
                except Exception:
                    return os.getcwd()

            def choose_and_upload():
                try:
                    filetypes = [
                        ("Documents", "*.pdf *.doc *.docx"),
                        ("Images", "*.png *.jpg *.jpeg"),
                        ("All files", "*.*")
                    ]
                    filename = filedialog.askopenfilename(title="Select Resume", filetypes=filetypes)
                    if not filename:
                        return
                    # Validate extension
                    ext = os.path.splitext(filename)[1].lower()
                    allowed = {'.pdf', '.doc', '.docx', '.png', '.jpg', '.jpeg'}
                    if ext not in allowed:
                        messagebox.showerror("Resume", "Unsupported file type. Please select PDF/DOC/DOCX/PNG/JPG.")
                        return
                    # Confirm replace if exists
                    if path_var.get():
                        if not messagebox.askyesno("Replace", "You already have a resume uploaded. Replace it?"):
                            return
                    # Copy to uploads/resumes with sanitized name
                    target_dir = ensure_folder()
                    ts = datetime.now().strftime('%Y%m%d%H%M%S')
                    safe_name = f"user{self.current_user['id']}_{ts}{ext}"
                    target_path = os.path.join(target_dir, safe_name)
                    # Perform copy
                    try:
                        # Use binary read/write to avoid extra deps
                        with open(filename, 'rb') as src, open(target_path, 'wb') as dst:
                            dst.write(src.read())
                    except Exception as e:
                        messagebox.showerror("Resume", f"Failed to copy file: {str(e)}")
                        return
                    # Save to DB
                    try:
                        conn = self.db_manager.create_connection()
                        cur = conn.cursor()
                        cur.execute("UPDATE users SET resume_path = ? WHERE id = ?", (target_path, self.current_user['id']))
                        conn.commit(); conn.close()
                        self.log_audit_action(self.current_user['id'], "Upload Resume", os.path.basename(target_path))
                        messagebox.showinfo("Resume", "Resume uploaded successfully.")
                        load_status()
                    except Exception as e:
                        messagebox.showerror("Resume", f"Failed to save resume: {str(e)}")
                except Exception as e:
                    try:
                        messagebox.showerror("Resume", f"Upload failed: {str(e)}")
                    except Exception:
                        pass

            def open_current():
                p = path_var.get()
                if not p:
                    messagebox.showinfo("Resume", "No resume to open.")
                    return
                if not os.path.exists(p):
                    messagebox.showerror("Resume", "The saved resume file was not found on disk.")
                    return
                try:
                    # Windows: open with default program
                    os.startfile(p)
                except Exception as e:
                    messagebox.showerror("Resume", f"Failed to open: {str(e)}")

            def remove_current():
                p = path_var.get()
                if not p:
                    messagebox.showinfo("Resume", "No resume to remove.")
                    return
                if not messagebox.askyesno("Remove", "Remove your current resume? This cannot be undone."):
                    return
                try:
                    # Clear DB first
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("UPDATE users SET resume_path = NULL WHERE id = ?", (self.current_user['id'],))
                    conn.commit(); conn.close()
                    # Attempt to delete the file (ignore errors)
                    try:
                        if os.path.exists(p):
                            os.remove(p)
                    except Exception:
                        pass
                    self.log_audit_action(self.current_user['id'], "Remove Resume", os.path.basename(p))
                    messagebox.showinfo("Resume", "Resume removed.")
                    load_status()
                except Exception as e:
                    messagebox.showerror("Resume", f"Failed to remove resume: {str(e)}")

            # Buttons row
            btnf = tk.Frame(frame, bg='#34495e')
            btnf.pack(fill='x', pady=12)
            tk.Button(btnf, text="Upload/Replace", bg="#27ae60", fg="white", width=15, command=choose_and_upload).pack(side='left')
            tk.Button(btnf, text="Open", bg="#2980b9", fg="white", width=10, command=open_current).pack(side='left', padx=8)
            tk.Button(btnf, text="Remove", bg="#c0392b", fg="white", width=10, command=remove_current).pack(side='left')
            tk.Button(frame, text="Close", command=win.destroy, bg="#7f8c8d", fg="white", width=10).pack(anchor='e', pady=(8,0))

            load_status()
        except Exception as e:
            try:
                messagebox.showerror("Resume", f"Failed to open Upload Resume: {str(e)}")
            except Exception:
                pass
            
   #====================== job search ==========================         

    def show_search_jobs(self):
        try:
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Jobs", "You must be logged in to search jobs.")
                return
            win = tk.Toplevel(self.root)
            win.title("Search Jobs")
            win.geometry("900x600")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Find Jobs", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filters = tk.Frame(win, bg='white')
            filters.pack(fill='x', padx=10)
            tk.Label(filters, text="Keyword:", bg='white').grid(row=0, column=0, sticky='w')
            q_var = tk.StringVar()
            tk.Entry(filters, textvariable=q_var, width=30).grid(row=0, column=1, padx=6, pady=4)
            tk.Label(filters, text="Location:", bg='white').grid(row=0, column=2, sticky='w')
            loc_var = tk.StringVar()
            tk.Entry(filters, textvariable=loc_var, width=20).grid(row=0, column=3, padx=6, pady=4)
            tk.Label(filters, text="Salary:", bg='white').grid(row=0, column=4, sticky='w')
            salary_var = tk.StringVar()
            tk.Entry(filters, textvariable=salary_var, width=15).grid(row=0, column=5, padx=6, pady=4)
            tk.Label(filters, text="Status:", bg='white').grid(row=0, column=6, sticky='w')
            status_var = tk.StringVar(value='Open')
            status_cb = ttk.Combobox(filters, textvariable=status_var, values=['All','Open','Closed'], state='readonly', width=10)
            status_cb.grid(row=0, column=7, padx=6, pady=4)
            tk.Label(filters, text="Posted Since (YYYY-MM-DD):", bg='white').grid(row=1, column=0, columnspan=2, sticky='w')
            since_var = tk.StringVar()
            tk.Entry(filters, textvariable=since_var, width=20).grid(row=1, column=2, padx=6, pady=4, sticky='w')
            tk.Button(filters, text="Search", bg="#3498db", fg="white", command=lambda: refresh()).grid(row=1, column=3, padx=6)
            tk.Button(filters, text="Reset", command=lambda: do_reset()).grid(row=1, column=4, padx=6)

            # Results table
            table_frame = tk.Frame(win, bg='white')
            table_frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Title","Employer","Location","Salary","Posted","Deadline","Status")
            tree = ttk.Treeview(table_frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=120)
            tree.column("Title", width=220)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(table_frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Bottom actions
            actions = tk.Frame(win, bg='white')
            actions.pack(fill='x', padx=10, pady=(0,10))
            apply_btn = tk.Button(actions, text="Apply", bg="#27ae60", fg="white")
            view_btn = tk.Button(actions, text="View Details", bg="#2980b9", fg="white")
            refresh_btn = tk.Button(actions, text="Refresh")
            apply_btn.pack(side='left')
            view_btn.pack(side='left', padx=6)
            refresh_btn.pack(side='right')

            def do_reset():
                q_var.set("")
                loc_var.set("")
                status_var.set('Open')
                since_var.set("")
                refresh()

            def refresh():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    query = (
                        "SELECT j.id, j.title, COALESCE(u.full_name,u.username) AS employer, j.location, j.salary_range, j.posted_date, j.deadline, j.status "
                        "FROM jobs j JOIN users u ON u.id = j.employer_id WHERE 1=1 "
                    )
                    params = []
                    q = q_var.get().strip()
                    if q:
                        query += "AND (j.title LIKE ? OR j.description LIKE ? OR j.requirements LIKE ?) "
                        like = f"%{q}%"; params.extend([like, like, like])
                    loc = loc_var.get().strip()
                    if loc:
                        query += "AND (j.location LIKE ?) "
                        params.append(f"%{loc}%")
                    st = status_var.get()
                    if st and st != 'All':
                        query += "AND j.status = ? "
                        params.append(st)
                    since = since_var.get().strip()
                    if since:
                        query += "AND date(j.posted_date) >= ? "
                        params.append(since)
                    query += "ORDER BY j.posted_date DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall()
                    conn.close()
                    try:
                        print(f"[DEBUG] show_search_jobs.refresh loaded {len(rows)} rows")
                    except Exception:
                        pass
                    for it in tree.get_children():
                        tree.delete(it)
                    for r in rows:
                        tree.insert('', 'end', values=r)
                except Exception as e:
                    try:
                        messagebox.showerror("Jobs", f"Failed to search jobs: {str(e)}")
                    except Exception:
                        pass

            def get_selected_job_id():
                sel = tree.selection()
                if not sel:
                    return None
                vals = tree.item(sel[0], 'values')
                return vals[0] if vals else None

            def view_details():
                jid = get_selected_job_id()
                if not jid:
                    messagebox.showinfo("Jobs", "Select a job to view details.")
                    return
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute(
                        "SELECT j.title, j.description, COALESCE(u.full_name,u.username), j.location, j.salary_range, j.requirements, j.posted_date, j.deadline, j.status "
                        "FROM jobs j JOIN users u ON u.id = j.employer_id WHERE j.id = ?",
                        (jid,)
                    )
                    r = cur.fetchone(); conn.close()
                    if not r:
                        messagebox.showerror("Jobs", "Job not found.")
                        return
                    title, desc, employer, loc, salary, reqs, posted, deadline, status = r
                    info = (
                        f"Title: {title}\nEmployer: {employer}\nLocation: {loc or ''}\nSalary: {salary or ''}\n"
                        f"Posted: {posted or ''}\nDeadline: {deadline or ''}\nStatus: {status}\n\nDescription:\n{desc or ''}\n\nRequirements:\n{reqs or ''}"
                    )
                    # Show in a scrollable text window
                    d = tk.Toplevel(win); d.title("Job Details"); d.geometry("600x500"); d.configure(bg='white'); d.grab_set(); d.transient(win)
                    txt = tk.Text(d, wrap='word')
                    txt.pack(fill='both', expand=True)
                    txt.insert('1.0', info)
                    txt.config(state='disabled')
                    tk.Button(d, text="Close", command=d.destroy).pack(pady=6)
                except Exception as e:
                    messagebox.showerror("Jobs", f"Failed to load details: {str(e)}")

            def apply_to_job():
                # Only job seekers can apply
                try:
                    if self.current_user.get('role') != ROLE_JOB_SEEKER:
                        messagebox.showwarning("Jobs", "Only Job Seekers can apply to jobs.")
                        return
                    jid = get_selected_job_id()
                    if not jid:
                        messagebox.showinfo("Jobs", "Select a job to apply.")
                        return
                    # Check for existing application
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    cur.execute("SELECT COUNT(*) FROM job_applications WHERE job_id=? AND applicant_id=?", (jid, self.current_user['id']))
                    if cur.fetchone()[0] > 0:
                        conn.close()
                        messagebox.showinfo("Jobs", "You have already applied to this job.")
                        return
                    # Use stored resume if any, allow optional cover letter
                    cover_win = tk.Toplevel(win); cover_win.title("Apply - Cover Letter"); cover_win.geometry("500x300"); cover_win.configure(bg='white'); cover_win.grab_set(); cover_win.transient(win)
                    tk.Label(cover_win, text="Optional Cover Letter:", bg='white').pack(anchor='w', padx=10, pady=(10,0))
                    cover_txt = tk.Text(cover_win, height=10)
                    cover_txt.pack(fill='both', expand=True, padx=10, pady=6)
                    def submit_app():
                        try:
                            cover = cover_txt.get('1.0','end-1c').strip()
                            # get resume path
                            cur.execute("SELECT resume_path FROM users WHERE id=?", (self.current_user['id'],))
                            rp = cur.fetchone()
                            resume_path = rp[0] if rp else None
                            cur.execute(
                                "INSERT INTO job_applications(job_id, applicant_id, application_date, status, resume_path, cover_letter) VALUES (?,?,?,?,?,?)",
                                (jid, self.current_user['id'], date.today(), 'Submitted', resume_path, cover)
                            )
                            conn.commit(); conn.close()
                            self.log_audit_action(self.current_user['id'], "Apply Job", f"job_id={jid}")
                            messagebox.showinfo("Jobs", "Application submitted.")
                            cover_win.destroy()
                        except sqlite3.IntegrityError:
                            try:
                                conn.rollback(); conn.close()
                            except Exception:
                                pass
                            messagebox.showerror("Jobs", "Failed to submit (possible duplicate).")
                        except Exception as e:
                            try:
                                conn.rollback(); conn.close()
                            except Exception:
                                pass
                            messagebox.showerror("Jobs", f"Failed to submit: {str(e)}")
                    tk.Button(cover_win, text="Submit Application", bg="#27ae60", fg="white", command=submit_app).pack(pady=6)
                    tk.Button(cover_win, text="Cancel", command=cover_win.destroy).pack()
                except Exception as e:
                    try:
                        messagebox.showerror("Jobs", f"Failed to apply: {str(e)}")
                    except Exception:
                        pass

            # Wire buttons and events
            view_btn.config(command=view_details)
            apply_btn.config(command=apply_to_job)
            refresh_btn.config(command=refresh)
            q_var.trace('w', lambda *a: refresh())
            status_var.trace('w', lambda *a: refresh())

            # Initial load
            refresh()

            # Log
            try:
                self.log_audit_action(self.current_user['id'], "Open Job Search", "")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Jobs", f"Failed to open Job Search: {str(e)}")
            except Exception:
                pass

#===================== show applications ==============================

    def show_my_applications(self):
        try:
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Applications", "You must be logged in to view your applications.")
                return
            # Only meaningful for job seekers; allow others to view if needed
            win = tk.Toplevel(self.root)
            win.title("My Applications")
            win.geometry("950x600")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="My Job Applications", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters
            filters = tk.Frame(win, bg='white')
            filters.pack(fill='x', padx=10)
            tk.Label(filters, text="Keyword:", bg='white').grid(row=0, column=0, sticky='w')
            q_var = tk.StringVar()
            tk.Entry(filters, textvariable=q_var, width=30).grid(row=0, column=1, padx=6, pady=4)
            tk.Label(filters, text="Status:", bg='white').grid(row=0, column=2, sticky='w')
            status_var = tk.StringVar(value='All')
            status_cb = ttk.Combobox(filters, textvariable=status_var, values=['All','Submitted','Under Review','Interview','Rejected','Accepted','Withdrawn'], state='readonly', width=16)
            status_cb.grid(row=0, column=3, padx=6, pady=4)
            tk.Label(filters, text="From (YYYY-MM-DD):", bg='white').grid(row=1, column=0, sticky='w')
            from_var = tk.StringVar()
            tk.Entry(filters, textvariable=from_var, width=18).grid(row=1, column=1, padx=6, pady=4, sticky='w')
            tk.Label(filters, text="To (YYYY-MM-DD):", bg='white').grid(row=1, column=2, sticky='w')
            to_var = tk.StringVar()
            tk.Entry(filters, textvariable=to_var, width=18).grid(row=1, column=3, padx=6, pady=4, sticky='w')
            tk.Button(filters, text="Search", bg="#3498db", fg="white", command=lambda: refresh()).grid(row=0, column=4, padx=6)
            tk.Button(filters, text="Reset", command=lambda: do_reset()).grid(row=0, column=5, padx=6)

            # Table
            table = tk.Frame(win, bg='white')
            table.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("App ID","Job ID","Title","Employer","Location","Status","Applied On","Deadline")
            tree = ttk.Treeview(table, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=120)
            tree.column("Title", width=220)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(table, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Actions
            actions = tk.Frame(win, bg='white')
            actions.pack(fill='x', padx=10, pady=(0,10))
            view_btn = tk.Button(actions, text="View Details", bg="#2980b9", fg="white")
            open_resume_btn = tk.Button(actions, text="Open Resume")
            view_cover_btn = tk.Button(actions, text="View Cover Letter")
            withdraw_btn = tk.Button(actions, text="Withdraw", bg="#e67e22", fg="white")
            refresh_btn = tk.Button(actions, text="Refresh")
            view_btn.pack(side='left')
            open_resume_btn.pack(side='left', padx=6)
            view_cover_btn.pack(side='left', padx=6)
            withdraw_btn.pack(side='left', padx=6)
            refresh_btn.pack(side='right')

            def do_reset():
                q_var.set("")
                status_var.set('All')
                from_var.set("")
                to_var.set("")
                refresh()

            def refresh():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    query = (
                        "SELECT ja.id, j.id, j.title, COALESCE(u.full_name,u.username) AS employer, j.location, ja.status, ja.application_date, j.deadline "
                        "FROM job_applications ja "
                        "JOIN jobs j ON j.id = ja.job_id "
                        "JOIN users u ON u.id = j.employer_id "
                        "WHERE ja.applicant_id = ? "
                    )
                    params = [self.current_user['id']]
                    q = q_var.get().strip()
                    if q:
                        query += "AND (j.title LIKE ? OR u.full_name LIKE ? OR u.username LIKE ?) "
                        like = f"%{q}%"; params.extend([like, like, like])
                    st = status_var.get()
                    if st and st != 'All':
                        query += "AND ja.status = ? "
                        params.append(st)
                    f = from_var.get().strip()
                    if f:
                        query += "AND date(ja.application_date) >= ? "
                        params.append(f)
                    t = to_var.get().strip()
                    if t:
                        query += "AND date(ja.application_date) <= ? "
                        params.append(t)
                    query += "ORDER BY ja.application_date DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall(); conn.close()
                    for it in tree.get_children():
                        tree.delete(it)
                    for r in rows:
                        tree.insert('', 'end', values=r)
                except Exception as e:
                    try:
                        messagebox.showerror("Applications", f"Failed to load applications: {str(e)}")
                    except Exception:
                        pass

            def get_selected():
                sel = tree.selection()
                if not sel:
                    return None
                return tree.item(sel[0], 'values')

            def view_details():
                vals = get_selected()
                if not vals:
                    messagebox.showinfo("Applications", "Select an application to view.")
                    return
                app_id, job_id, title, employer, location, status, applied_on, deadline = vals
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Fetch job details and applicant note
                    cur.execute("SELECT description, requirements FROM jobs WHERE id=?", (job_id,))
                    jrow = cur.fetchone()
                    cur.execute("SELECT cover_letter, resume_path FROM job_applications WHERE id=?", (app_id,))
                    arow = cur.fetchone(); conn.close()
                    desc = jrow[0] if jrow else ''
                    reqs = jrow[1] if jrow else ''
                    cover = (arow[0] or '') if arow else ''
                    resume_path = (arow[1] or '') if arow else ''
                    info = (
                        f"Title: {title}\nEmployer: {employer}\nLocation: {location or ''}\n"
                        f"Applied On: {applied_on or ''}\nDeadline: {deadline or ''}\nStatus: {status}\n"
                        f"Resume: {'Yes' if resume_path else 'No'}\n\nDescription:\n{desc or ''}\n\nRequirements:\n{reqs or ''}\n\nCover Letter:\n{cover or ''}"
                    )
                    d = tk.Toplevel(win); d.title("Application Details"); d.geometry("650x520"); d.configure(bg='white'); d.grab_set(); d.transient(win)
                    txt = tk.Text(d, wrap='word'); txt.pack(fill='both', expand=True)
                    txt.insert('1.0', info); txt.config(state='disabled')
                    tk.Button(d, text="Close", command=d.destroy).pack(pady=6)
                except Exception as e:
                    messagebox.showerror("Applications", f"Failed to load details: {str(e)}")

            def open_resume():
                vals = get_selected()
                if not vals:
                    messagebox.showinfo("Applications", "Select an application first.")
                    return
                app_id = vals[0]
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT resume_path FROM job_applications WHERE id=?", (app_id,))
                    row = cur.fetchone(); conn.close()
                    rp = row[0] if row else None
                    if not rp:
                        messagebox.showinfo("Applications", "No resume associated with this application.")
                        return
                    if not os.path.exists(rp):
                        messagebox.showerror("Applications", "The stored resume file was not found.")
                        return
                    os.startfile(rp)
                except Exception as e:
                    messagebox.showerror("Applications", f"Failed to open resume: {str(e)}")

            def view_cover():
                vals = get_selected()
                if not vals:
                    messagebox.showinfo("Applications", "Select an application first.")
                    return
                app_id = vals[0]
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT cover_letter FROM job_applications WHERE id=?", (app_id,))
                    row = cur.fetchone(); conn.close()
                    cover = row[0] if row else ''
                    d = tk.Toplevel(win); d.title("Cover Letter"); d.geometry("600x400"); d.configure(bg='white'); d.grab_set(); d.transient(win)
                    txt = tk.Text(d, wrap='word'); txt.pack(fill='both', expand=True)
                    txt.insert('1.0', cover or "(No cover letter)")
                    txt.config(state='disabled')
                    tk.Button(d, text="Close", command=d.destroy).pack(pady=6)
                except Exception as e:
                    messagebox.showerror("Applications", f"Failed to open cover letter: {str(e)}")

            def withdraw():
                vals = get_selected()
                if not vals:
                    messagebox.showinfo("Applications", "Select an application to withdraw.")
                    return
                app_id, job_id, title, employer, location, status, applied_on, deadline = vals
                if status not in ("Submitted","Under Review"):
                    messagebox.showinfo("Applications", "You can only withdraw applications that are Submitted or Under Review.")
                    return
                if not messagebox.askyesno("Withdraw", f"Withdraw your application for '{title}'?"):
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("UPDATE job_applications SET status='Withdrawn' WHERE id=?", (app_id,))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Withdraw Application", f"app_id={app_id}")
                    except Exception:
                        pass
                    messagebox.showinfo("Applications", "Application withdrawn.")
                    refresh()
                except Exception as e:
                    messagebox.showerror("Applications", f"Failed to withdraw: {str(e)}")

            # Wire
            view_btn.config(command=view_details)
            open_resume_btn.config(command=open_resume)
            view_cover_btn.config(command=view_cover)
            withdraw_btn.config(command=withdraw)
            refresh_btn.config(command=refresh)
            q_var.trace('w', lambda *a: refresh())
            status_var.trace('w', lambda *a: refresh())

            # Initial
            refresh()
            try:
                self.log_audit_action(self.current_user['id'], "Open My Applications", "")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Applications", f"Failed to open My Applications: {str(e)}")
            except Exception:
                pass
            
#========================= manage job ============================            

    def show_manage_jobs(self):
        try:
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Jobs", "You must be logged in to manage jobs.")
                return
            # Only job posters (employer, contract_owner, contractor) and administrators can manage jobs they posted
            role = self.current_user.get('role')
            if role not in ("employer", "contract_owner", "contractor", "administrator"):
                messagebox.showwarning("Access Denied", "Only Employers, Contract Owners, Contractors, or Administrators can manage jobs.")
                return

            win = tk.Toplevel(self.root)
            win.title("Manage Jobs")
            win.geometry("1000x620")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Manage My Jobs", font=('Arial', 16, 'bold'), bg='white').pack(side='left')
            tk.Button(header, text="Post New Job", bg="#27ae60", fg="white", command=self.show_post_job).pack(side='right')

            # Filters
            filters = tk.Frame(win, bg='white')
            filters.pack(fill='x', padx=10)
            tk.Label(filters, text="Keyword:", bg='white').grid(row=0, column=0, sticky='w')
            q_var = tk.StringVar()
            tk.Entry(filters, textvariable=q_var, width=30).grid(row=0, column=1, padx=6, pady=4)
            tk.Label(filters, text="Status:", bg='white').grid(row=0, column=2, sticky='w')
            status_var = tk.StringVar(value='All')
            status_cb = ttk.Combobox(filters, textvariable=status_var, values=['All','Open','Closed','On Hold'], state='readonly', width=12)
            status_cb.grid(row=0, column=3, padx=6, pady=4)
            tk.Label(filters, text="From (YYYY-MM-DD):", bg='white').grid(row=1, column=0, sticky='w')
            from_var = tk.StringVar()
            tk.Entry(filters, textvariable=from_var, width=18).grid(row=1, column=1, padx=6, pady=4, sticky='w')
            tk.Label(filters, text="To (YYYY-MM-DD):", bg='white').grid(row=1, column=2, sticky='w')
            to_var = tk.StringVar()
            tk.Entry(filters, textvariable=to_var, width=18).grid(row=1, column=3, padx=6, pady=4, sticky='w')
            search_btn = tk.Button(filters, text="Search", bg="#3498db", fg="white")
            reset_btn = tk.Button(filters, text="Reset")
            search_btn.grid(row=0, column=4, padx=6)
            reset_btn.grid(row=0, column=5, padx=6)

            # Table
            table = tk.Frame(win, bg='white')
            table.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Title","Location","Salary","Posted","Deadline","Status","Applications")
            tree = ttk.Treeview(table, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=120)
            tree.column("Title", width=240)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(table, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Actions
            actions = tk.Frame(win, bg='white')
            actions.pack(fill='x', padx=10, pady=(0,10))
            edit_btn = tk.Button(actions, text="Edit", bg="#2980b9", fg="white")
            close_btn = tk.Button(actions, text="Close Job", bg="#e67e22", fg="white")
            reopen_btn = tk.Button(actions, text="Reopen Job", bg="#27ae60", fg="white")
            delete_btn = tk.Button(actions, text="Delete", bg="#c0392b", fg="white")
            view_apps_btn = tk.Button(actions, text="View Applicants")
            refresh_btn = tk.Button(actions, text="Refresh")
            edit_btn.pack(side='left')
            close_btn.pack(side='left', padx=6)
            reopen_btn.pack(side='left', padx=6)
            delete_btn.pack(side='left', padx=6)
            view_apps_btn.pack(side='left', padx=6)
            refresh_btn.pack(side='right')

            def do_reset():
                q_var.set(""); status_var.set('All'); from_var.set(""); to_var.set(""); refresh()

            def refresh():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    query = (
                        "SELECT j.id, j.title, j.location, j.salary_range, j.posted_date, j.deadline, j.status, "
                        "(SELECT COUNT(*) FROM job_applications ja WHERE ja.job_id=j.id) AS apps "
                        "FROM jobs j WHERE 1=1 "
                    )
                    params = []
                    # Employers: only their jobs; Admins: all jobs
                    if role != 'administrator':
                        query += "AND j.employer_id = ? "
                        params.append(self.current_user['id'])
                    q = q_var.get().strip()
                    if q:
                        query += "AND (j.title LIKE ? OR j.description LIKE ? OR j.requirements LIKE ? OR j.location LIKE ?) "
                        like = f"%{q}%"; params.extend([like, like, like, like])
                    st = status_var.get()
                    if st and st != 'All':
                        query += "AND j.status = ? "; params.append(st)
                    f = from_var.get().strip()
                    if f:
                        query += "AND date(j.posted_date) >= ? "; params.append(f)
                    t = to_var.get().strip()
                    if t:
                        query += "AND date(j.posted_date) <= ? "; params.append(t)
                    query += "ORDER BY j.posted_date DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall(); conn.close()
                    for it in tree.get_children():
                        tree.delete(it)
                    for r in rows:
                        tree.insert('', 'end', values=r)
                except Exception as e:
                    try:
                        messagebox.showerror("Jobs", f"Failed to load jobs: {str(e)}")
                    except Exception:
                        pass

            def get_selected():
                sel = tree.selection()
                if not sel:
                    return None
                return tree.item(sel[0], 'values')

            def edit_job():
                vals = get_selected()
                if not vals:
                    messagebox.showinfo("Jobs", "Select a job to edit.")
                    return
                jid, title, loc, salary, posted, deadline, status, apps = vals
                # Open a simple edit dialog
                dlg = tk.Toplevel(win); dlg.title("Edit Job"); dlg.geometry("600x520"); dlg.configure(bg='white'); dlg.grab_set(); dlg.transient(win)
                tk.Label(dlg, text=f"Editing: {title}", bg='white', font=('Arial', 12, 'bold')).pack(anchor='w', padx=10, pady=(10,6))
                frm = tk.Frame(dlg, bg='white'); frm.pack(fill='both', expand=True, padx=10)
                tk.Label(frm, text="Title:", bg='white').grid(row=0, column=0, sticky='e'); title_var = tk.StringVar(value=title); tk.Entry(frm, textvariable=title_var, width=40).grid(row=0, column=1, sticky='w', padx=6, pady=6)
                tk.Label(frm, text="Location:", bg='white').grid(row=1, column=0, sticky='e'); loc_var = tk.StringVar(value=loc or ""); tk.Entry(frm, textvariable=loc_var, width=40).grid(row=1, column=1, sticky='w', padx=6, pady=6)
                tk.Label(frm, text="Salary:", bg='white').grid(row=2, column=0, sticky='e'); sal_var = tk.StringVar(value=salary or ""); tk.Entry(frm, textvariable=sal_var, width=40).grid(row=2, column=1, sticky='w', padx=6, pady=6)
                tk.Label(frm, text="Deadline (YYYY-MM-DD):", bg='white').grid(row=3, column=0, sticky='e'); dl_var = tk.StringVar(value=deadline or ""); tk.Entry(frm, textvariable=dl_var, width=20).grid(row=3, column=1, sticky='w', padx=6, pady=6)
                tk.Label(frm, text="Status:", bg='white').grid(row=4, column=0, sticky='e'); st_var = tk.StringVar(value=status); st_cb = ttk.Combobox(frm, textvariable=st_var, values=['Open','Closed','On Hold'], state='readonly', width=12); st_cb.grid(row=4, column=1, sticky='w', padx=6, pady=6)
                tk.Label(frm, text="Description:", bg='white').grid(row=5, column=0, sticky='ne'); desc_txt = tk.Text(frm, width=50, height=6); desc_txt.grid(row=5, column=1, sticky='w', padx=6, pady=6)
                tk.Label(frm, text="Requirements:", bg='white').grid(row=6, column=0, sticky='ne'); req_txt = tk.Text(frm, width=50, height=5); req_txt.grid(row=6, column=1, sticky='w', padx=6, pady=6)
                # Load current long fields
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor(); cur.execute("SELECT description, requirements FROM jobs WHERE id=?", (jid,)); r = cur.fetchone(); conn.close()
                    if r:
                        desc_txt.insert('1.0', r[0] or ""); req_txt.insert('1.0', r[1] or "")
                except Exception:
                    pass
                def save_changes():
                    try:
                        # Basic validation
                        if not title_var.get().strip():
                            messagebox.showerror("Validation", "Title is required"); return
                        # Optional date format check
                        dls = dl_var.get().strip()
                        if dls:
                            try:
                                datetime.strptime(dls, '%Y-%m-%d')
                            except Exception:
                                messagebox.showerror("Validation", "Deadline must be YYYY-MM-DD"); return
                        conn = self.db_manager.create_connection(); cur = conn.cursor()
                        cur.execute(
                            "UPDATE jobs SET title=?, location=?, salary_range=?, deadline=?, status=?, description=?, requirements=? WHERE id=?",
                            (title_var.get().strip(), loc_var.get().strip(), sal_var.get().strip(), dls if dls else None, st_var.get(), desc_txt.get('1.0','end-1c').strip(), req_txt.get('1.0','end-1c').strip(), jid)
                        )
                        conn.commit(); conn.close()
                        try:
                            self.log_audit_action(self.current_user['id'], "Edit Job", f"job_id={jid}")
                        except Exception:
                            pass
                        messagebox.showinfo("Jobs", "Job updated."); dlg.destroy(); refresh()
                    except Exception as e:
                        messagebox.showerror("Jobs", f"Failed to save: {str(e)}")
                btns = tk.Frame(dlg, bg='white'); btns.pack(fill='x', padx=10, pady=8)
                tk.Button(btns, text="Save", bg="#27ae60", fg="white", command=save_changes).pack(side='left')
                tk.Button(btns, text="Cancel", command=dlg.destroy).pack(side='right')

            def set_status(new_status):
                vals = get_selected()
                if not vals:
                    messagebox.showinfo("Jobs", "Select a job first."); return
                jid = vals[0]
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("UPDATE jobs SET status=? WHERE id=?", (new_status, jid))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Update Job Status", f"job_id={jid}, status={new_status}")
                    except Exception:
                        pass
                    refresh()
                except Exception as e:
                    messagebox.showerror("Jobs", f"Failed to update status: {str(e)}")

            def delete_job():
                vals = get_selected()
                if not vals:
                    messagebox.showinfo("Jobs", "Select a job to delete."); return
                jid, title = vals[0], vals[1]
                if not messagebox.askyesno("Delete", f"Delete job '{title}'? This will remove all applications too."):
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    # Remove applications first to keep DB consistent
                    cur.execute("DELETE FROM job_applications WHERE job_id=?", (jid,))
                    cur.execute("DELETE FROM jobs WHERE id=?", (jid,))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Delete Job", f"job_id={jid}")
                    except Exception:
                        pass
                    messagebox.showinfo("Jobs", "Job deleted."); refresh()
                except Exception as e:
                    messagebox.showerror("Jobs", f"Failed to delete: {str(e)}")

            def view_applicants():
                vals = get_selected()
                if not vals:
                    messagebox.showinfo("Jobs", "Select a job to view applicants."); return
                jid = vals[0]
                # Reuse existing employer applications manager filtered to this job if available
                try:
                    if hasattr(self, 'show_manage_applications'):
                        # Open and preselect via internal filter if possible
                        self.show_manage_applications()
                    else:
                        messagebox.showinfo("Applicants", "Applicants manager is not available in this build.")
                except Exception as e:
                    try:
                        messagebox.showerror("Applicants", f"Failed to open applicants: {str(e)}")
                    except Exception:
                        pass

            # Wire
            search_btn.config(command=refresh)
            reset_btn.config(command=do_reset)
            refresh_btn.config(command=refresh)
            edit_btn.config(command=edit_job)
            close_btn.config(command=lambda: set_status('Closed'))
            reopen_btn.config(command=lambda: set_status('Open'))
            delete_btn.config(command=delete_job)
            view_apps_btn.config(command=view_applicants)
            q_var.trace('w', lambda *a: refresh())
            status_var.trace('w', lambda *a: refresh())

            # Initial
            refresh()
            try:
                self.log_audit_action(self.current_user['id'], "Open Manage Jobs", "")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Jobs", f"Failed to open Manage Jobs: {str(e)}")
            except Exception:
                pass


#=================== view job application ==============
    def show_view_applicants(self):
        try:
            # Only logged-in Employers or Administrators should access
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Applicants", "You must be logged in to view applicants.")
                return
            role = self.current_user.get('role')
            if role not in ("employer", "administrator", "contract_owner"):
                messagebox.showwarning("Access Denied", "Only Employers or Administrators can view applicants.")
                return

            win = tk.Toplevel(self.root)
            win.title("View Applicants")
            win.geometry("1100x650")
            win.configure(bg='white')
            win.grab_set()

            # Header
            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Applicants", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters (reuse similar to manage applications)
            filt = tk.LabelFrame(win, text="Filters", bg='white')
            filt.pack(fill='x', padx=10, pady=(0,10))
            tk.Label(filt, text="Job:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            job_var = tk.StringVar()
            job_cb = ttk.Combobox(filt, textvariable=job_var, state='readonly', width=40)
            job_cb.grid(row=0, column=1, sticky='w', padx=5, pady=6)
            tk.Label(filt, text="Status:", bg='white').grid(row=0, column=2, sticky='e', padx=5, pady=6)
            status_var = tk.StringVar(value='All')
            status_cb = ttk.Combobox(filt, textvariable=status_var, state='readonly', width=20)
            status_cb['values'] = ['All','Submitted','Under Review','Interview','Rejected','Hired']
            status_cb.grid(row=0, column=3, sticky='w', padx=5, pady=6)
            tk.Label(filt, text="Applicant contains:", bg='white').grid(row=0, column=4, sticky='e', padx=5, pady=6)
            search_var = tk.StringVar()
            tk.Entry(filt, textvariable=search_var, width=22).grid(row=0, column=5, sticky='w', padx=5, pady=6)
            act = tk.Frame(filt, bg='white')
            act.grid(row=0, column=6, padx=5, pady=6, sticky='w')
            refresh_btn = tk.Button(act, text="Refresh", bg="#3498db", fg="white")
            refresh_btn.pack(side='left')

            # Table
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Job","Applicant","Applied On","Status","Resume","Cover Letter")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=160 if c in ("Job","Applicant") else 120)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Actions
            btns = tk.Frame(win, bg='white')
            btns.pack(fill='x', padx=10, pady=(0,10))
            view_cover_btn = tk.Button(btns, text="View Cover Letter")
            open_resume_btn = tk.Button(btns, text="Open Resume")
            review_btn = tk.Button(btns, text="Mark Under Review", bg="#2980b9", fg="white")
            interview_btn = tk.Button(btns, text="Schedule Interview", bg="#8e44ad", fg="white")
            reject_btn = tk.Button(btns, text="Reject", bg="#c0392b", fg="white")
            hire_btn = tk.Button(btns, text="Hire", bg="#27ae60", fg="white")
            view_cover_btn.pack(side='left')
            open_resume_btn.pack(side='left', padx=6)
            review_btn.pack(side='left', padx=6)
            interview_btn.pack(side='left', padx=6)
            reject_btn.pack(side='left', padx=6)
            hire_btn.pack(side='left', padx=6)

            # Load jobs list for combobox
            job_map = {"All Jobs": None}
            def load_jobs():
                try:
                    conn = self.db_manager.create_connection()
                    cur = conn.cursor()
                    role = self.current_user['role']
                    if role in ['administrator','contract_owner']:
                        cur.execute("SELECT id, title FROM jobs ORDER BY posted_date DESC")
                    else:
                        cur.execute("SELECT id, title FROM jobs WHERE employer_id=? ORDER BY posted_date DESC", (self.current_user['id'],))
                    rows = cur.fetchall(); conn.close()
                    values = ["All Jobs"]
                    for jid, title in rows:
                        disp = f"{title} (ID:{jid})"; job_map[disp] = jid; values.append(disp)
                    job_cb['values'] = values; job_cb.set(values[0])
                except Exception:
                    job_cb['values'] = ["All Jobs"]; job_cb.set("All Jobs")

            def refresh():
                try:
                    jid = job_map.get(job_var.get())
                    st = status_var.get()
                    q = search_var.get().strip()
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    query = (
                        "SELECT ja.id, j.title, COALESCE(u.full_name,u.username) AS applicant, ja.application_date, ja.status, ja.resume_path, substr(ja.cover_letter,1,50) "
                        "FROM job_applications ja JOIN jobs j ON j.id = ja.job_id JOIN users u ON u.id = ja.applicant_id WHERE 1=1 "
                    )
                    params = []
                    role = self.current_user['role']
                    if role not in ['administrator','contract_owner']:
                        query += "AND j.employer_id = ? "; params.append(self.current_user['id'])
                    if jid:
                        query += "AND ja.job_id = ? "; params.append(jid)
                    if st and st != 'All':
                        query += "AND ja.status = ? "; params.append(st)
                    if q:
                        query += "AND (u.full_name LIKE ? OR j.title LIKE ?) "; like = f"%{q}%"; params.extend([like, like])
                    query += "ORDER BY ja.application_date DESC"
                    cur.execute(query, params)
                    rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Applicants", f"Failed to load applicants: {str(e)}")
                    except Exception:
                        pass
                    rows = []
                for it in tree.get_children():
                    tree.delete(it)
                for r in rows:
                    tree.insert('', 'end', values=r)
                try:
                    self.log_audit_action(self.current_user['id'], "View Applicants", json.dumps({'job': job_var.get(), 'status': status_var.get(), 'q': search_var.get()}))
                except Exception:
                    pass

            def get_selected_id():
                sel = tree.selection()
                if not sel:
                    messagebox.showwarning("Select", "Select an application first.")
                    return None
                return tree.item(sel[0], 'values')[0]

            def update_status(new_status):
                app_id = get_selected_id()
                if not app_id:
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("UPDATE job_applications SET status=? WHERE id=?", (new_status, app_id))
                    conn.commit(); conn.close()
                    try:
                        self.log_audit_action(self.current_user['id'], "Update Application Status", f"{app_id} -> {new_status}")
                    except Exception:
                        pass
                    refresh()
                except Exception as e:
                    try:
                        messagebox.showerror("Applicants", f"Failed to update status: {str(e)}")
                    except Exception:
                        pass

            def open_resume():
                app_id = get_selected_id()
                if not app_id:
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT resume_path FROM job_applications WHERE id=?", (app_id,))
                    row = cur.fetchone(); conn.close()
                    rp = row[0] if row else None
                    if not rp:
                        messagebox.showinfo("Resume", "No resume uploaded for this application.")
                        return
                    if not os.path.exists(rp):
                        messagebox.showerror("Resume", "The stored resume file was not found.")
                        return
                    os.startfile(rp)
                except Exception as e:
                    try:
                        messagebox.showerror("Resume", f"Failed to open resume: {str(e)}")
                    except Exception:
                        pass

            def view_cover():
                app_id = get_selected_id()
                if not app_id:
                    return
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("SELECT cover_letter FROM job_applications WHERE id=?", (app_id,))
                    row = cur.fetchone(); conn.close()
                    cover = row[0] if row else ''
                    d = tk.Toplevel(win); d.title("Cover Letter"); d.geometry("600x400"); d.configure(bg='white'); d.grab_set(); d.transient(win)
                    txt = tk.Text(d, wrap='word'); txt.pack(fill='both', expand=True)
                    txt.insert('1.0', cover or "(No cover letter)"); txt.config(state='disabled')
                    tk.Button(d, text="Close", command=d.destroy).pack(pady=6)
                except Exception as e:
                    try:
                        messagebox.showerror("Applicants", f"Failed to open cover letter: {str(e)}")
                    except Exception:
                        pass

            # Wire
            refresh_btn.config(command=refresh)
            open_resume_btn.config(command=open_resume)
            view_cover_btn.config(command=view_cover)
            review_btn.config(command=lambda: update_status('Under Review'))
            interview_btn.config(command=lambda: update_status('Interview'))
            reject_btn.config(command=lambda: update_status('Rejected'))
            hire_btn.config(command=lambda: update_status('Hired'))
            job_var.trace('w', lambda *a: refresh())
            status_var.trace('w', lambda *a: refresh())
            search_var.trace('w', lambda *a: refresh())

            # Context menu
            def context_menu(event):
                menu = tk.Menu(win, tearoff=0)
                menu.add_command(label="Mark Under Review", command=lambda: update_status('Under Review'))
                menu.add_command(label="Schedule Interview", command=lambda: update_status('Interview'))
                menu.add_separator()
                menu.add_command(label="Open Resume", command=open_resume)
                menu.add_command(label="View Cover Letter", command=view_cover)
                try:
                    menu.tk_popup(event.x_root, event.y_root)
                finally:
                    menu.grab_release()
            tree.bind("<Button-3>", context_menu)
            tree.bind('<Double-1>', lambda e: view_cover())

            # Load and initial refresh
            load_jobs(); refresh()

            try:
                self.log_audit_action(self.current_user['id'], "Open View Applicants", "")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Applicants", f"Failed to open View Applicants: {str(e)}")
            except Exception:
                pass



#================== schedule interview ====================
    def show_schedule_interview(self):
        try:
            # Only logged-in Employers or Administrators should access
            if not getattr(self, 'current_user', None):
                messagebox.showerror("Interviews", "You must be logged in to schedule interviews.")
                return
            role = self.current_user.get('role')
            if role not in ("employer", "administrator", "contract_owner"):
                messagebox.showwarning("Access Denied", "Only Employers or Administrators can schedule interviews.")
                return

            # Simple interviews planner without a dedicated table: attaches date/time and notes to applications via audit log
            win = tk.Toplevel(self.root)
            win.title("Schedule Interview")
            win.geometry("600x480")
            win.configure(bg='white')
            win.grab_set()

            header = tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            tk.Label(header, text="Schedule Interview", font=('Arial', 16, 'bold'), bg='white').pack(side='left')

            # Filters and selection
            filt = tk.Frame(win, bg='white')
            filt.pack(fill='x', padx=10)
            tk.Label(filt, text="Job:", bg='white').grid(row=0, column=0, sticky='e', padx=5, pady=6)
            job_var = tk.StringVar()
            job_cb = ttk.Combobox(filt, textvariable=job_var, state='readonly', width=40)
            job_cb.grid(row=0, column=1, sticky='w')
            tk.Label(filt, text="Status:", bg='white').grid(row=0, column=2, sticky='e', padx=5)
            status_var = tk.StringVar(value='All')
            status_cb = ttk.Combobox(filt, textvariable=status_var, state='readonly', width=18)
            status_cb['values'] = ['All','Submitted','Under Review','Interview']
            status_cb.grid(row=0, column=3, sticky='w')

            # Table of applications
            frame = tk.Frame(win, bg='white')
            frame.pack(fill='both', expand=True, padx=10, pady=10)
            cols = ("ID","Job","Applicant","Applied On","Status")
            tree = ttk.Treeview(frame, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=140 if c in ("Job","Applicant") else 110)
            tree.pack(fill='both', expand=True, side='left')
            sy = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set)
            sy.pack(side='right', fill='y')

            # Details / schedule panel
            panel = tk.LabelFrame(win, text="Interview Details", bg='white')
            panel.pack(fill='x', padx=10, pady=(0,10))
            tk.Label(panel, text="Date (YYYY-MM-DD):", bg='white').grid(row=0, column=0, sticky='e', padx=6, pady=6)
            date_var = tk.StringVar(value=date.today().isoformat())
            tk.Entry(panel, textvariable=date_var, width=16).grid(row=0, column=1, sticky='w')
            tk.Label(panel, text="Time (HH:MM, 24h):", bg='white').grid(row=0, column=2, sticky='e', padx=6)
            time_var = tk.StringVar(value="10:00")
            tk.Entry(panel, textvariable=time_var, width=10).grid(row=0, column=3, sticky='w')
            tk.Label(panel, text="Location / Link:", bg='white').grid(row=1, column=0, sticky='e', padx=6)
            loc_var = tk.StringVar()
            tk.Entry(panel, textvariable=loc_var, width=40).grid(row=1, column=1, columnspan=3, sticky='w', pady=6)
            tk.Label(panel, text="Notes:", bg='white').grid(row=2, column=0, sticky='ne', padx=6)
            notes_txt = tk.Text(panel, width=60, height=4)
            notes_txt.grid(row=2, column=1, columnspan=3, sticky='w', pady=6)

            actions = tk.Frame(win, bg='white')
            actions.pack(fill='x', padx=10, pady=(0,10))
            save_btn = tk.Button(actions, text="Schedule", bg="#27ae60", fg="white")
            refresh_btn = tk.Button(actions, text="Refresh")
            save_btn.pack(side='left')
            refresh_btn.pack(side='right')

            job_map = {"All Jobs": None}
            def load_jobs():
                try:
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    if role in ['administrator','contract_owner']:
                        cur.execute("SELECT id, title FROM jobs ORDER BY posted_date DESC")
                    else:
                        cur.execute("SELECT id, title FROM jobs WHERE employer_id=? ORDER BY posted_date DESC", (self.current_user['id'],))
                    rows = cur.fetchall(); conn.close()
                    vals = ["All Jobs"]
                    for jid, title in rows:
                        disp = f"{title} (ID:{jid})"; job_map[disp] = jid; vals.append(disp)
                    job_cb['values'] = vals; job_cb.set(vals[0])
                except Exception:
                    job_cb['values'] = ["All Jobs"]; job_cb.set("All Jobs")

            def refresh():
                try:
                    jid = job_map.get(job_var.get())
                    st = status_var.get()
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    q = (
                        "SELECT ja.id, j.title, COALESCE(u.full_name,u.username) AS applicant, ja.application_date, ja.status "
                        "FROM job_applications ja JOIN jobs j ON j.id=ja.job_id JOIN users u ON u.id=ja.applicant_id WHERE 1=1 "
                    )
                    params = []
                    if role not in ['administrator','contract_owner']:
                        q += "AND j.employer_id = ? "; params.append(self.current_user['id'])
                    if jid:
                        q += "AND ja.job_id = ? "; params.append(jid)
                    if st and st != 'All':
                        q += "AND ja.status = ? "; params.append(st)
                    q += "ORDER BY ja.application_date DESC"
                    cur.execute(q, params); rows = cur.fetchall(); conn.close()
                except Exception as e:
                    try:
                        messagebox.showerror("Interviews", f"Failed to load applications: {str(e)}")
                    except Exception:
                        pass
                    rows = []
                for it in tree.get_children():
                    tree.delete(it)
                for r in rows:
                    tree.insert('', 'end', values=r)

            def get_selected():
                sel = tree.selection()
                if not sel:
                    messagebox.showinfo("Interviews", "Select an application first.")
                    return None
                return tree.item(sel[0], 'values')

            def validate_inputs():
                d = date_var.get().strip(); t = time_var.get().strip()
                try:
                    datetime.strptime(d, '%Y-%m-%d')
                except Exception:
                    messagebox.showerror("Validation", "Date must be YYYY-MM-DD"); return False
                try:
                    datetime.strptime(t, '%H:%M')
                except Exception:
                    messagebox.showerror("Validation", "Time must be HH:MM (24h)"); return False
                return True

            def schedule():
                vals = get_selected()
                if not vals:
                    return
                if not validate_inputs():
                    return
                app_id = vals[0]
                scheduled_dt = f"{date_var.get().strip()} {time_var.get().strip()}"
                location = loc_var.get().strip()
                notes = notes_txt.get('1.0','end-1c').strip()
                try:
                    # For now, store the schedule as a status update to 'Interview' and write to audit log with details
                    conn = self.db_manager.create_connection(); cur = conn.cursor()
                    cur.execute("UPDATE job_applications SET status='Interview' WHERE id=?", (app_id,))
                    conn.commit(); conn.close()
                    details = json.dumps({
                        'application_id': app_id,
                        'scheduled_at': scheduled_dt,
                        'location': location,
                        'notes': notes
                    })
                    try:
                        self.log_audit_action(self.current_user['id'], "Schedule Interview", details)
                    except Exception:
                        pass
                    messagebox.showinfo("Interviews", "Interview scheduled and applicant status set to 'Interview'.")
                    refresh()
                except Exception as e:
                    try:
                        messagebox.showerror("Interviews", f"Failed to schedule: {str(e)}")
                    except Exception:
                        pass

            # Wire
            refresh_btn.config(command=refresh)
            save_btn.config(command=schedule)
            job_var.trace('w', lambda *a: refresh())
            status_var.trace('w', lambda *a: refresh())

            # Init
            load_jobs(); refresh()

            try:
                self.log_audit_action(self.current_user['id'], "Open Schedule Interview", "")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Interviews", f"Failed to open Schedule Interview: {str(e)}")
            except Exception:
                pass

#============ run =======================

    def run(self):
        self.root.mainloop()


# Initialize and run the application
if __name__ == "__main__":
    # Create default admin users if they don't exist
    db_manager = DatabaseManager()
    security_manager = SecurityManager()

    conn = db_manager.create_connection()
    cursor = conn.cursor()

    # Ensure default 'admin' exists if no administrators at all
    cursor.execute("SELECT COUNT(*) FROM users WHERE role = 'administrator'")
    if cursor.fetchone()[0] == 0:
        admin_password = security_manager.hash_password("admin123")
        cursor.execute('''
                       INSERT INTO users
                       (username, email, password_hash, role, full_name, phone, address, created_date, first_login)
                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                       ''', (
                           'admin',
                           'admin@cbpm.cm',
                           admin_password,
                           'administrator',
                           'System Administrator',
                           '+237 6XX XXX XXX',
                           'Yaoundé, Cameroon',
                           date.today(),
                           0
                       ))
        conn.commit()
        print("Default admin user created: username='admin', password='admin123'")

    # Ensure specific 'newadmin' user exists with provided hash
    try:
        cursor.execute("SELECT COUNT(*) FROM users WHERE username = ?", ('newadmin',))
        exists = cursor.fetchone()[0]
        if exists == 0:
            provided_sha256 = '240be518fabd2724ddb6f04eeb1da5967448d7e831c08c8fa822809f74c720a9'
            cursor.execute('''
                           INSERT INTO users
                           (username, email, password_hash, role, full_name, phone, address, created_date, is_active, first_login, failed_login_attempts)
                           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                           ''', (
                               'newadmin',
                               'newadmin@cbpm.cm',
                               provided_sha256,
                               'administrator',
                               'New Administrator',
                               '',
                               '',
                               date.today(),
                               1,
                               1,
                               0
                           ))
            conn.commit()
            print("Admin user 'newadmin' created with provided password hash.")
    except Exception as _e:
        # Non-fatal: continue launching app even if insertion failed
        pass

    # One-time admin password reset (create a flag file to avoid resetting every run)
    try:
        import os as _os, json as _json
        flag_dir = _os.path.join(_os.path.expanduser('~'), 'Documents', 'CBPM')
        _os.makedirs(flag_dir, exist_ok=True)
        flag_file = _os.path.join(flag_dir, 'admin_reset_done.flag')
        if not _os.path.exists(flag_file):
            try:
                new_pwd = 'Admin@2025!Reset'
                new_hash = security_manager.hash_password(new_pwd)
                # Reset for both potential admin usernames if they exist
                cursor = conn.cursor()
                cursor.execute("UPDATE users SET password_hash=?, first_login=1, is_active=1, failed_login_attempts=0 WHERE username IN ('admin','newadmin')", (new_hash,))
                conn.commit()
                with open(flag_file, 'w', encoding='utf-8') as f:
                    f.write(_json.dumps({
                        'reset': True,
                        'usernames': ['admin', 'newadmin'],
                        'when': datetime.now().isoformat()
                    }))
                print("Admin credentials have been reset. Use username 'admin' or 'newadmin' with the new temporary password provided in instructions.")
            except Exception as _rex:
                try:
                    print(f"[WARN] Admin reset failed: {_rex}")
                except Exception:
                    pass
    except Exception:
        pass

    try:
        conn.close()
    except Exception:
        pass

    # Start the application or show Android guidance if Tkinter is unavailable
    if HAS_TK:
        app = CBPMApp()
        app.run()
    else:
        print("CBPM: GUI components are unavailable in this environment (likely Android).")
        print("A desktop Tkinter UI cannot run on Android.")
        print("See docs\\android.md for the Android approach (Kivy front-end + API backend).")
        # Exit code 0 to avoid failing automated runs on Android environments

# ===== Module-level implementation to expose Transfer Products UI for Contract Owners =====
def show_transfer_products(self):
    # Transfer Products Management window
    transfer_window = tk.Toplevel(self.root)
    transfer_window.title("Transfer Products Between Stores")
    transfer_window.geometry("1400x800")
    transfer_window.configure(bg='white')
    transfer_window.grab_set()  # Make modal

    # Main container
    main_frame = tk.Frame(transfer_window, bg='white', padx=10, pady=10)
    main_frame.pack(fill='both', expand=True)

    # Title and controls frame
    header_frame = tk.Frame(main_frame, bg='white')
    header_frame.pack(fill='x', pady=(0, 20))

    # Title
    tk.Label(header_frame, text="Product Transfer Management", font=('Arial', 18, 'bold'),
             bg='white', fg='#2c3e50').pack(side='left')

    # Control buttons
    control_frame = tk.Frame(header_frame, bg='white')
    control_frame.pack(side='right')

    new_transfer_btn = tk.Button(control_frame, text="New Transfer", font=('Arial', 11, 'bold'),
                                 bg='#27ae60', fg='white', width=12)
    new_transfer_btn.pack(side='left', padx=(0, 10))

    refresh_btn = tk.Button(control_frame, text="Refresh", font=('Arial', 10),
                            bg='#3498db', fg='white', width=8)
    refresh_btn.pack(side='left')

    # Create notebook for different sections
    notebook = ttk.Notebook(main_frame)
    notebook.pack(fill='both', expand=True, pady=(0, 10))

    # Tab 1: Create New Transfer
    new_transfer_frame = tk.Frame(notebook, bg='white')
    notebook.add(new_transfer_frame, text="New Transfer")

    # Tab 2: Transfer History
    history_frame = tk.Frame(notebook, bg='white')
    notebook.add(history_frame, text="Transfer History")

    # Tab 3: Pending Transfers
    pending_frame = tk.Frame(notebook, bg='white')
    notebook.add(pending_frame, text="Pending Transfers")

    # =================== TAB 1: NEW TRANSFER ===================
    new_main = tk.Frame(new_transfer_frame, bg='white', padx=20, pady=20)
    new_main.pack(fill='both', expand=True)

    # Store Selection Section
    store_section = tk.LabelFrame(new_main, text="Store Selection",
                                  font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
    store_section.pack(fill='x', pady=(0, 20))

    store_selection_frame = tk.Frame(store_section, bg='white')
    store_selection_frame.pack(fill='x', padx=15, pady=15)

    # Source Store
    source_frame = tk.Frame(store_selection_frame, bg='white')
    source_frame.pack(side='left', fill='x', expand=True, padx=(0, 20))

    tk.Label(source_frame, text="Transfer FROM (Source Store):", font=('Arial', 11, 'bold'),
             bg='white', fg='#e74c3c').pack(anchor='w', pady=(0, 5))

    source_store_var = tk.StringVar()
    source_store_combo = ttk.Combobox(source_frame, textvariable=source_store_var,
                                      width=35, state='readonly', font=('Arial', 11))
    source_store_combo.pack(fill='x', pady=(0, 10))

    source_info_label = tk.Label(source_frame, text="", font=('Arial', 9),
                                 bg='white', fg='#7f8c8d', wraplength=300)
    source_info_label.pack(anchor='w')

    # Destination Store
    dest_frame = tk.Frame(store_selection_frame, bg='white')
    dest_frame.pack(side='right', fill='x', expand=True, padx=(20, 0))

    tk.Label(dest_frame, text="Transfer TO (Destination Store):", font=('Arial', 11, 'bold'),
             bg='white', fg='#27ae60').pack(anchor='w', pady=(0, 5))

    dest_store_var = tk.StringVar()
    dest_store_combo = ttk.Combobox(dest_frame, textvariable=dest_store_var,
                                    width=35, state='readonly', font=('Arial', 11))
    dest_store_combo.pack(fill='x', pady=(0, 10))

    dest_info_label = tk.Label(dest_frame, text="", font=('Arial', 9),
                               bg='white', fg='#7f8c8d', wraplength=300)
    dest_info_label.pack(anchor='w')

    # Available Inventory Section
    inventory_section = tk.LabelFrame(new_main, text="Available Inventory",
                                      font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
    inventory_section.pack(fill='both', expand=True, pady=(0, 20))

    # Search and filter frame
    search_frame = tk.Frame(inventory_section, bg='white')
    search_frame.pack(fill='x', padx=15, pady=(15, 10))

    tk.Label(search_frame, text="Search Products:", font=('Arial', 10),
             bg='white').pack(side='left')

    search_var = tk.StringVar()
    search_entry = tk.Entry(search_frame, textvariable=search_var, font=('Arial', 10), width=25)
    search_entry.pack(side='left', padx=(5, 20))

    tk.Label(search_frame, text="Category:", font=('Arial', 10), bg='white').pack(side='left')
    category_var = tk.StringVar()
    category_combo = ttk.Combobox(search_frame, textvariable=category_var, width=20, state='readonly')
    category_combo['values'] = ['All', 'Cement', 'Steel', 'Sand', 'Gravel', 'Wood', 'Bricks', 'Electrical', 'Plumbing']
    category_combo.set('All')
    category_combo.pack(side='left', padx=(5, 20))

    tk.Label(search_frame, text="Only in stock:", font=('Arial', 10), bg='white').pack(side='left')
    in_stock_var = tk.BooleanVar(value=True)
    in_stock_cb = tk.Checkbutton(search_frame, variable=in_stock_var, bg='white')
    in_stock_cb.pack(side='left', padx=(5, 20))

    # Inventory treeview
    inventory_frame = tk.Frame(inventory_section, bg='white')
    inventory_frame.pack(fill='both', expand=True, padx=15, pady=(0, 15))

    inv_scroll_y = ttk.Scrollbar(inventory_frame)
    inv_scroll_y.pack(side='right', fill='y')
    inv_scroll_x = ttk.Scrollbar(inventory_frame, orient='horizontal')
    inv_scroll_x.pack(side='bottom', fill='x')

    inventory_tree = ttk.Treeview(inventory_frame, columns=(
        'ID', 'Store', 'Product', 'Category', 'Available', 'UOM', 'Unit Price', 'Last Update'
    ), show='headings', yscrollcommand=inv_scroll_y.set, xscrollcommand=inv_scroll_x.set)
    inventory_tree.pack(fill='both', expand=True)
    inv_scroll_y.config(command=inventory_tree.yview)
    inv_scroll_x.config(command=inventory_tree.xview)

    # Configure columns
    columns = [
        ('ID', 60, 'center'),
        ('Store', 200, 'w'),
        ('Product', 220, 'w'),
        ('Category', 120, 'center'),
        ('Available', 100, 'center'),
        ('UOM', 80, 'center'),
        ('Unit Price', 100, 'center'),
        ('Last Update', 140, 'center')
    ]
    for col, width, anchor in columns:
        inventory_tree.heading(col, text=col)
        inventory_tree.column(col, width=width, anchor=anchor)

    # Selection details section
    selection_section = tk.LabelFrame(new_main, text="Selected Item",
                                      font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
    selection_section.pack(fill='x', pady=(0, 20))

    transfer_details_frame = tk.Frame(selection_section, bg='white')
    transfer_details_frame.pack(fill='x', padx=15, pady=15)

    # Selected item labels
    selected_frame = tk.Frame(transfer_details_frame, bg='white')
    selected_frame.pack(side='left', fill='x', expand=True)

    tk.Label(selected_frame, text="Selected Product:", font=('Arial', 11, 'bold'),
             bg='white').grid(row=0, column=0, sticky='e', pady=5)
    selected_product_var = tk.StringVar(value="None")
    tk.Label(selected_frame, textvariable=selected_product_var, font=('Arial', 11),
             bg='white', fg='#2c3e50').grid(row=0, column=1, sticky='w', padx=(10, 0))

    tk.Label(selected_frame, text="Available Stock:", font=('Arial', 11, 'bold'),
             bg='white').grid(row=1, column=0, sticky='e', pady=5)
    available_stock_var = tk.StringVar(value="0")
    tk.Label(selected_frame, textvariable=available_stock_var, font=('Arial', 11),
             bg='white', fg='#2c3e50').grid(row=1, column=1, sticky='w', padx=(10, 0))

    tk.Label(selected_frame, text="Unit of Measure:", font=('Arial', 11, 'bold'),
             bg='white').grid(row=2, column=0, sticky='e', pady=5)
    uom_var = tk.StringVar(value="")
    tk.Label(selected_frame, textvariable=uom_var, font=('Arial', 11),
             bg='white', fg='#2c3e50').grid(row=2, column=1, sticky='w', padx=(10, 0))

    tk.Label(selected_frame, text="Unit Price (FCFA):", font=('Arial', 11, 'bold'),
             bg='white').grid(row=3, column=0, sticky='e', pady=5)
    unit_price_var = tk.StringVar(value="0")
    tk.Label(selected_frame, textvariable=unit_price_var, font=('Arial', 11),
             bg='white', fg='#2c3e50').grid(row=3, column=1, sticky='w', padx=(10, 0))

    # Transfer quantity
    tk.Label(selected_frame, text="Transfer Quantity:", font=('Arial', 11, 'bold'),
             bg='white').grid(row=4, column=0, sticky='e', pady=5)
    quantity_var = tk.StringVar()
    tk.Entry(selected_frame, textvariable=quantity_var, font=('Arial', 11), width=15).grid(row=4, column=1, sticky='w', padx=(10, 0))

    # Transfer reason/notes
    reason_notes_frame = tk.Frame(transfer_details_frame, bg='white')
    reason_notes_frame.pack(side='right', fill='x', expand=True)

    tk.Label(reason_notes_frame, text="Transfer Reason:", font=('Arial', 11, 'bold'),
             bg='white').grid(row=0, column=0, sticky='e', pady=5)
    reason_var = tk.StringVar()
    reason_combo = ttk.Combobox(reason_notes_frame, textvariable=reason_var, width=25, state='readonly')
    reason_combo['values'] = ['Stock Rebalancing', 'Store Restocking', 'Customer Request', 'Seasonal Adjustment', 'Emergency Supply']
    reason_combo.grid(row=0, column=1, sticky='w', padx=(10, 0))

    tk.Label(reason_notes_frame, text="Notes:", font=('Arial', 11, 'bold'),
             bg='white').grid(row=1, column=0, sticky='ne', pady=5)
    notes_text = tk.Text(reason_notes_frame, font=('Arial', 11), width=30, height=4)
    notes_text.grid(row=1, column=1, sticky='w', padx=(10, 0))

    # Action buttons for new transfer
    action_frame = tk.Frame(new_main, bg='white')
    action_frame.pack(fill='x', pady=(0, 10))

    add_to_transfer_btn = tk.Button(action_frame, text="Add to Transfer List",
                                    bg='#17a2b8', fg='white', width=18, font=('Arial', 10, 'bold'))
    add_to_transfer_btn.pack(side='left', padx=(0, 10))

    preview_transfer_btn = tk.Button(action_frame, text="Preview Transfer",
                                     bg='#6f42c1', fg='white', width=16, font=('Arial', 10, 'bold'))
    preview_transfer_btn.pack(side='left', padx=(0, 10))

    execute_transfer_btn = tk.Button(action_frame, text="Execute Transfer",
                                     bg='#28a745', fg='white', width=16, font=('Arial', 10, 'bold'))
    execute_transfer_btn.pack(side='left', padx=(0, 10))

    clear_transfer_btn = tk.Button(action_frame, text="Clear All",
                                   bg='#dc3545', fg='white', width=12, font=('Arial', 10, 'bold'))
    clear_transfer_btn.pack(side='right')

    # Current Transfer List
    transfer_list_section = tk.LabelFrame(new_main, text="Current Transfer List",
                                          font=('Arial', 12, 'bold'), bg='white', fg='#2c3e50')
    transfer_list_section.pack(fill='both', expand=True)

    transfer_list_frame = tk.Frame(transfer_list_section, bg='white')
    transfer_list_frame.pack(fill='both', expand=True, padx=15, pady=15)

    # Transfer list treeview
    list_scroll_y = ttk.Scrollbar(transfer_list_frame)
    list_scroll_y.pack(side='right', fill='y')
    list_scroll_x = ttk.Scrollbar(transfer_list_frame, orient='horizontal')
    list_scroll_x.pack(side='bottom', fill='x')

    transfer_list_tree = ttk.Treeview(transfer_list_frame,
                                      columns=('Item ID', 'Product', 'Quantity', 'UOM', 'Unit Price', 'Total', 'Reason', 'Notes'),
                                      show='headings', yscrollcommand=list_scroll_y.set, xscrollcommand=list_scroll_x.set)
    transfer_list_tree.pack(fill='both', expand=True)
    list_scroll_y.config(command=transfer_list_tree.yview)
    list_scroll_x.config(command=transfer_list_tree.xview)

    # Configure transfer list columns
    list_columns = [
        ('Item ID', 80, 'center'),
        ('Product', 220, 'w'),
        ('Quantity', 100, 'center'),
        ('UOM', 80, 'center'),
        ('Unit Price', 100, 'center'),
        ('Total', 120, 'center'),
        ('Reason', 180, 'w'),
        ('Notes', 240, 'w')
    ]
    for col, width, anchor in list_columns:
        transfer_list_tree.heading(col, text=col)
        transfer_list_tree.column(col, width=width, anchor=anchor)

    # Transfer list summary
    summary_frame = tk.Frame(transfer_list_section, bg='#ecf0f1', relief='raised', bd=1)
    summary_frame.pack(fill='x')
    total_items_label = tk.Label(summary_frame, text="Items: 0", font=('Arial', 10, 'bold'), bg='#ecf0f1')
    total_items_label.pack(side='left', padx=15, pady=8)
    total_value_label = tk.Label(summary_frame, text="Total: 0 FCFA", font=('Arial', 10, 'bold'), bg='#ecf0f1')
    total_value_label.pack(side='left', padx=15, pady=8)

    # =================== TAB 2: TRANSFER HISTORY ===================
    history_main = tk.Frame(history_frame, bg='white', padx=20, pady=20)
    history_main.pack(fill='both', expand=True)

    history_controls = tk.Frame(history_main, bg='white')
    history_controls.pack(fill='x', pady=(0, 10))

    tk.Label(history_controls, text="Filter by Store:", font=('Arial', 10), bg='white').pack(side='left')
    history_store_var = tk.StringVar()
    history_store_combo = ttk.Combobox(history_controls, textvariable=history_store_var, width=30, state='readonly')
    history_store_combo.pack(side='left', padx=(5, 15))

    tk.Label(history_controls, text="Period:", font=('Arial', 10), bg='white').pack(side='left')
    history_period_var = tk.StringVar()
    history_period_combo = ttk.Combobox(history_controls, textvariable=history_period_var, width=20, state='readonly')
    history_period_combo['values'] = ['All Time', 'Last 12 Months', 'This Year', 'Last 6 Months', 'This Month']
    history_period_combo.set('All Time')
    history_period_combo.pack(side='left', padx=(5, 15))

    tk.Label(history_controls, text="Search:", font=('Arial', 10), bg='white').pack(side='left')
    history_search_var = tk.StringVar()
    history_search_entry = tk.Entry(history_controls, textvariable=history_search_var, font=('Arial', 10), width=20)
    history_search_entry.pack(side='left', padx=(5, 15))

    load_history_btn = tk.Button(history_controls, text="Load History", font=('Arial', 10), bg='#3498db', fg='white', width=12)
    load_history_btn.pack(side='left')

    # History treeview
    history_tree_frame = tk.Frame(history_main, bg='white')
    history_tree_frame.pack(fill='both', expand=True)

    history_scroll_y = ttk.Scrollbar(history_tree_frame)
    history_scroll_y.pack(side='right', fill='y')
    history_tree = ttk.Treeview(history_tree_frame,
                                columns=('Transfer ID', 'Date', 'From Store', 'To Store',
                                         'Items', 'Total Value', 'Status', 'Initiated By'),
                                show='headings', yscrollcommand=history_scroll_y.set)
    history_tree.pack(fill='both', expand=True)
    history_scroll_y.config(command=history_tree.yview)

    for col, width, anchor in [
        ('Transfer ID', 100, 'center'),
        ('Date', 150, 'center'),
        ('From Store', 220, 'w'),
        ('To Store', 220, 'w'),
        ('Items', 80, 'center'),
        ('Total Value', 120, 'center'),
        ('Status', 120, 'center'),
        ('Initiated By', 160, 'w')
    ]:
        history_tree.heading(col, text=col)
        history_tree.column(col, width=width, anchor=anchor)

    # =================== TAB 3: PENDING TRANSFERS ===================
    pending_main = tk.Frame(pending_frame, bg='white', padx=20, pady=20)
    pending_main.pack(fill='both', expand=True)

    tk.Label(pending_main, text="Transfers Requiring Your Action", font=('Arial', 12, 'bold'),
             bg='white', fg='#2c3e50').pack(anchor='w', pady=(0, 15))

    # Pending transfers treeview
    pending_tree_frame = tk.Frame(pending_main, bg='white')
    pending_tree_frame.pack(fill='both', expand=True)

    pending_scroll_y = ttk.Scrollbar(pending_tree_frame)
    pending_scroll_y.pack(side='right', fill='y')
    pending_tree = ttk.Treeview(pending_tree_frame,
                                columns=('Transfer ID', 'Date', 'From Store', 'Items',
                                         'Total Value', 'Action Required'),
                                show='headings', yscrollcommand=pending_scroll_y.set)
    pending_tree.pack(fill='both', expand=True)
    pending_scroll_y.config(command=pending_tree.yview)

    for col, width, anchor in [
        ('Transfer ID', 100, 'center'),
        ('Date', 150, 'center'),
        ('From Store', 240, 'w'),
        ('Items', 80, 'center'),
        ('Total Value', 120, 'center'),
        ('Action Required', 160, 'center')
    ]:
        pending_tree.heading(col, text=col)
        pending_tree.column(col, width=width, anchor=anchor)

    # Pending actions
    pending_actions_frame = tk.Frame(pending_main, bg='white')
    pending_actions_frame.pack(fill='x', pady=(10, 0))
    approve_btn = tk.Button(pending_actions_frame, text="Approve Transfer", font=('Arial', 10), bg='#28a745', fg='white', width=16)
    approve_btn.pack(side='left', padx=(0, 10))
    reject_btn = tk.Button(pending_actions_frame, text="Reject Transfer", font=('Arial', 10), bg='#dc3545', fg='white', width=16)
    reject_btn.pack(side='left')

    # Storage for transfer list items
    current_transfer_items = []

    # Helper functions
    def load_stores():
        conn = self.db_manager.create_connection()
        cur = conn.cursor()
        cur.execute("SELECT id, name, location FROM stores WHERE status='Active'")
        stores = cur.fetchall()
        conn.close()

        store_names = [f"{sid} - {name}" for (sid, name, _loc) in stores]
        source_store_combo['values'] = store_names
        dest_store_combo['values'] = store_names
        history_store_combo['values'] = ['All'] + store_names

        # Set default selections if available
        if stores:
            source_store_combo.set(f"{stores[0][0]} - {stores[0][1]}")
            dest_store_combo.set(f"{stores[-1][0]} - {stores[-1][1]}")
        return {sid: (name, loc) for sid, name, loc in stores}

    def update_store_info(*args):
        src_text = source_store_var.get()
        dst_text = dest_store_var.get()
        if src_text:
            sid = int(src_text.split(" - ")[0])
            # Normally would include more detailed info; keep concise
            source_info_label.config(text=f"Store ID: {sid}")
        if dst_text:
            did = int(dst_text.split(" - ")[0])
            dest_info_label.config(text=f"Store ID: {did}")

    def load_inventory():
        src_text = source_store_var.get()
        if not src_text:
            return
        sid = int(src_text.split(" - ")[0])
        q = """SELECT i.id, s.name, m.name, m.category, i.quantity, m.unit,
                       i.unit_price, i.last_updated
                FROM inventory i
                JOIN stores s ON i.store_id=s.id
                JOIN building_materials m ON i.material_id=m.id
                WHERE i.store_id=?
            """
        params = [sid]
        if search_var.get().strip():
            q += " AND (m.name LIKE ? OR m.category LIKE ?)"
            sterm = f"%{search_var.get().strip()}%"
            params.extend([sterm, sterm])
        if category_var.get() and category_var.get() != 'All':
            q += " AND m.category=?"
            params.append(category_var.get())
        if in_stock_var.get():
            q += " AND i.quantity>0"
        q += " ORDER BY m.name"
        conn = self.db_manager.create_connection(); cur = conn.cursor()
        cur.execute(q, params)
        rows = cur.fetchall(); conn.close()
        # Populate
        for i in inventory_tree.get_children():
            inventory_tree.delete(i)
        for r in rows:
            inventory_tree.insert('', 'end', values=r)

    def on_inventory_select(event):
        sel = inventory_tree.selection()
        if not sel:
            return
        row = inventory_tree.item(sel[0])['values']
        # Map row to fields
        item_id, store_name, product_name, category, available, uom, price, last_update = row
        selected_product_var.set(product_name)
        available_stock_var.set(str(available))
        uom_var.set(uom)
        unit_price_var.set(f"{price}")

    # Add item to transfer list
    def add_to_transfer():
        sel = inventory_tree.selection()
        if not sel:
            messagebox.showwarning("Select Item", "Please select an item from inventory")
            return
        if not quantity_var.get().strip():
            messagebox.showerror("Error", "Please enter transfer quantity")
            return
        if not reason_var.get().strip():
            messagebox.showerror("Error", "Please select transfer reason")
            return
        try:
            transfer_qty = float(quantity_var.get())
            if transfer_qty <= 0:
                raise ValueError
        except Exception:
            messagebox.showerror("Validation", "Transfer quantity must be a positive number")
            return
        current_stock = float(available_stock_var.get() or 0)
        if transfer_qty > current_stock:
            messagebox.showerror("Stock", f"Transfer quantity ({transfer_qty}) exceeds available stock ({current_stock})")
            return
        # Check if item already in transfer list
        for existing_item in current_transfer_items:
            if existing_item['item_id'] == inventory_tree.item(sel[0])['values'][0]:
                messagebox.showwarning("Duplicate", "Item already in transfer list. Remove it first to add with different quantity.")
                return
        row = inventory_tree.item(sel[0])['values']
        item_id, store_name, product_name, category, available, uom, price, last_update = row
        total = transfer_qty * float(price)
        item = {
            'item_id': item_id,
            'product': product_name,
            'quantity': transfer_qty,
            'uom': uom,
            'unit_price': float(price),
            'total': total,
            'reason': reason_var.get().strip(),
            'notes': notes_text.get('1.0', 'end-1c').strip()
        }
        current_transfer_items.append(item)
        transfer_list_tree.insert('', 'end', values=(item['item_id'], item['product'], item['quantity'], item['uom'],
                                                     item['unit_price'], item['total'], item['reason'], item['notes']))
        # Reset quantity/notes
        quantity_var.set("")
        notes_text.delete('1.0', 'end')
        update_transfer_summary()

    def update_transfer_summary():
        total_items = len(current_transfer_items)
        total_value = sum(i['total'] for i in current_transfer_items)
        total_items_label.config(text=f"Items: {total_items}")
        total_value_label.config(text=f"Total: {total_value:,.0f} FCFA")

    def preview_transfer():
        if not current_transfer_items:
            messagebox.showinfo("Transfer", "Add items to transfer list first")
            return
        # Preview window
        preview = tk.Toplevel(transfer_window)
        preview.title("Transfer Preview")
        preview.geometry("700x600")
        preview.configure(bg='white')
        preview.grab_set()
        frame = tk.Frame(preview, bg='white', padx=20, pady=20)
        frame.pack(fill='both', expand=True)
        src = source_store_var.get() or 'N/A'
        dst = dest_store_var.get() or 'N/A'
        tk.Label(frame, text=f"From: {src}", font=('Arial', 11, 'bold'), bg='white').pack(anchor='w')
        tk.Label(frame, text=f"To:   {dst}", font=('Arial', 11, 'bold'), bg='white').pack(anchor='w', pady=(0, 10))
        tv = ttk.Treeview(frame, columns=('Product','Qty','UOM','Unit Price','Total','Reason'), show='headings')
        for col, w in [('Product',220),('Qty',80),('UOM',80),('Unit Price',100),('Total',100),('Reason',180)]:
            tv.heading(col, text=col)
            tv.column(col, width=w, anchor='center')
        tv.pack(fill='both', expand=True)
        for it in current_transfer_items:
            tv.insert('', 'end', values=(it['product'], it['quantity'], it['uom'], it['unit_price'], it['total'], it['reason']))
        tk.Button(frame, text="Close", command=preview.destroy, bg='#6c757d', fg='white').pack(pady=10)

    def execute_transfer():
        # Only retail store owners can approve/execute transfers
        if not self.current_user or self.current_user.get('role') != 'retail_store':
            try:
                self.log_audit_action(self.current_user['id'] if self.current_user else None,
                                      "Transfer Request",
                                      "Non-retail user attempted to execute transfer; request requires approval by retail store owner.")
            except Exception:
                pass
            messagebox.showinfo("Approval Required", "Only Retail Store Owners can approve and execute transfers. Your request has been noted and requires approval.")
            return
        if not current_transfer_items:
            messagebox.showwarning("Transfer", "No items to transfer")
            return
        if not source_store_var.get() or not dest_store_var.get():
            messagebox.showwarning("Stores", "Select both source and destination stores")
            return
        if source_store_var.get() == dest_store_var.get():
            messagebox.showerror("Stores", "Source and destination cannot be the same")
            return
        src_id = int(source_store_var.get().split(" - ")[0])
        dst_id = int(dest_store_var.get().split(" - ")[0])
        try:
            conn = self.db_manager.create_connection(); cur = conn.cursor()
            # For each item: decrement from src inventory, increment/add to dst inventory
            for item in current_transfer_items:
                # Get material_id by joining inventory id
                cur.execute("SELECT material_id FROM inventory WHERE id=?", (item['item_id'],))
                row = cur.fetchone()
                if not row:
                    raise Exception("Inventory item not found")
                mat_id = row[0]
                qty = float(item['quantity'])
                # Decrement source
                cur.execute("UPDATE inventory SET quantity = quantity - ?, last_updated=? WHERE id=? AND store_id=?",
                            (qty, datetime.now().isoformat(sep=' '), item['item_id'], src_id))
                # Increment destination: if not exists, create with same price/uom
                cur.execute("SELECT id FROM inventory WHERE store_id=? AND material_id=?", (dst_id, mat_id))
                dst_row = cur.fetchone()
                if dst_row:
                    cur.execute("UPDATE inventory SET quantity = quantity + ?, last_updated=? WHERE id=?",
                                (qty, datetime.now().isoformat(sep=' '), dst_row[0]))
                else:
                    cur.execute("SELECT unit, ? as price FROM building_materials WHERE id=?", (item['unit_price'], mat_id))
                    uom = item['uom']
                    cur.execute("INSERT INTO inventory (store_id, material_id, quantity, unit_price, last_updated) VALUES (?,?,?,?,?)",
                                (dst_id, mat_id, qty, item['unit_price'], datetime.now().isoformat(sep=' ')))
            conn.commit(); conn.close()
            try:
                self.log_audit_action(self.current_user['id'], "Transfer Products",
                                      json.dumps({
                                          'from_store': src_id,
                                          'to_store': dst_id,
                                          'items': current_transfer_items
                                      }))
            except Exception:
                pass
            messagebox.showinfo("Transfer", "Transfer completed successfully")
            # Clear list and refresh views
            clear_transfer_list(); load_inventory(); load_transfer_history(); load_pending_transfers()
        except Exception as e:
            try:
                messagebox.showerror("Transfer Failed", str(e))
            except Exception:
                pass

    def clear_transfer_list():
        current_transfer_items.clear()
        for i in transfer_list_tree.get_children():
            transfer_list_tree.delete(i)
        update_transfer_summary()

    def remove_from_transfer():
        sel = transfer_list_tree.selection()
        if not sel:
            return
        transfer_list_tree.delete(sel[0])
        # Also remove from current_transfer_items by matching Item ID
        removed_id = None
        try:
            removed_id = transfer_list_tree.item(sel[0])['values'][0]
        except Exception:
            pass
        if removed_id is not None:
            for idx, it in enumerate(current_transfer_items):
                if it['item_id'] == removed_id:
                    current_transfer_items.pop(idx)
                    break
        update_transfer_summary()

    def load_transfer_history():
        # Placeholder sample data until transaction logging is implemented
        for i in history_tree.get_children():
            history_tree.delete(i)
        sample = [
            ("TR-2025-0001", "2025-02-15 10:30", "Store A - Downtown", "Store B - Uptown", 3, 491000, "Completed", self.current_user['username']),
            ("TR-2025-0002", "2025-02-16 14:20", "Store B - Uptown", "Store C - Market", 2, 215000, "Completed", self.current_user['username'])
        ]
        for r in sample:
            history_tree.insert('', 'end', values=r)

    def load_pending_transfers():
        # Placeholder data for pending transfers
        for i in pending_tree.get_children():
            pending_tree.delete(i)
        pending = [
            ("TR-2025-0003", "2025-02-20 09:15", "Store A - Downtown", 2, 180000, "Approval Needed"),
            ("TR-2025-0004", "2025-02-21 11:45", "Store C - Market", 1, 65000, "Approval Needed")
        ]
        for r in pending:
            pending_tree.insert('', 'end', values=r)

    def show_transfer_list_menu(event):
        sel = transfer_list_tree.selection()
        if not sel:
            return
        menu = tk.Menu(transfer_list_tree, tearoff=0)
        menu.add_command(label="Remove Item", command=remove_from_transfer)
        menu.tk_popup(event.x_root, event.y_root)

    def view_transfer_details(source):
        if source == 'history':
            selection = history_tree.selection()
            tree = history_tree
        else:
            selection = pending_tree.selection()
            tree = pending_tree
        if not selection:
            return
        transfer_id = tree.item(selection[0])['values'][0]
        # Create details window
        details_window = tk.Toplevel(transfer_window)
        details_window.title(f"Transfer Details - {transfer_id}")
        details_window.geometry("600x500")
        details_window.configure(bg='#f8f9fa')
        details_window.grab_set()
        details_window.transient(transfer_window)
        # Details content
        details_frame = tk.Frame(details_window, bg='#f8f9fa', padx=30, pady=20)
        details_frame.pack(fill='both', expand=True)
        tk.Label(details_frame, text=f"Transfer Details - {transfer_id}",
                 font=('Arial', 16, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))
        details_text = tk.Text(details_frame, height=20, width=70, font=('Arial', 10),
                               wrap='word', state='normal', bg='white')
        details_text.pack(fill='both', expand=True, pady=(0, 15))
        details_content = f"""
Transfer Information:
Transfer ID: {transfer_id}
Date: 2024-12-01 12:00:01
Status: Completed

Stores:
From: Store A - Downtown Branch
  Location: Yaoundé Central Market
  Manager: John Doe
  Phone: +237 6XX XXX XXX

To: Store B - Uptown Branch  
  Location: Yaoundé Bastos
  Manager: Jane Smith
  Phone: +237 6YY YYY YYY

Transferred Items:
1. Cement Portland - 50 bags @ 6,500 FCFA = 325,000 FCFA
2. Steel Rebar 10mm - 20 pieces @ 6,800 FCFA = 136,000 FCFA
3. Sand (River) - 2 cubic meters @ 15,000 FCFA = 30,000 FCFA

Total Value: 491,000 FCFA

Transfer Reason: Stock Rebalancing
Notes: Emergency restocking for upcoming project
Initiated By: {self.current_user['full_name']}
Approved By: System (Auto-approved)

Status Timeline:
- Created: 2024-12-01 12:00:01
- Approved: 2024-12-01 12:01:15  
- In Transit: 2024-12-01 13:30:00
- Completed: 2024-12-01 15:45:30
"""
        details_text.insert('1.0', details_content)
        details_text.config(state='disabled')
        tk.Button(details_frame, text="Close", font=('Arial', 11, 'bold'),
                  bg='#6c757d', fg='white', width=15,
                  command=details_window.destroy).pack()

    # Action buttons frame at bottom
    action_buttons_frame = tk.Frame(main_frame, bg='white')
    action_buttons_frame.pack(fill='x', pady=10)

    help_btn = tk.Button(action_buttons_frame, text="Transfer Guide", font=('Arial', 10),
                         bg='#17a2b8', fg='white', width=12)
    help_btn.pack(side='left')

    export_all_btn = tk.Button(action_buttons_frame, text="Export All Data", font=('Arial', 10),
                               bg='#6f42c1', fg='white', width=12)
    export_all_btn.pack(side='left', padx=(10, 0))

    close_btn = tk.Button(action_buttons_frame, text="Close", font=('Arial', 10),
                          bg='#dc3545', fg='white', width=10,
                          command=transfer_window.destroy)
    close_btn.pack(side='right')

    # Help function
    def show_transfer_guide():
        guide_window = tk.Toplevel(transfer_window)
        guide_window.title("Product Transfer Guide")
        guide_window.geometry("600x500")
        guide_window.configure(bg='#f8f9fa')
        guide_window.grab_set()
        guide_window.transient(transfer_window)
        guide_frame = tk.Frame(guide_window, bg='#f8f9fa', padx=30, pady=20)
        guide_frame.pack(fill='both', expand=True)
        tk.Label(guide_frame, text="Product Transfer Guide",
                 font=('Arial', 16, 'bold'), bg='#f8f9fa', fg='#2c3e50').pack(pady=(0, 20))
        guide_content = """
HOW TO TRANSFER PRODUCTS BETWEEN STORES:

1. SELECT STORES
   • Choose source store (where products are coming from)
   • Choose destination store (where products are going to)
   • Both stores must be owned or managed by you

2. SELECT PRODUCTS
   • Browse available inventory in source store
   • Use search and category filters to find items
   • Click on items to see details and stock levels

3. ADD TO TRANSFER
   • Enter transfer quantity (cannot exceed available stock)
   • Select transfer reason from dropdown
   • Add optional notes for additional context
   • Click "Add to Transfer List"

4. REVIEW & EXECUTE
   • Review all items in transfer list
   • Check total value and item count
   • Use "Preview Transfer" to see full details
   • Click "Execute Transfer" to complete

TRANSFER REASONS:
• Stock Rebalancing: Distribute inventory evenly
• Store Restocking: Supply low-stock locations
• Customer Request: Move items closer to customers
• Seasonal Adjustment: Prepare for busy periods
• Emergency Supply: Urgent restocking needs

IMPORTANT NOTES:
• Transfers update inventory in real-time
• Source store stock decreases immediately
• Destination store stock increases immediately
• All transfers are logged in history
• Managers can approve/reject incoming transfers

PERMISSIONS:
• Store owners can transfer between their stores
• Store managers can receive transfers
• All transfers require proper authorization
"""
        guide_text = tk.Text(guide_frame, height=20, width=70, font=('Arial', 9),
                             wrap='word', state='normal', bg='white')
        guide_text.pack(fill='both', expand=True, pady=(0, 15))
        guide_text.insert('1.0', guide_content)
        guide_text.config(state='disabled')
        tk.Button(guide_frame, text="Close", font=('Arial', 11, 'bold'),
                  bg='#6c757d', fg='white', width=15,
                  command=guide_window.destroy).pack()

    help_btn.config(command=show_transfer_guide)

    # Keyboard shortcuts
    transfer_window.bind('<F5>', lambda e: [load_stores(), load_inventory(), load_transfer_history(),
                                            load_pending_transfers()])
    transfer_window.bind('<Escape>', lambda e: transfer_window.destroy())

    # Initial data loading
    store_info = load_stores()
    load_transfer_history()
    load_pending_transfers()

    # Log the action
    self.log_audit_action(
        self.current_user['id'],
        "Access Product Transfer",
        "Opened product transfer management interface"
    )


# --- Late bindings to attach module-level UI functions to CBPMApp ---
try:
    # Ensure menu callbacks like self.show_view_inventory exist on CBPMApp
    CBPMApp.show_view_inventory = show_view_inventory  # type: ignore[name-defined]
except Exception:
    pass



# --- Ensure CBPMApp has a safe show_view_inventory method ---
try:
    def _basic_show_view_inventory(self, preselected_store_id=None):
        """Always-present entry point for Inventory Overview.
        Tries a richer view if available; otherwise falls back to basic inventory.
        """
        try:
            # Prefer an advanced in-class implementation if one exists in this build
            if hasattr(self, '_impl_show_view_inventory') and callable(getattr(self, '_impl_show_view_inventory')):
                return self._impl_show_view_inventory(preselected_store_id=preselected_store_id)
            # If an alternative method name was used
            if hasattr(self, 'open_view_inventory') and callable(getattr(self, 'open_view_inventory')):
                return self.open_view_inventory(preselected_store_id=preselected_store_id)
            # As a last resort, show the basic inventory manager
            return self.show_inventory()
        except Exception as e:
            try:
                from tkinter import messagebox as _mb
                _mb.showerror("Inventory", f"Failed to open inventory: {str(e)}")
            except Exception:
                pass
            return None
    if not hasattr(CBPMApp, 'show_view_inventory'):
        CBPMApp.show_view_inventory = _basic_show_view_inventory  # type: ignore[attr-defined]
except Exception:
    pass

# --- Backward compatibility: singular show_manage_job alias ---
try:
    if hasattr(CBPMApp, 'show_manage_jobs') and not hasattr(CBPMApp, 'show_manage_job'):
        CBPMApp.show_manage_job = CBPMApp.show_manage_jobs  # type: ignore[attr-defined]
except Exception:
    pass

# --- Ensure CBPMApp has a safe show_manage_jobs method ---
try:
    def _basic_show_manage_jobs(self):
        """Always-present entry point for Manage Jobs.
        Tries a richer view if available; otherwise shows a minimal management window
        so users never see an 'unavailable' dialog.
        """
        try:
            # Prefer in-class full implementation if it exists in this build
            if hasattr(self, '_impl_show_manage_jobs') and callable(getattr(self, '_impl_show_manage_jobs')):
                return self._impl_show_manage_jobs()
            if hasattr(self, 'show_manage_jobs') and callable(getattr(self, 'show_manage_jobs')) and _basic_show_manage_jobs is not getattr(self, 'show_manage_jobs'):
                # If the full method is present (and not this fallback), call it
                return getattr(self, 'show_manage_jobs')()
            # Legacy alias name
            if hasattr(self, 'show_manage_job') and callable(getattr(self, 'show_manage_job')):
                return self.show_manage_job()
        except Exception as e:
            # If preferred paths fail, fall back to a minimal window instead of a blocking error
            pass
        # Minimal fallback UI
        try:
            import tkinter as _tk
            from tkinter import ttk as _ttk
            from tkinter import messagebox as _mb
            win = _tk.Toplevel(self.root)
            win.title("Manage Jobs")
            win.geometry("700x420")
            win.configure(bg='white')
            win.grab_set()
            header = _tk.Frame(win, bg='white')
            header.pack(fill='x', padx=10, pady=10)
            _tk.Label(header, text="Manage My Jobs (Basic)", font=('Arial', 16, 'bold'), bg='white').pack(side='left')
            body = _tk.Frame(win, bg='white')
            body.pack(fill='both', expand=True, padx=10, pady=10)
            _tk.Label(body, text="A full Manage Jobs interface was not found in this build.\n"
                               "You can still view your posted jobs in this basic list.",
                      bg='white', fg='#2c3e50').pack(anchor='w', pady=(0,8))
            cols = ("ID","Title","Status","Posted","Deadline")
            tree = _ttk.Treeview(body, columns=cols, show='headings')
            for c in cols:
                tree.heading(c, text=c)
                tree.column(c, width=120 if c!="Title" else 260)
            tree.pack(fill='both', expand=True, side='left')
            sy = _ttk.Scrollbar(body, orient='vertical', command=tree.yview)
            tree.configure(yscrollcommand=sy.set); sy.pack(side='right', fill='y')
            # Load jobs belonging to current user (or all if admin)
            try:
                role = getattr(self, 'current_user', {}).get('role') if getattr(self, 'current_user', None) else None
                uid = getattr(self, 'current_user', {}).get('id') if getattr(self, 'current_user', None) else None
                conn = self.db_manager.create_connection(); cur = conn.cursor()
                sql = ("SELECT id, title, status, COALESCE(posted_date,''), COALESCE(deadline,'') FROM jobs ")
                params = []
                if role != 'administrator' and uid:
                    sql += "WHERE employer_id = ? ORDER BY posted_date DESC"; params.append(uid)
                else:
                    sql += "ORDER BY posted_date DESC"
                cur.execute(sql, params)
                for r in cur.fetchall():
                    tree.insert('', 'end', values=r)
                conn.close()
            except Exception:
                pass
            # Close button
            btns = _tk.Frame(win, bg='white'); btns.pack(fill='x', padx=10, pady=10)
            _tk.Button(btns, text="Close", bg="#dc3545", fg="white", command=win.destroy).pack(side='right')
            # Audit log
            try:
                if getattr(self, 'current_user', None):
                    self.log_audit_action(self.current_user['id'], "Open Manage Jobs (Basic)", "")
            except Exception:
                pass
            return None
        except Exception:
            try:
                from tkinter import messagebox as _mb
                _mb.showinfo("Jobs", "Manage Jobs opened (basic mode).")
            except Exception:
                pass
            return None

    # If for some reason the class lacks show_manage_jobs, attach the basic one
    if not hasattr(CBPMApp, 'show_manage_jobs'):
        CBPMApp.show_manage_jobs = _basic_show_manage_jobs  # type: ignore[attr-defined]
    # Stable dispatcher always available for menus
    if not hasattr(CBPMApp, 'open_manage_jobs'):
        CBPMApp.open_manage_jobs = _basic_show_manage_jobs  # type: ignore[attr-defined]
except Exception:
    pass
